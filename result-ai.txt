// Nemesis-3b (Aegis-Phalanx) – 강화형 휴리스틱 + 소형 DNN 보정
// - tank/enemies/allies/bulletInfo 모두를 입력으로 32→16→4 MLP를 구성하고, 
//   사격 지터와 측면 이동 바이어스를 소폭 보정합니다(핵심 전술은 휴리스틱).
// - 전술: 전 팀 집중사격(최저 체력), 리드샷, 총알 회피, 아군 간격, 카이팅/접근/측면, 벽 반발.

(function(){
  // 공통 유틸
  function ang(a){ a%=360; if(a<0)a+=360; return a; }
  function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(enemies){ if(!enemies.length) return null; // 최저 체력 → y → x
    let best=enemies[0]; for(const e of enemies){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tank,b){ // 접근 중이며 경로 근접한 탄만 위협
    const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv;
    const proj = dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d < (tank.size*0.5+8); } return false;
  }
  function wallRepel(tx,ty){ const W=900,H=600,p=60; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }

  // 소형 MLP: 32→16→4 tanh, 결정론적 시드
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }
  function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }
  function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tank,enemies,allies,bulletInfo){ const W=900,H=600;
    const self=[tank.x/W, tank.y/H, clamp(tank.health/200,0,1), (tank.type===0?1:0), (tank.type===1?1:0), (tank.type===2?1:0), clamp(tank.size/50,0,1), clamp(allies.length/5,0,1)];
    const es=enemies.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[];
    for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push((e.x-tank.x)/W,(e.y-tank.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); }
    const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[];
    for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tank.x)/W,(a.y-tank.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); }
    const bs=bulletInfo.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,b.vx/v,b.vy/v); } else bf.push(0,0,0,0); }
    const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tank,enemies,allies,bulletInfo){ const x=buildFeat(seed,tank,enemies,allies,bulletInfo);
    const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); const o=mv(initW(seed^0x6a09e667,16,4),h); return o; }

  // 로봇 생성기
  function makeBot(label, role, cfgSeed, pref){
    const mem={ last:null }; // 타깃 추정용
    function leadAngle(tank,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot((tgt.x-mem.last.x),(tgt.y-mem.last.y))<50){ vx=tgt.x-mem.last.x; vy=tgt.y-mem.last.y; }
      const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } }
      const px=dx+vx*t, py=dy+vy*t; mem.last={x:tgt.x,y:tgt.y}; return deg(px,py); }

    function name(){ return label; }
    function type(){ return role; }
    function update(tank,enemies,allies,bulletInfo){
      // DNN 보정값 산출
      const o=nn(cfgSeed,tank,enemies,allies,bulletInfo);
      const jitterScale=clamp(0.8+0.25*Math.tanh(o[0]),0.6,1.1); // 사격 지터 스케일
      const sideBias=clamp(0.0+25*Math.tanh(o[1]),-25,25);      // 측면 이동 편향(도)

      // 타깃 선정(전 팀 동일)
      const tgt = pickTarget(enemies) || closest(enemies);
      if(tgt){
        const base = leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y);
        const jj = ((tank.x*31+tank.y*17+cfgSeed)%23-11) * 0.28 * jitterScale;
        tank.fire(ang(base + jj));
      }

      // 이동 우선순위: 총알 회피 > 아군 간격 > 교전(카이팅/접근/측면) + 벽 반발
      let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
      // 총알 회피: 가장 위협적인 탄 기준 수직 회피
      let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
      if(hot){ const a=deg(hot.vx,hot.vy); const dir=((tank.x+tank.y+cfgSeed)&1)?1:-1; const cand=[a+90+dir*12, a-90-dir*12, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
      // 아군 간격 유지
      if(allies.length){ const al=closest(allies); if(al && al.distance<64){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+25)) return; if(tryMove(av-25)) return; } }
      // 교전
      if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y);
        const near=pref.near, far=pref.far;
        if(d<near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return; }
        else if(d>far){ if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return; }
        else { const side=to + (pref.side + sideBias); if(tryMove(side)) return; if(tryMove(side+22)) return; if(tryMove(side-22)) return; }
      }
      // 벽 반발/기본
      const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0;
      const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias];
      for(const p of prefDir){ if(tryMove(p)) return; }
    }
    return { name, type, update };
  }

  // 6 로봇 내보내기 블록들(파일 파서에 맞춰 각 블록은 name/type/update만 포함)

  // 1
  (function(){ const B=makeBot('Aegis T1', Type.TANKER, 1117, { near: 190, far: 270, side: 16 });
    function name(){ return B.name(); } function type(){ return B.type(); } function update(t,e,a,b){ return B.update(t,e,a,b); } })();
  function name(){ return 'Aegis T1'; }
  function type(){ return Type.TANKER; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis T1', Type.TANKER, 1117, { near: 190, far: 270, side: 16 }); B.update(tank,enemies,allies,bulletInfo); })(); }

  // 2
  function name(){ return 'Aegis T2'; }
  function type(){ return Type.TANKER; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis T2', Type.TANKER, 2029, { near: 205, far: 285, side: 14 }); B.update(tank,enemies,allies,bulletInfo); })(); }

  // 3
  function name(){ return 'Aegis D1'; }
  function type(){ return Type.DEALER; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis D1', Type.DEALER, 3031, { near: 230, far: 350, side: 22 }); B.update(tank,enemies,allies,bulletInfo); })(); }

  // 4
  function name(){ return 'Aegis D2'; }
  function type(){ return Type.DEALER; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis D2', Type.DEALER, 4051, { near: 235, far: 355, side: -20 }); B.update(tank,enemies,allies,bulletInfo); })(); }

  // 5
  function name(){ return 'Aegis D3'; }
  function type(){ return Type.DEALER; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis D3', Type.DEALER, 4909, { near: 240, far: 360, side: 18 }); B.update(tank,enemies,allies,bulletInfo); })(); }

  // 6
  function name(){ return 'Aegis N1'; }
  function type(){ return Type.NORMAL; }
  function update(tank,enemies,allies,bulletInfo){ (function(){ const B=makeBot('Aegis N1', Type.NORMAL, 5821, { near: 210, far: 320, side: -16 }); B.update(tank,enemies,allies,bulletInfo); })(); }
})();

