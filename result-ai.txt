// Helios-Edge (AegisNet-L)
// - DNN(64→32→16→8, tanh) 경량 구조 + 휴리스틱 합성: 빠르고 일관된 교전
// - update(tank, enemies, allies, bulletInfo) 전체 파라미터를 사용하여 64차 특징 벡터 구성
// - 이동: 탄 회피(TTC/측면) + 벽 반발 + 아군 간격 + 목표 접근/이탈/궤도 벡터를 DNN 게이팅으로 혼합
// - 사격: 리드샷(속도 추정) + DNN 보정 각 + 소량 지터, 팀 전체 최소 체력 타겟에 집중
// - tank_battle_platform.html과 동일 포맷(function name/type/update) 6기 로봇

// ===== 로봇 1 (TANKER, front-anchor) =====
function name(){return 'Helios T1';}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){
    const U={};
    U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;};
    U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
    U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; };
    U.closest=(arr)=>{ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){md=e.distance;r=e;} } return r; };
    U.sortByDist=(a,b)=>a.distance-b.distance;
    U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; };
    U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; };
    U.tanhV=(v)=>{ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o; };
    U.wall=(x,y)=>{ const W=900,H=600,p=72; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<68){ const k=(68-d)/68; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.ttcDanger=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+6; const near=lat-rad; if(near>26) return 0; const tti=proj/(v+1e-6); return U.clamp(1/(1+0.6*tti),0,1)*U.clamp((26-Math.max(0,near))/26,0,1); };
    U.lead=(mem,tk,tgt)=>{ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(tgt.x-mem.last.x,tgt.y-mem.last.y)<140){ vx=tgt.x-mem.last.x; vy=tgt.y-mem.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; mem.last={x:tgt.x,y:tgt.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)];
      const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x.slice(0,64);
    };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA13,64,32), W2:U.initW(seed^0xB97,32,16), W3:U.initW(seed^0xC55,16,8) });
    U.fwd=(net,x)=>{ const h1=U.tanhV(U.mv(net.W1,x)); const h2=U.tanhV(U.mv(net.W2,h1)); return U.mv(net.W3,h2); };
    return U;
  }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71C07) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  // DNN 출력: [mvx,mvy, fvx,fvy, wTow,wAway,wCW,wCCW]
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]);
  const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=U.clamp((y[4]+1)/2,0,1), wAway=U.clamp((y[5]+1)/2,0,1), wCW=U.clamp((y[6]+1)/2,0,1), wCCW=U.clamp((y[7]+1)/2,0,1);

  // 타겟: 최소 체력 우선(동률 y→x)
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;

  // 사격: 리드샷 + DNN 보정 + 지터
  const aimHeur = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0;
  const aimNet = U.ang(U.deg(fvx,fvy));
  const jitter = ((tank.x*17 + tank.y*31 + 7)%23 - 11) * 0.25;
  tank.fire(U.ang(0.85*aimHeur + 0.15*aimNet + jitter));

  // 이동 벡터 합성: 탄 회피 + 벽 + 아군 분리 + 목표 게이팅
  let vx=0,vy=0;
  for(const b of bulletInfo){ const d=U.ttcDanger(tank,b); if(d>0){ const bx=b.vx, by=b.vy; // 측면 회피
      const sx=-by, sy=bx; const sl=Math.hypot(sx,sy)||1; vx+= (sx/sl)*d; vy+= (sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.9*wx; vy+=0.9*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.7*sx; vy+=0.7*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const ao=U.ang(to);
    const toward=[Math.cos(ao*Math.PI/180), Math.sin(ao*Math.PI/180)];
    const away=[-toward[0], -toward[1]];
    const cw=[Math.cos((ao-90)*Math.PI/180), Math.sin((ao-90)*Math.PI/180)];
    const ccw=[-cw[0], -cw[1]];
    vx += 0.9*(wTow*toward[0] + wAway*away[0]) + 0.6*(wCW*cw[0] + wCCW*ccw[0]);
    vy += 0.9*(wTow*toward[1] + wAway*away[1]) + 0.6*(wCW*cw[1] + wCCW*ccw[1]);
  }
  // 네트 보정
  vx += 0.5*mvx; vy += 0.5*mvy;
  const ang=U.ang(U.deg(vx,vy));
  if(!tank.move(ang)){
    if(!tank.move(ang+25)) if(!tank.move(ang-25)) tank.move(ang+180);
  }
}

// ===== 로봇 2 (TANKER, support-anchor) =====
function name(){return 'Helios T2';}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){ const U={}; U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;}; U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI; U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; }; U.sortByDist=(a,b)=>a.distance-b.distance; U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }; U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }; U.tanhV=(v)=>v.map(Math.tanh);
    U.ttc=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+6; const near=lat-rad; if(near>24) return 0; const tti=proj/(v+1e-6); return Math.max(0,1/(1+0.55*tti)) * Math.max(0,(24-Math.max(0,near))/24); };
    U.wall=(x,y)=>{ const W=900,H=600,p=70; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<64){ const k=(64-d)/64; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.lead=(mem,tk,t)=>{ if(!t) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(t.x-mem.last.x,t.y-mem.last.y)<140){ vx=t.x-mem.last.x; vy=t.y-mem.last.y; } const dx=t.x-tk.x, dy=t.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let tt=0; if(Math.abs(A)<1e-6){ tt=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); tt=Math.max(t1,t2,0); } } const px=dx+vx*tt, py=dy+vy*tt; mem.last={x:t.x,y:t.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)]; const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x; };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA33,64,32), W2:U.initW(seed^0xB55,32,16), W3:U.initW(seed^0xC77,16,8) }); U.fwd=(n,x)=>{ const h1=U.tanhV(U.mv(n.W1,x)); const h2=U.tanhV(U.mv(n.W2,h1)); return U.mv(n.W3,h2); };
    return U; }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71C11) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]); const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=(y[4]+1)/2, wAway=(y[5]+1)/2, wCW=(y[6]+1)/2, wCCW=(y[7]+1)/2;
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;
  const aimH = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0; const aimN=U.ang(U.deg(fvx,fvy)); const jit=((tank.x*13+tank.y*19+3)%23-11)*0.32; tank.fire(U.ang(0.84*aimH+0.16*aimN+jit));
  let vx=0,vy=0; for(const b of bulletInfo){ const d=U.ttc(tank,b); if(d>0){ const sx=-b.vy, sy=b.vx; const sl=Math.hypot(sx,sy)||1; vx+=(sx/sl)*d; vy+=(sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.9*wx; vy+=0.9*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.6*sx; vy+=0.6*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const cw=[Math.cos((to-90)*Math.PI/180), Math.sin((to-90)*Math.PI/180)]; const ccw=[-cw[0],-cw[1]]; const tw=[Math.cos(to*Math.PI/180),Math.sin(to*Math.PI/180)]; const aw=[-tw[0],-tw[1]]; vx+=0.8*(wTow*tw[0]+wAway*aw[0])+0.55*(wCW*cw[0]+wCCW*ccw[0]); vy+=0.8*(wTow*tw[1]+wAway*aw[1])+0.55*(wCW*cw[1]+wCCW*ccw[1]); }
  vx+=0.45*mvx; vy+=0.45*mvy; const ang=U.ang(U.deg(vx,vy)); if(!tank.move(ang)){ if(!tank.move(ang+20)) if(!tank.move(ang-20)) tank.move(ang+180); }
}

// ===== 로봇 3 (DEALER, kiter) =====
function name(){return 'Helios D1';}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){ const U={}; U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;}; U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI; U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; }; U.sortByDist=(a,b)=>a.distance-b.distance; U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }; U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }; U.tanhV=(v)=>v.map(Math.tanh);
    U.ttc=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+5; const near=lat-rad; if(near>22) return 0; const tti=proj/(v+1e-6); return Math.max(0,1/(1+0.65*tti))*Math.max(0,(22-Math.max(0,near))/22); };
    U.wall=(x,y)=>{ const W=900,H=600,p=60; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<58){ const k=(58-d)/58; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.lead=(mem,tk,t)=>{ if(!t) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(t.x-mem.last.x,t.y-mem.last.y)<120){ vx=t.x-mem.last.x; vy=t.y-mem.last.y; } const dx=t.x-tk.x, dy=t.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let tt=0; if(Math.abs(A)<1e-6){ tt=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); tt=Math.max(t1,t2,0); } } const px=dx+vx*tt, py=dy+vy*tt; mem.last={x:t.x,y:t.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)]; const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x; };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA77,64,32), W2:U.initW(seed^0xB99,32,16), W3:U.initW(seed^0xCAB,16,8) }); U.fwd=(n,x)=>{ const h1=U.tanhV(U.mv(n.W1,x)); const h2=U.tanhV(U.mv(n.W2,h1)); return U.mv(n.W3,h2); };
    return U; }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71CD1) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]); const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=(y[4]+1)/2, wAway=(y[5]+1)/2, wCW=(y[6]+1)/2, wCCW=(y[7]+1)/2;
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;
  const aimH = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0; const aimN=U.ang(U.deg(fvx,fvy)); const jit=((tank.x*29+tank.y*13+5)%23-11)*0.28; tank.fire(U.ang(0.82*aimH+0.18*aimN+jit));
  let vx=0,vy=0; for(const b of bulletInfo){ const d=U.ttc(tank,b); if(d>0){ const sx=-b.vy, sy=b.vx; const sl=Math.hypot(sx,sy)||1; vx+=(sx/sl)*d; vy+=(sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.7*wx; vy+=0.7*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.5*sx; vy+=0.5*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const tw=[Math.cos(to*Math.PI/180),Math.sin(to*Math.PI/180)]; const aw=[-tw[0],-tw[1]]; const cw=[Math.cos((to-90)*Math.PI/180), Math.sin((to-90)*Math.PI/180)]; const ccw=[-cw[0],-cw[1]];
    // 딜러: 중거리 유지(away 가중 조정)
    vx+=0.65*(wTow*tw[0]+(0.7*wAway)*aw[0])+0.7*(wCW*cw[0]+wCCW*ccw[0]);
    vy+=0.65*(wTow*tw[1]+(0.7*wAway)*aw[1])+0.7*(wCW*cw[1]+wCCW*ccw[1]);
  }
  vx+=0.6*mvx; vy+=0.6*mvy; const ang=U.ang(U.deg(vx,vy)); if(!tank.move(ang)){ if(!tank.move(ang+25)) if(!tank.move(ang-25)) tank.move(ang+180); }
}

// ===== 로봇 4 (DEALER, kiter) =====
function name(){return 'Helios D2';}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){ const U={}; U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;}; U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI; U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; }; U.sortByDist=(a,b)=>a.distance-b.distance; U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }; U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }; U.tanhV=(v)=>v.map(Math.tanh);
    U.ttc=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+5; const near=lat-rad; if(near>22) return 0; const tti=proj/(v+1e-6); return Math.max(0,1/(1+0.65*tti))*Math.max(0,(22-Math.max(0,near))/22); };
    U.wall=(x,y)=>{ const W=900,H=600,p=60; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<58){ const k=(58-d)/58; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.lead=(mem,tk,t)=>{ if(!t) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(t.x-mem.last.x,t.y-mem.last.y)<120){ vx=t.x-mem.last.x; vy=t.y-mem.last.y; } const dx=t.x-tk.x, dy=t.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let tt=0; if(Math.abs(A)<1e-6){ tt=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); tt=Math.max(t1,t2,0); } } const px=dx+vx*tt, py=dy+vy*tt; mem.last={x:t.x,y:t.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)]; const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x; };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA79,64,32), W2:U.initW(seed^0xB9B,32,16), W3:U.initW(seed^0xCAD,16,8) }); U.fwd=(n,x)=>{ const h1=U.tanhV(U.mv(n.W1,x)); const h2=U.tanhV(U.mv(n.W2,h1)); return U.mv(n.W3,h2); };
    return U; }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71CD7) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]); const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=(y[4]+1)/2, wAway=(y[5]+1)/2, wCW=(y[6]+1)/2, wCCW=(y[7]+1)/2;
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;
  const aimH = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0; const aimN=U.ang(U.deg(fvx,fvy)); const jit=((tank.x*23+tank.y*17+9)%23-11)*0.26; tank.fire(U.ang(0.82*aimH+0.18*aimN+jit));
  let vx=0,vy=0; for(const b of bulletInfo){ const d=U.ttc(tank,b); if(d>0){ const sx=-b.vy, sy=b.vx; const sl=Math.hypot(sx,sy)||1; vx+=(sx/sl)*d; vy+=(sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.7*wx; vy+=0.7*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.5*sx; vy+=0.5*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const tw=[Math.cos(to*Math.PI/180),Math.sin(to*Math.PI/180)]; const aw=[-tw[0],-tw[1]]; const cw=[Math.cos((to-90)*Math.PI/180), Math.sin((to-90)*Math.PI/180)]; const ccw=[-cw[0],-cw[1]];
    vx+=0.65*(wTow*tw[0]+(0.7*wAway)*aw[0])+0.7*(wCW*cw[0]+wCCW*ccw[0]);
    vy+=0.65*(wTow*tw[1]+(0.7*wAway)*aw[1])+0.7*(wCW*cw[1]+wCCW*ccw[1]);
  }
  vx+=0.6*mvx; vy+=0.6*mvy; const ang=U.ang(U.deg(vx,vy)); if(!tank.move(ang)){ if(!tank.move(ang+25)) if(!tank.move(ang-25)) tank.move(ang+180); }
}

// ===== 로봇 5 (NORMAL, flanker) =====
function name(){return 'Helios N1';}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){ const U={}; U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;}; U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI; U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; }; U.sortByDist=(a,b)=>a.distance-b.distance; U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }; U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }; U.tanhV=(v)=>v.map(Math.tanh);
    U.ttc=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+6; const near=lat-rad; if(near>24) return 0; const tti=proj/(v+1e-6); return Math.max(0,1/(1+0.6*tti))*Math.max(0,(24-Math.max(0,near))/24); };
    U.wall=(x,y)=>{ const W=900,H=600,p=64; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<60){ const k=(60-d)/60; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.lead=(mem,tk,t)=>{ if(!t) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(t.x-mem.last.x,t.y-mem.last.y)<120){ vx=t.x-mem.last.x; vy=t.y-mem.last.y; } const dx=t.x-tk.x, dy=t.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let tt=0; if(Math.abs(A)<1e-6){ tt=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); tt=Math.max(t1,t2,0); } } const px=dx+vx*tt, py=dy+vy*tt; mem.last={x:t.x,y:t.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)]; const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x; };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA93,64,32), W2:U.initW(seed^0xBB5,32,16), W3:U.initW(seed^0xCD7,16,8) }); U.fwd=(n,x)=>{ const h1=U.tanhV(U.mv(n.W1,x)); const h2=U.tanhV(U.mv(n.W2,h1)); return U.mv(n.W3,h2); };
    return U; }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71D21) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]); const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=(y[4]+1)/2, wAway=(y[5]+1)/2, wCW=(y[6]+1)/2, wCCW=(y[7]+1)/2;
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;
  const aimH = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0; const aimN=U.ang(U.deg(fvx,fvy)); const jit=((tank.x*31+tank.y*11+1)%23-11)*0.25; tank.fire(U.ang(0.84*aimH+0.16*aimN+jit));
  let vx=0,vy=0; for(const b of bulletInfo){ const d=U.ttc(tank,b); if(d>0){ const sx=-b.vy, sy=b.vx; const sl=Math.hypot(sx,sy)||1; vx+=(sx/sl)*d; vy+=(sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.8*wx; vy+=0.8*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.55*sx; vy+=0.55*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const flank=to+(tank.y<300? -90:90); const tw=[Math.cos(to*Math.PI/180),Math.sin(to*Math.PI/180)]; const fl=[Math.cos(flank*Math.PI/180),Math.sin(flank*Math.PI/180)];
    vx+=0.7*(wTow*tw[0]) + 0.65*(wCW*fl[0] + wCCW*(-fl[0]));
    vy+=0.7*(wTow*tw[1]) + 0.65*(wCW*fl[1] + wCCW*(-fl[1]));
  }
  vx+=0.55*mvx; vy+=0.55*mvy; const ang=U.ang(U.deg(vx,vy)); if(!tank.move(ang)){ if(!tank.move(ang+20)) if(!tank.move(ang-20)) tank.move(ang+180); }
}

// ===== 로봇 6 (NORMAL, flanker) =====
function name(){return 'Helios N2';}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  function __u__(){ const U={}; U.ang=(a)=>{a%=360; if(a<0)a+=360; return a;}; U.deg=(x,y)=>Math.atan2(y,x)*180/Math.PI; U.clamp=(v,min,max)=>v<min?min:(v>max?max:v);
    U.mean=(a)=>{ if(!a.length) return 0; let s=0; for(const v of a) s+=v; return s/a.length; }; U.sortByDist=(a,b)=>a.distance-b.distance; U.sortByHealthThenPos=(a,b)=>{ if(a.health!==b.health) return a.health-b.health; if(a.y!==b.y) return a.y-b.y; return a.x-b.x; };
    U.sr=(s)=>{ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }; U.initW=(seed,i,o)=>{ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=U.sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; };
    U.mv=(Wm,v)=>{ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }; U.tanhV=(v)=>v.map(Math.tanh);
    U.ttc=(tk,b)=>{ const v=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const rx=tk.x-b.x, ry=tk.y-b.y; const proj=rx*nx+ry*ny; if(proj<0) return 0; const lat=Math.abs(rx*(-ny)+ry*nx); const rad=tk.size*0.5+6; const near=lat-rad; if(near>24) return 0; const tti=proj/(v+1e-6); return Math.max(0,1/(1+0.6*tti))*Math.max(0,(24-Math.max(0,near))/24); };
    U.wall=(x,y)=>{ const W=900,H=600,p=64; let vx=0,vy=0; if(x<p) vx+=(p-x)/p; if(x>W-p) vx-=(x-(W-p))/p; if(y<p) vy+=(p-y)/p; if(y>H-p) vy-=(y-(H-p))/p; return [vx,vy]; };
    U.sep=(px,py,als)=>{ let vx=0,vy=0; for(const a of als){ const d=Math.hypot(px-a.x,py-a.y); if(d<60){ const k=(60-d)/60; const dx=px-a.x, dy=py-a.y; const l=Math.hypot(dx,dy)||1; vx+=dx/l*k; vy+=dy/l*k; } } return [vx,vy]; };
    U.lead=(mem,tk,t)=>{ if(!t) return null; const bs=8; let vx=0,vy=0; if(mem.last && Math.hypot(t.x-mem.last.x,t.y-mem.last.y)<120){ vx=t.x-mem.last.x; vy=t.y-mem.last.y; } const dx=t.x-tk.x, dy=t.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let tt=0; if(Math.abs(A)<1e-6){ tt=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); tt=Math.max(t1,t2,0); } } const px=dx+vx*tt, py=dy+vy*tt; mem.last={x:t.x,y:t.y}; return U.deg(px,py); };
    U.feat=(tk,ens,als,bul)=>{ const W=900,H=600; const self=[tk.x/W,tk.y/H,U.clamp(tk.health/200,0,1),(tk.type===0?1:0),(tk.type===1?1:0),(tk.type===2?1:0),U.clamp(tk.size/60,0,1)];
      const es=ens.slice().sort(U.sortByDist).slice(0,3), ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H,U.clamp(e.distance/900,0,1),Math.cos(a),Math.sin(a),U.clamp(e.health/200,0,1)); } else ef.push(0,0,1,1,0,0); }
      const as=als.slice().sort(U.sortByDist).slice(0,2), af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H,U.clamp(a.distance/600,0,1),U.clamp(a.health/200,0,1)); } else af.push(0,0,1,0); }
      const bs=bul.slice(0,4), bf=[]; for(let i=0;i<4;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; const rx=(b.x-tk.x)/W, ry=(b.y-tk.y)/H; const nx=b.vx/v, ny=b.vy/v; const proj=U.clamp(((b.x-tk.x)*nx+(b.y-tk.y)*ny)/900,-1,1); bf.push(rx,ry,nx,ny,proj); } else bf.push(0,0,0,0,0); }
      const cx=(U.mean(ens.map(e=>e.x))-tk.x)/W, cy=(U.mean(ens.map(e=>e.y))-tk.y)/H; const nb=U.clamp(bul.length/12,0,1);
      const agg=[cx,cy,nb,U.clamp(ens.length/6,0,1),U.clamp(als.length/6,0,1)]; const x=self.concat(ef,af,bf,agg); while(x.length<64) x.push(0); return x; };
    U.initNet=(seed)=>({ W1:U.initW(seed^0xA99,64,32), W2:U.initW(seed^0xBBB,32,16), W3:U.initW(seed^0xCDD,16,8) }); U.fwd=(n,x)=>{ const h1=U.tanhV(U.mv(n.W1,x)); const h2=U.tanhV(U.mv(n.W2,h1)); return U.mv(n.W3,h2); };
    return U; }
  const U=__u__(); if(!update._m) update._m={ last:null, net:U.initNet(0x71D27) };
  const x=U.feat(tank,enemies,allies,bulletInfo), y=U.fwd(update._m.net,x);
  const mvx=Math.tanh(y[0]), mvy=Math.tanh(y[1]); const fvx=Math.tanh(y[2]), fvy=Math.tanh(y[3]);
  const wTow=(y[4]+1)/2, wAway=(y[5]+1)/2, wCW=(y[6]+1)/2, wCCW=(y[7]+1)/2;
  const tgt = enemies.length? enemies.slice().sort(U.sortByHealthThenPos)[0] : null;
  const aimH = tgt ? (U.lead(update._m,tank,tgt) ?? U.deg(tgt.x-tank.x,tgt.y-tank.y)) : 0; const aimN=U.ang(U.deg(fvx,fvy)); const jit=((tank.x*7+tank.y*23+15)%23-11)*0.25; tank.fire(U.ang(0.84*aimH+0.16*aimN+jit));
  let vx=0,vy=0; for(const b of bulletInfo){ const d=U.ttc(tank,b); if(d>0){ const sx=-b.vy, sy=b.vx; const sl=Math.hypot(sx,sy)||1; vx+=(sx/sl)*d; vy+=(sy/sl)*d; } }
  { const [wx,wy]=U.wall(tank.x,tank.y); vx+=0.8*wx; vy+=0.8*wy; }
  { const [sx,sy]=U.sep(tank.x,tank.y,allies); vx+=0.55*sx; vy+=0.55*sy; }
  if(tgt){ const to=U.deg(tgt.x-tank.x,tgt.y-tank.y); const flank=to+(tank.y<300? 90:-90); const tw=[Math.cos(to*Math.PI/180),Math.sin(to*Math.PI/180)]; const fl=[Math.cos(flank*Math.PI/180),Math.sin(flank*Math.PI/180)];
    vx+=0.7*(wTow*tw[0]) + 0.65*(wCW*fl[0] + wCCW*(-fl[0]));
    vy+=0.7*(wTow*tw[1]) + 0.65*(wCW*fl[1] + wCCW*(-fl[1]));
  }
  vx+=0.55*mvx; vy+=0.55*mvy; const ang=U.ang(U.deg(vx,vy)); if(!tank.move(ang)){ if(!tank.move(ang+20)) if(!tank.move(ang-20)) tank.move(ang+180); }
}

