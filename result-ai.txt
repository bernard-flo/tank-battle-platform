// Nemesis AI Team (DNN + Heuristics)
// - 블록별 독립 유틸/MLP/전술 포함(분할 로더 대응)
// - update는 tank/enemies/allies/bulletInfo 모두 활용
// - 48→32→16→4 tanh MLP 출력과 회피/간격/교전 로직 혼합

function name() { return 'Nemesis T1'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.8+34); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2);
    const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0); } }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1); } }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1); } }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000; }
    function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row; } return Wt; }
    function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }
    function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
    const s1=(cfg.seed*73856093)^0x9e3779b9, s2=(cfg.seed*19349663)^0x7f4a7c15, s3=(cfg.seed*83492791)^0x6a09e667;
    const h1=tanhV(mv(w(s1,48,32),x)); const h2=tanhV(mv(w(s2,32,16),h1)); const o=tanhV(mv(w(s3,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.22; tank.fire(ang(0.7*base+0.3*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const bias=(cfg.role==='front'?+8:(cfg.role==='flank'?-12:+14)); const C=[a+90+bias,a-90-bias,a+110,a-110]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<66){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<185){ baseMove=to+180+(cfg.role==='front'?+8:-12); } else if(d>275){ baseMove=to+(cfg.role==='flank'?+18:0); } else { baseMove=to+(cfg.role==='support'?+24:-18); } const mvA=ang(0.65*baseMove+0.35*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'front', seed:11 });
}

// ===== 다음 로봇 =====

function name() { return 'Nemesis T2'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.8+34); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3); const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2); const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0);} }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1);} }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1);} }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000;} function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row;} return Wt;} function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out;} function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o;}
    const h1=tanhV(mv(w((cfg.seed*73856093)^0x9e3779b9,48,32),x)); const h2=tanhV(mv(w((cfg.seed*19349663)^0x7f4a7c15,32,16),h1)); const o=tanhV(mv(w((cfg.seed*83492791)^0x6a09e667,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.22; tank.fire(ang(0.7*base+0.3*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const bias=(cfg.role==='front'?+8:(cfg.role==='flank'?-12:+14)); const C=[a+90+bias,a-90-bias,a+110,a-110]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<66){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<185){ baseMove=to+180+(cfg.role==='front'?+8:-12);} else if(d>275){ baseMove=to+(cfg.role==='flank'?+18:0);} else { baseMove=to+(cfg.role==='support'?+24:-18);} const mvA=ang(0.65*baseMove+0.35*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'front', seed:17 });
}

// ===== 다음 로봇 =====

function name() { return 'Nemesis D1'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.75+38); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3); const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2); const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0);} }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1);} }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1);} }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000;} function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row;} return Wt;} function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out;} function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o;}
    const h1=tanhV(mv(w((cfg.seed*73856093)^0x9e3779b9,48,32),x)); const h2=tanhV(mv(w((cfg.seed*19349663)^0x7f4a7c15,32,16),h1)); const o=tanhV(mv(w((cfg.seed*83492791)^0x6a09e667,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.25; tank.fire(ang(0.68*base+0.32*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const C=[a+90-8,a-90+8,a+115,a-115]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<70){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<210){ baseMove=to+180-10; } else if(d>300){ baseMove=to+18; } else { baseMove=to-22; } const mvA=ang(0.6*baseMove+0.4*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'flank', seed:23 });
}

// ===== 다음 로봇 =====

function name() { return 'Nemesis D2'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.75+38); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3); const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2); const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0);} }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1);} }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1);} }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000;} function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row;} return Wt;} function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out;} function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o;}
    const h1=tanhV(mv(w((cfg.seed*73856093)^0x9e3779b9,48,32),x)); const h2=tanhV(mv(w((cfg.seed*19349663)^0x7f4a7c15,32,16),h1)); const o=tanhV(mv(w((cfg.seed*83492791)^0x6a09e667,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.25; tank.fire(ang(0.68*base+0.32*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const C=[a+90+8,a-90-8,a+115,a-115]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<70){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<210){ baseMove=to+180+10; } else if(d>300){ baseMove=to-18; } else { baseMove=to+22; } const mvA=ang(0.6*baseMove+0.4*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'flank', seed:29 });
}

// ===== 다음 로봇 =====

function name() { return 'Nemesis D3'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.75+38); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3); const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2); const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0);} }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1);} }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1);} }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000;} function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row;} return Wt;} function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out;} function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o;}
    const h1=tanhV(mv(w((cfg.seed*73856093)^0x9e3779b9,48,32),x)); const h2=tanhV(mv(w((cfg.seed*19349663)^0x7f4a7c15,32,16),h1)); const o=tanhV(mv(w((cfg.seed*83492791)^0x6a09e667,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.27; tank.fire(ang(0.7*base+0.3*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const C=[a+90-10,a-90+10,a+115,a-115]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<68){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<210){ baseMove=to+180-12; } else if(d>300){ baseMove=to+16; } else { baseMove=to-20; } const mvA=ang(0.6*baseMove+0.4*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'support', seed:31 });
}

// ===== 다음 로봇 =====

function name() { return 'Nemesis D4'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  (function run(cfg){
    function clamp01(x){ return x<0?0:(x>1?1:x); }
    function ang(a){ a%=360; if(a<0)a+=360; return a; }
    function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
    function near(arr){ let r=null,d=1e9; for(const e of arr){ if(e.distance<d){d=e.distance;r=e;} } return r; }
    function isThreat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp; const proj=dx*nx+dy*ny; if(proj<=0) return false; const px=b.x-proj*nx, py=b.y-proj*ny; const dd=Math.hypot(px-tank.x,py-tank.y); return dd<(tank.size*0.75+38); }
    const W=900,H=600; const self=[tank.x/W,tank.y/H,clamp01(tank.health/160),(tank.type===0?1:0),(tank.type===1?1:0),(tank.type===2?1:0)];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance).slice(0,3); const as=allies.slice().sort((a,b)=>a.distance-b.distance).slice(0,2); const ts=bulletInfo.filter(isThreat).sort((a,b)=>a.distance-b.distance).slice(0,3);
    const ef=[]; for(let i=0;i<3;i++){ const e=es[i]; if(e){ const dx=(e.x-tank.x)/W,dy=(e.y-tank.y)/H; const d=clamp01(e.distance/1000); const a=Math.atan2(e.y-tank.y,e.x-tank.x); ef.push(dx,dy,d,Math.cos(a),Math.sin(a),clamp01(e.health/160)); } else { ef.push(0,0,1,1,0,0);} }
    const af=[]; for(let i=0;i<2;i++){ const a=as[i]; if(a){ const dx=(a.x-tank.x)/W,dy=(a.y-tank.y)/H; af.push(dx,dy,clamp01(a.distance/800)); } else { af.push(0,0,1);} }
    const bf=[]; for(let i=0;i<3;i++){ const b=ts[i]; if(b){ const dv=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tank.x)/W,(b.y-tank.y)/H,(b.vx/dv),(b.vy/dv),clamp01(b.distance/800)); } else { bf.push(0,0,0,0,1);} }
    const x=self.concat(ef,af,bf,[clamp01(enemies.length/6),clamp01(allies.length/5),clamp01(bulletInfo.length/12)]);
    function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)%0x100000000;} function w(seed,i,o){ let s=seed>>>0; const Wt=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=(s%2001)/1000-1; row[c]=r01*Math.sqrt(2/(i+o)); } Wt[r]=row;} return Wt;} function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out;} function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++) o[i]=Math.tanh(v[i]); return o;}
    const h1=tanhV(mv(w((cfg.seed*73856093)^0x9e3779b9,48,32),x)); const h2=tanhV(mv(w((cfg.seed*19349663)^0x7f4a7c15,32,16),h1)); const o=tanhV(mv(w((cfg.seed*83492791)^0x6a09e667,16,4),h2));
    const nnMove=Math.atan2(o[1],o[0])*180/Math.PI; const nnFire=Math.atan2(o[3],o[2])*180/Math.PI;
    const tgt=enemies.length?near(enemies):null; if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.27; tank.fire(ang(0.7*base+0.3*nnFire+jitter)); }
    function go(a){ return tank.move(ang(a)); }
    if(ts.length){ const b=ts[0]; const a=deg(b.vx,b.vy); const C=[a+90+10,a-90-10,a+115,a-115]; for(const c of C){ if(go(c)) return; } }
    if(allies.length){ const A=near(allies); if(A && A.distance<68){ const away=deg(tank.x-A.x,tank.y-A.y); if(go(away)) return; if(go(away+25)) return; if(go(away-25)) return; } }
    if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); let baseMove; if(d<210){ baseMove=to+180+12; } else if(d>300){ baseMove=to-16; } else { baseMove=to+20; } const mvA=ang(0.6*baseMove+0.4*nnMove); if(go(mvA)) return; if(go(mvA+25)) return; if(go(mvA-25)) return; }
    if(go(nnMove)) return; const pref=[0,90,180,270]; for(const p of pref){ if(go(p)) return; }
  })({ role:'support', seed:37 });
}

