// Nemesis-3c (Aegis-Phalanx) – 강화형 휴리스틱 + 소형 DNN 보정
// - 각 로봇 블록은 독립적으로 동작하며(update 함수 내부에 모든 헬퍼 포함),
//   tank/enemies/allies/bulletInfo를 모두 활용한 32→16→4 MLP로 사격 지터/측면 편향만 소폭 보정.

// ===== 로봇 1 =====
function name(){ return 'Aegis T1'; }
function type(){ return Type.TANKER; }
function update(tank,enemies,allies,bulletInfo){
  // 유틸/MLP/전술 헬퍼
  function ang(a){ a%=360; if(a<0)a+=360; return a; }
  function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; }
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+8); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=60; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; }
  function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; }
  function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)];
    const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); }
    const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); }
    const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); }
    const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  // per-robot memory
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }

  const cfg={ seed:1117, near:190, far:270, side:16 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.8+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies);
  if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.28*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const dir=((tank.x+tank.y+cfg.seed)&1)?1:-1; const cand=[a+90+dir*12, a-90-dir*12, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<64){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+25)) return; if(tryMove(av-25)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+22)) return; if(tryMove(side-22)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

// ===== 로봇 2 =====
function name(){ return 'Aegis T2'; }
function type(){ return Type.TANKER; }
function update(tank,enemies,allies,bulletInfo){
  function ang(a){ a%=360; if(a<0)a+=360; return a; } function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; } function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+8); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=60; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; } function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; } function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)]; const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); } const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); } const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); } const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }
  const cfg={ seed:2029, near:205, far:285, side:14 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.8+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies); if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*17+cfg.seed)%23-11)*0.26*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const dir=((tank.x+tank.y+cfg.seed)&1)?1:-1; const cand=[a+90+dir*10, a-90-dir*10, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<64){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+22)) return; if(tryMove(av-22)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

// ===== 로봇 3 =====
function name(){ return 'Aegis D1'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  function ang(a){ a%=360; if(a<0)a+=360; return a; } function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; } function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+10); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=70; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; } function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; } function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)]; const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); } const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); } const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); } const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }
  const cfg={ seed:3031, near:230, far:350, side:22 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.85+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies); if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*13+cfg.seed)%23-11)*0.26*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+10, a-90-10, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<66){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+22)) return; if(tryMove(av-22)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

// ===== 로봇 4 =====
function name(){ return 'Aegis D2'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  function ang(a){ a%=360; if(a<0)a+=360; return a; } function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; } function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+10); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=70; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; } function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; } function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)]; const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); } const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); } const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); } const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }
  const cfg={ seed:4051, near:235, far:355, side:-20 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.85+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies); if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*13+cfg.seed)%23-11)*0.26*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90-12, a-90+12, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<66){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+22)) return; if(tryMove(av-22)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

// ===== 로봇 5 =====
function name(){ return 'Aegis D3'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  function ang(a){ a%=360; if(a<0)a+=360; return a; } function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; } function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+10); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=70; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; } function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; } function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)]; const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); } const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); } const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); } const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }
  const cfg={ seed:4909, near:240, far:360, side:18 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.85+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies); if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*13+cfg.seed)%23-11)*0.26*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+8, a-90-8, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<66){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+22)) return; if(tryMove(av-22)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

// ===== 로봇 6 =====
function name(){ return 'Aegis N1'; }
function type(){ return Type.NORMAL; }
function update(tank,enemies,allies,bulletInfo){
  function ang(a){ a%=360; if(a<0)a+=360; return a; } function deg(x,y){ return Math.atan2(y,x)*180/Math.PI; } function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function closest(arr){ let r=null,md=1e9; for(const e of arr){ if(e.distance<md){ md=e.distance; r=e; } } return r; }
  function pickTarget(ens){ if(!ens.length) return null; let best=ens[0]; for(const e of ens){ if(e.health<best.health-0.1 || (Math.abs(e.health-best.health)<0.1 && (e.y<best.y || (e.y===best.y && e.x<best.x)))) best=e; } return best; }
  function threatCheck(tk,b){ const dx=b.x-tk.x, dy=b.y-tk.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tk.x,py-tk.y); return d<(tk.size*0.5+9); } return false; }
  function wallRepel(tx,ty){ const W=900,H=600,p=65; let vx=0,vy=0; if(tx<p) vx+=(p-tx)/p; if(tx>W-p) vx-=(tx-(W-p))/p; if(ty<p) vy+=(p-ty)/p; if(ty>H-p) vy-=(ty-(H-p))/p; return [vx,vy]; }
  function sr(s){ s^=s<<13; s^=s>>>17; s^=s<<5; return (s>>>0)>>>0; } function initW(seed,i,o){ let s=seed>>>0; const W=new Array(o); for(let r=0;r<o;r++){ const row=new Array(i); for(let c=0;c<i;c++){ s=sr(s); const r01=((s%2001)/1000-1); row[c]=r01*Math.sqrt(2/(i+o)); } W[r]=row; } return W; }
  function mv(Wm,v){ const out=new Array(Wm.length); for(let r=0;r<Wm.length;r++){ const row=Wm[r]; let sum=0; for(let c=0;c<row.length;c++){ sum+=row[c]*v[c]; } out[r]=sum; } return out; } function tanhV(v){ const o=new Array(v.length); for(let i=0;i<v.length;i++){ o[i]=Math.tanh(v[i]); } return o; }
  function buildFeat(seed,tk,ens,als,bul){ const W=900,H=600; const self=[tk.x/W, tk.y/H, clamp(tk.health/200,0,1), (tk.type===0?1:0), (tk.type===1?1:0), (tk.type===2?1:0), clamp(tk.size/50,0,1), clamp(als.length/5,0,1)]; const es=ens.slice().sort((a,b)=>a.health-b.health||a.distance-b.distance).slice(0,2); const ef=[]; for(let i=0;i<2;i++){ const e=es[i]; if(e){ const a=Math.atan2(e.y-tk.y,e.x-tk.x); ef.push((e.x-tk.x)/W,(e.y-tk.y)/H, clamp(e.distance/900,0,1), Math.cos(a), Math.sin(a)); } else ef.push(0,0,1,1,0); } const as=als.slice().sort((a,b)=>a.distance-b.distance).slice(0,1); const af=[]; for(let i=0;i<1;i++){ const a=as[i]; if(a){ af.push((a.x-tk.x)/W,(a.y-tk.y)/H, clamp(a.distance/600,0,1)); } else af.push(0,0,1); } const bs=bul.slice(0,3); const bf=[]; for(let i=0;i<3;i++){ const b=bs[i]; if(b){ const v=Math.hypot(b.vx,b.vy)||1; bf.push((b.x-tk.x)/W,(b.y-tk.y)/H, b.vx/v,b.vy/v); } else bf.push(0,0,0,0); } const x=self.concat(ef,af,bf); while(x.length<32) x.push(0); return x; }
  function nn(seed,tk,ens,als,bul){ const x=buildFeat(seed,tk,ens,als,bul); const h=tanhV(mv(initW(seed^0x9e3779b9,32,16),x)); return mv(initW(seed^0x6a09e667,16,4),h); }
  if(!update._m) update._m={ last:null };
  function leadAngle(tk,tgt){ if(!tgt) return null; const bs=8; let vx=0,vy=0; if(update._m.last && Math.hypot(tgt.x-update._m.last.x,tgt.y-update._m.last.y)<50){ vx=tgt.x-update._m.last.x; vy=tgt.y-update._m.last.y; } const dx=tgt.x-tk.x, dy=tgt.y-tk.y; const A=vx*vx+vy*vy-bs*bs, B=2*(dx*vx+dy*vy), C=dx*dx+dy*dy; let t=0; if(Math.abs(A)<1e-6){ t=(B<0)?(-C/B):0; } else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); const t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.max(t1,t2,0); } } const px=dx+vx*t, py=dy+vy*t; update._m.last={x:tgt.x,y:tgt.y}; return deg(px,py); }
  const cfg={ seed:5821, near:210, far:320, side:-16 };
  const o=nn(cfg.seed,tank,enemies,allies,bulletInfo); const jitterScale=clamp(0.85+0.25*Math.tanh(o[0]),0.6,1.1); const sideBias=clamp(0+25*Math.tanh(o[1]),-25,25);
  const tgt=pickTarget(enemies) || closest(enemies); if(tgt){ const base=leadAngle(tank,tgt) ?? deg(tgt.x-tank.x,tgt.y-tank.y); const jj=((tank.x*31+tank.y*13+cfg.seed)%23-11)*0.26*jitterScale; tank.fire(ang(base+jj)); }
  let tried=0; function tryMove(a){ tried++; return tank.move(ang(a)); }
  let hot=null, minD=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threatCheck(tank,b)){ minD=d; hot=b; } }
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90, a-90, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<64){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+20)) return; if(tryMove(av-20)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<cfg.near){ const away=to+180 + sideBias*0.3; if(tryMove(away)) return; if(tryMove(away+20)) return; if(tryMove(away-20)) return; } else if(d>cfg.far){ if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return; } else { const side=to + (cfg.side + sideBias); if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  const [rx,ry]=wallRepel(tank.x,tank.y); const repelA=(Math.abs(rx)+Math.abs(ry)>0.01)?deg(rx,ry):0; const prefDir=[repelA, 0+sideBias, 90+sideBias, 180+sideBias, 270+sideBias]; for(const p of prefDir){ if(tryMove(p)) return; }
}

