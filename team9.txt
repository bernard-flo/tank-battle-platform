function name() {
  return 'ğŸ›¡ï¸ZinzerğŸ›¡ï¸';
}
function type() {
  return Type.TANKER; // ì›ë˜ëŒ€ë¡œ NORMAL
}
function update(tank, enemies, allies, bulletInfo) {
  if (enemies.length > 0) {
    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    let nearest = enemies[0];
    for (let enemy of enemies) {
      if (enemy.distance < nearest.distance) {
        nearest = enemy;
      }
    }
    
    // ì ì„ í–¥í•´ ì‚¬ê²© (ë¬´ì¡°ê±´)
    const fireAngle = Math.atan2(nearest.y - tank.y, nearest.x - tank.x) * 180 / Math.PI;
    tank.fire(fireAngle);
    
    // ì´ë™ ì „ëµ
    let moveAngle;
    
    if (nearest.distance > 200) {
      // ë©€ë©´ ì ‘ê·¼
      moveAngle = fireAngle;
    } else if (nearest.distance < 80) {
      // ê°€ê¹Œìš°ë©´ í›„ì§„
      moveAngle = fireAngle + 180;
    } else {
      // ì¤‘ê°„ê±°ë¦¬ë©´ ì˜†ìœ¼ë¡œ ì´ë™ (ì›í˜• ê¸°ë™)
      moveAngle = fireAngle + 90;
    }
    
    // ì´ë™ ì‹œë„ - ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ê°ë„ë¡œ
    if (!tank.move(moveAngle)) {
      if (!tank.move(moveAngle + 90)) {
        if (!tank.move(moveAngle - 90)) {
          // ê·¸ë˜ë„ ì•ˆë˜ë©´ ëœë¤
          tank.move(Math.random() * 360);
        }
      }
    }
  }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====

function name() {
  return 'ğŸ›¡ï¸AldoğŸ›¡ï¸';
}
function type() {
  return Type.TANKER; // ì›ë˜ëŒ€ë¡œ NORMAL
}
function update(tank, enemies, allies, bulletInfo) {
  if (enemies.length > 0) {
    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    let nearest = enemies[0];
    for (let enemy of enemies) {
      if (enemy.distance < nearest.distance) {
        nearest = enemy;
      }
    }
    
    // ì ì„ í–¥í•´ ì‚¬ê²© (ë¬´ì¡°ê±´)
    const fireAngle = Math.atan2(nearest.y - tank.y, nearest.x - tank.x) * 180 / Math.PI;
    tank.fire(fireAngle);
    
    // ì´ë™ ì „ëµ
    let moveAngle;
    
    if (nearest.distance > 200) {
      // ë©€ë©´ ì ‘ê·¼
      moveAngle = fireAngle;
    } else if (nearest.distance < 80) {
      // ê°€ê¹Œìš°ë©´ í›„ì§„
      moveAngle = fireAngle + 180;
    } else {
      // ì¤‘ê°„ê±°ë¦¬ë©´ ì˜†ìœ¼ë¡œ ì´ë™ (ì›í˜• ê¸°ë™)
      moveAngle = fireAngle + 90;
    }
    
    // ì´ë™ ì‹œë„ - ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ê°ë„ë¡œ
    if (!tank.move(moveAngle)) {
      if (!tank.move(moveAngle + 90)) {
        if (!tank.move(moveAngle - 90)) {
          // ê·¸ë˜ë„ ì•ˆë˜ë©´ ëœë¤
          tank.move(Math.random() * 360);
        }
      }
    }
  }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====

function name() {
  return 'ğŸ›¡ï¸TinağŸ›¡ï¸';
}
function type() {
  return Type.TANKER; // ì›ë˜ëŒ€ë¡œ NORMAL
}
function update(tank, enemies, allies, bulletInfo) {
  if (enemies.length > 0) {
    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    let nearest = enemies[0];
    for (let enemy of enemies) {
      if (enemy.distance < nearest.distance) {
        nearest = enemy;
      }
    }
    
    // ì ì„ í–¥í•´ ì‚¬ê²© (ë¬´ì¡°ê±´)
    const fireAngle = Math.atan2(nearest.y - tank.y, nearest.x - tank.x) * 180 / Math.PI;
    tank.fire(fireAngle);
    
    // ì´ë™ ì „ëµ
    let moveAngle;
    
    if (nearest.distance > 200) {
      // ë©€ë©´ ì ‘ê·¼
      moveAngle = fireAngle;
    } else if (nearest.distance < 80) {
      // ê°€ê¹Œìš°ë©´ í›„ì§„
      moveAngle = fireAngle + 180;
    } else {
      // ì¤‘ê°„ê±°ë¦¬ë©´ ì˜†ìœ¼ë¡œ ì´ë™ (ì›í˜• ê¸°ë™)
      moveAngle = fireAngle + 90;
    }
    
    // ì´ë™ ì‹œë„ - ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ê°ë„ë¡œ
    if (!tank.move(moveAngle)) {
      if (!tank.move(moveAngle + 90)) {
        if (!tank.move(moveAngle - 90)) {
          // ê·¸ë˜ë„ ì•ˆë˜ë©´ ëœë¤
          tank.move(Math.random() * 360);
        }
      }
    }
  }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====

function name() {
  return 'ğŸ›¡ï¸FelixğŸ›¡ï¸';
}
function type() {
  return Type.TANKER; // ì›ë˜ëŒ€ë¡œ NORMAL
}
function update(tank, enemies, allies, bulletInfo) {
  if (enemies.length > 0) {
    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    let nearest = enemies[0];
    for (let enemy of enemies) {
      if (enemy.distance < nearest.distance) {
        nearest = enemy;
      }
    }
    
    // ì ì„ í–¥í•´ ì‚¬ê²© (ë¬´ì¡°ê±´)
    const fireAngle = Math.atan2(nearest.y - tank.y, nearest.x - tank.x) * 180 / Math.PI;
    tank.fire(fireAngle);
    
    // ì´ë™ ì „ëµ
    let moveAngle;
    
    if (nearest.distance > 200) {
      // ë©€ë©´ ì ‘ê·¼
      moveAngle = fireAngle;
    } else if (nearest.distance < 80) {
      // ê°€ê¹Œìš°ë©´ í›„ì§„
      moveAngle = fireAngle + 180;
    } else {
      // ì¤‘ê°„ê±°ë¦¬ë©´ ì˜†ìœ¼ë¡œ ì´ë™ (ì›í˜• ê¸°ë™)
      moveAngle = fireAngle + 90;
    }
    
    // ì´ë™ ì‹œë„ - ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ê°ë„ë¡œ
    if (!tank.move(moveAngle)) {
      if (!tank.move(moveAngle + 90)) {
        if (!tank.move(moveAngle - 90)) {
          // ê·¸ë˜ë„ ì•ˆë˜ë©´ ëœë¤
          tank.move(Math.random() * 360);
        }
      }
    }
  }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====

function name() {
  return 'ğŸ›¡ï¸ZeusğŸ›¡ï¸';
}
function type() {
  return Type.TANKER; // ì›ë˜ëŒ€ë¡œ NORMAL
}
function update(tank, enemies, allies, bulletInfo) {
  if (enemies.length > 0) {
    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    let nearest = enemies[0];
    for (let enemy of enemies) {
      if (enemy.distance < nearest.distance) {
        nearest = enemy;
      }
    }
    
    // ì ì„ í–¥í•´ ì‚¬ê²© (ë¬´ì¡°ê±´)
    const fireAngle = Math.atan2(nearest.y - tank.y, nearest.x - tank.x) * 180 / Math.PI;
    tank.fire(fireAngle);
    
    // ì´ë™ ì „ëµ
    let moveAngle;
    
    if (nearest.distance > 200) {
      // ë©€ë©´ ì ‘ê·¼
      moveAngle = fireAngle;
    } else if (nearest.distance < 80) {
      // ê°€ê¹Œìš°ë©´ í›„ì§„
      moveAngle = fireAngle + 180;
    } else {
      // ì¤‘ê°„ê±°ë¦¬ë©´ ì˜†ìœ¼ë¡œ ì´ë™ (ì›í˜• ê¸°ë™)
      moveAngle = fireAngle + 90;
    }
    
    // ì´ë™ ì‹œë„ - ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ê°ë„ë¡œ
    if (!tank.move(moveAngle)) {
      if (!tank.move(moveAngle + 90)) {
        if (!tank.move(moveAngle - 90)) {
          // ê·¸ë˜ë„ ì•ˆë˜ë©´ ëœë¤
          tank.move(Math.random() * 360);
        }
      }
    }
  }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====

function name(){ return "ğŸ›¡ï¸Aldo2ğŸ›¡ï¸"; }
function type(){ return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo){
  if(!enemies.length) return;
  const ang=(dy,dx)=>Math.atan2(dy,dx)*180/Math.PI, norm=a=>((a%360)+360)%360;
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const tryMove=list=>{ for(const a of list){ if(tank.move(norm(a))) return true; } return false; };
  const lanes=[90,210,330];
  const score=(e)=>{ const n=allies.filter(a=>dist(a,e)<220).length; return (e.health - n*3.6) + e.distance*0.02; };
  const sorted=[...enemies].sort((a,b)=>score(a)-score(b));
  const t=sorted[0]||enemies[0];
  const base=ang(t.y-tank.y, t.x-tank.x);
  const ph=(Date.now() + (tank.x+tank.y)*5)%420, sign=ph<210?1:-1;
  const offset=Math.max(3, Math.min(14, t.distance/48));
  tank.fire(base + sign*offset);
  if(tank.y>560 && tryMove([270, 315, 225])) return;
  if(tank.y< 40 && tryMove([ 90,  45, 135])) return;
  if(tank.x< 40 && tryMove([  0,  45, 315])) return;
  if(tank.x>860 && tryMove([180, 135, 225])) return;
  let danger=null,bd=1e9; for(const b of bulletInfo){
    const dx=tank.x-b.x, dy=tank.y-b.y, dot=dx*b.vx+dy*b.vy;
    if(dot>0 && b.distance<bd && b.distance<170){ danger=b; bd=b.distance; } }
  if(danger){ const inA=ang(danger.vy,danger.vx); if(tryMove([inA+90, inA-90, base+180])) return; }
  const anchor=lanes.reduce((p,c)=>Math.abs(c-tank.y)<Math.abs(p-tank.y)?c:p,lanes[0]);
  if(Math.abs(tank.y-anchor)>14){ if(tryMove([tank.y<anchor?90:270, base+90, base-90])) return; }
  if(t.distance<240){ tryMove([base+180, base-180, base+90, base-90]); }
  else if(t.distance>360){ tryMove([base, base+15, base-15, base+90, base-90]); }
  else{ tryMove([base+(sign>0?90:-90), base+(sign>0?-90:90), base+180]); }
}

// ===== ë‹¤ìŒ ë¡œë´‡ =====
