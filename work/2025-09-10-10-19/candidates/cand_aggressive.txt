function name(){return "Valkyrie-A1";}
function type(){return Type.TANKER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+41)|0)%2?1:-1;
  const P={rMin:150,rMax:220,strafe:34,threatR:135,fleeBias:13,sep:62,edge:50,leadCap:12,leadW:0.95,aimJ:0.2,healthW:1.2,distW:0.15,finHP:26,aggrRemain:4,aggrMin:36,aggrMax:22,bias:-8};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+1)%23)-11)*0.08)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+70,a-70]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+14))return; if(tryM(to-14))return; } else { const side=to + ((((tank.x*13+tank.y*7+3)|0)%2)?P.strafe:-P.strafe) + P.bias*0.5; if(tryM(side))return; if(tryM(side+14))return; if(tryM(side-14))return; } }
  const sweep=[0,60,120,180,240,300]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}

function name(){return "Valkyrie-A2";}
function type(){return Type.TANKER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+43)|0)%2?1:-1;
  const P={rMin:155,rMax:225,strafe:34,threatR:135,fleeBias:13,sep:62,edge:52,leadCap:12,leadW:0.95,aimJ:0.2,healthW:1.2,distW:0.15,finHP:26,aggrRemain:4,aggrMin:36,aggrMax:22,bias:10};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+1)%23)-11)*0.08)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+70,a-70]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+14))return; if(tryM(to-14))return; } else { const side=to + ((((tank.x*13+tank.y*7+3)|0)%2)?P.strafe:-P.strafe) + P.bias*0.5; if(tryM(side))return; if(tryM(side+14))return; if(tryM(side-14))return; } }
  const sweep=[0,60,120,180,240,300]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}

function name(){return "Valkyrie-A3";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+47)|0)%2?1:-1;
  const P={rMin:210,rMax:320,strafe:30,threatR:140,fleeBias:12,sep:58,edge:48,leadCap:14,leadW:1.02,aimJ:0.16,healthW:1.25,distW:0.1,finHP:20,aggrRemain:4,aggrMin:40,aggrMax:26,bias:-12};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.55+vx*0.45, svy=lvy*0.55+vy*0.45; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+5)%23)-11)*0.06)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+80,a-80]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+12))return; if(tryM(to-12))return; } else { const side=to + ((((tank.x*13+tank.y*7+7)|0)%2)?P.strafe:-P.strafe) + P.bias*0.45; if(tryM(side))return; if(tryM(side+12))return; if(tryM(side-12))return; } }
  const sweep=[0,45,90,135,180,225,270,315]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}

function name(){return "Valkyrie-A4";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+53)|0)%2?1:-1;
  const P={rMin:215,rMax:325,strafe:30,threatR:140,fleeBias:12,sep:58,edge:48,leadCap:14,leadW:1.02,aimJ:0.16,healthW:1.25,distW:0.1,finHP:20,aggrRemain:4,aggrMin:40,aggrMax:26,bias:10};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.55+vx*0.45, svy=lvy*0.55+vy*0.45; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+9)%23)-11)*0.06)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+80,a-80]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+12))return; if(tryM(to-12))return; } else { const side=to + ((((tank.x*13+tank.y*7+11)|0)%2)?P.strafe:-P.strafe) + P.bias*0.45; if(tryM(side))return; if(tryM(side+12))return; if(tryM(side-12))return; } }
  const sweep=[0,45,90,135,180,225,270,315]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}

function name(){return "Valkyrie-A5";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+59)|0)%2?1:-1;
  const P={rMin:220,rMax:335,strafe:30,threatR:140,fleeBias:12,sep:58,edge:48,leadCap:14,leadW:1.02,aimJ:0.16,healthW:1.25,distW:0.1,finHP:20,aggrRemain:4,aggrMin:40,aggrMax:26,bias:-2};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.55+vx*0.45, svy=lvy*0.55+vy*0.45; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+13)%23)-11)*0.06)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+80,a-80]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+12))return; if(tryM(to-12))return; } else { const side=to + ((((tank.x*13+tank.y*7+15)|0)%2)?P.strafe:-P.strafe) + P.bias*0.45; if(tryM(side))return; if(tryM(side+12))return; if(tryM(side-12))return; } }
  const sweep=[0,45,90,135,180,225,270,315]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}

function name(){return "Valkyrie-A6";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v, H=Math.hypot; const rnd=((tank.x*97+tank.y*131+61)|0)%2?1:-1;
  const P={rMin:220,rMax:335,strafe:30,threatR:140,fleeBias:12,sep:58,edge:48,leadCap:14,leadW:1.02,aimJ:0.16,healthW:1.25,distW:0.1,finHP:20,aggrRemain:4,aggrMin:40,aggrMax:26,bias:14};
  let tgt=null,b=1e9; for(const e of enemies){ const k=e.health*P.healthW+e.distance*P.distW; if(k<b){b=k;tgt=e;} }
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=tgt.x-__state.last.x, vy=tgt.y-__state.last.y; const lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.55+vx*0.45, svy=lvy*0.55+vy*0.45; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t; } const jitter=((((tank.x*31+tank.y*17+17)%23)-11)*0.06)*P.aimJ; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }
  let tries=0; const tryM=(a)=>{tries++; return tank.move(norm(a));}; let hot=null,minD=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minD && d<P.threatR){minD=d;hot=bu;} } } if(hot){ const a=toDeg(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias+P.bias*0.6; const c=[a+100+side,a-100-side,a+80,a-80]; for(const k of c){ if(tryM(k)) return; } }
  if(tank.x<P.edge){ if(tryM(0))return; } if(tank.x>900-P.edge){ if(tryM(180))return; } if(tank.y<P.edge){ if(tryM(90))return; } if(tank.y>600-P.edge){ if(tryM(270))return; }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let minR=P.rMin, maxR=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){minR-=P.aggrMin; maxR-=P.aggrMax;} if(d<minR){ const away=to+180+P.bias*0.4; if(tryM(away))return; if(tryM(away+18))return; if(tryM(away-18))return; } else if(d>maxR){ if(tryM(to))return; if(tryM(to+12))return; if(tryM(to-12))return; } else { const side=to + ((((tank.x*13+tank.y*7+19)|0)%2)?P.strafe:-P.strafe) + P.bias*0.45; if(tryM(side))return; if(tryM(side+12))return; if(tryM(side-12))return; } }
  const sweep=[0,45,90,135,180,225,270,315]; for(const s of sweep){ if(tryM(s+P.bias)) return; }
}
