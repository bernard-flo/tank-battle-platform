function name(){return "ARES-B1";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:165,rMax:255,strafe:24,edge:56,sep:74,threatR:230,threatH:6,fleeBias:18,aimJitter:0.12,leadCap:18,assumeSpeed:5.0,aggrIn:34,aggrOut:22,finisherHP:28,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.3+e.distance*0.08+i*0.0003; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)+90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*11+tank.y*17)|0)%23-11)*0.07*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba+90+P.fleeBias,ba-90-P.fleeBias,ba+120,ba-120,ba+70,ba-70]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(150,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*19+tank.y*7)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  for(const s of [0,60,120,180,240,300]){ if(go(s)) return; }
}

// ===== 다음 로봇 =====

function name(){return "ARES-B2";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:170,rMax:265,strafe:22,edge:56,sep:72,threatR:230,threatH:6,fleeBias:18,aimJitter:0.12,leadCap:18,assumeSpeed:5.0,aggrIn:34,aggrOut:22,finisherHP:28,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.25+e.distance*0.09+i*0.0003; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)-90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*13+tank.y*19)|0)%23-11)*0.07*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba-90-P.fleeBias,ba+90+P.fleeBias,ba-120,ba+120,ba-60,ba+60]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(150,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*17+tank.y*11)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+14)) return; if(go(side-14)) return; }
  for(const s of [0,60,120,180,240,300]){ if(go(s)) return; }
}

// ===== 다음 로봇 =====

function name(){return "ARES-B3";}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:190,rMax:310,strafe:26,edge:52,sep:64,threatR:215,threatH:6,fleeBias:16,aimJitter:0.1,leadCap:16,assumeSpeed:5.6,aggrIn:28,aggrOut:18,finisherHP:24,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.2+e.distance*0.1+i*0.0002; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)+90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*29+tank.y*31)|0)%23-11)*0.06*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba+90+P.fleeBias,ba-90-P.fleeBias,ba+120,ba-120]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(140,r0-P.aggrIn); r1=Math.max(180,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*23+tank.y*17)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+12)) return; if(go(side-12)) return; }
  for(const s of [15,75,135,195,255,315]){ if(go(s)) return; }
}

// ===== 다음 로봇 =====

function name(){return "ARES-B4";}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:200,rMax:320,strafe:24,edge:52,sep:64,threatR:215,threatH:6,fleeBias:16,aimJitter:0.1,leadCap:16,assumeSpeed:5.6,aggrIn:28,aggrOut:18,finisherHP:24,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.25+e.distance*0.09+i*0.0002; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)-90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*31+tank.y*29)|0)%23-11)*0.06*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba-90-P.fleeBias,ba+90+P.fleeBias,ba-120,ba+120]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(140,r0-P.aggrIn); r1=Math.max(180,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*17+tank.y*23)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+12)) return; if(go(side-12)) return; }
  for(const s of [15,75,135,195,255,315]){ if(go(s)) return; }
}

// ===== 다음 로봇 =====

function name(){return "ARES-B5";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:215,rMax:345,strafe:22,edge:48,sep:62,threatR:220,threatH:5,fleeBias:14,aimJitter:0.09,leadCap:14,assumeSpeed:6.0,aggrIn:28,aggrOut:18,finisherHP:24,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.2+e.distance*0.11+i*0.0002; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)+90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*23+tank.y*41)|0)%23-11)*0.055*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba+90+P.fleeBias,ba-90-P.fleeBias,ba+120,ba-120,ba+70,ba-70]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(160,r0-P.aggrIn); r1=Math.max(200,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*19+tank.y*13)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+12)) return; if(go(side-12)) return; }
  for(const s of [25,85,145,205,265,325]){ if(go(s)) return; }
}

// ===== 다음 로봇 =====

function name(){return "ARES-B6";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  const D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360; if(a<0)a+=360; return a;}, H=Math.hypot, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={rMin:220,rMax:340,strafe:22,edge:48,sep:62,threatR:220,threatH:5,fleeBias:14,aimJitter:0.09,leadCap:14,assumeSpeed:6.0,aggrIn:28,aggrOut:18,finisherHP:24,aggrRemain:3};
  if(!enemies.length) return; let tgt=enemies[0], best=1e18; for(let i=0;i<enemies.length;i++){const e=enemies[i]; const k=e.health*1.25+e.distance*0.1+i*0.0002; if(k<best){best=k; tgt=e;}}
  const dx=tgt.x-tank.x, dy=tgt.y-tank.y, d=H(dx,dy); const t=CL(d/8,0,P.leadCap); const tangent=D(dx,dy)-90; const ax=Math.cos(tangent*Math.PI/180)*P.assumeSpeed, ay=Math.sin(tangent*Math.PI/180)*P.assumeSpeed; const jitter=(((tank.x*41+tank.y*23)|0)%23-11)*0.055*P.aimJitter; tank.fire(D(tgt.x+ax*t-tank.x,tgt.y+ay*t-tank.y)+jitter);
  let hot=null,score=1e18; for(const b of bulletInfo){const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const ux=b.vx/v, uy=b.vy/v; const proj=dx*ux+dy*uy; if(proj<=0) continue; const px=b.x-proj*ux,py=b.y-proj*uy; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; if(dist>P.threatR) continue; const s=dist+tt*(P.threatH); if(s<score){score=s; hot=b;}}
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };
  if(hot){ const ba=D(hot.vx,hot.vy); for(const c of [ba-90-P.fleeBias,ba+90+P.fleeBias,ba-120,ba+120,ba-70,ba+70]){ if(go(c)) return; } }
  if(tank.x < P.edge){ if(go(0)) return; } if(tank.x > 900-P.edge){ if(go(180)) return; } if(tank.y < P.edge){ if(go(90)) return; } if(tank.y > 600-P.edge){ if(go(270)) return; }
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance; near=a;} } if(near && ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; }
  const to=D(dx,dy); let r0=P.rMin, r1=P.rMax; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(160,r0-P.aggrIn); r1=Math.max(200,r1-P.aggrOut);} if(d<r0){ if(go(to+180)) return; } else if(d>r1){ if(go(to)) return; } else { const side=to+((((tank.x*13+tank.y*19)|0)%2)?P.strafe:-P.strafe); if(go(side)) return; if(go(side+12)) return; if(go(side-12)) return; }
  for(const s of [25,85,145,205,265,325]){ if(go(s)) return; }
}
