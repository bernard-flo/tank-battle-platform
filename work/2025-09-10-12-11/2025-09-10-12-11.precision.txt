function name(){return "AquilaX-T1";}
function type(){return Type.TANKER;}
let __state_0 = { last:null, tick:0, lastVel:null, side: ((0*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":170,"rMax":265,"strafe":22,"threatR":190,"threatH":4,"fleeBias":18,"sep":70,"edge":52,"leadCap":20,"leadW":1.04,"aimJitter":0.1,"healthW":1.25,"distW":0.1,"finisherHP":26,"aggrRemain":3,"aggrIn":26,"aggrOut":16,"prefDealer":1,"prefNormal":0,"bias":-10};
  const S=__state_0;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 0*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "AquilaX-D2";}
function type(){return Type.DEALER;}
let __state_1 = { last:null, tick:0, lastVel:null, side: ((1*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":210,"rMax":330,"strafe":30,"threatR":170,"threatH":5,"fleeBias":16,"sep":64,"edge":56,"leadCap":22,"leadW":1.15,"aimJitter":0.08,"healthW":1.2,"distW":0.08,"finisherHP":22,"aggrRemain":2,"aggrIn":35,"aggrOut":24,"prefDealer":1,"prefNormal":0,"aimBias":-0.4,"bias":-8};
  const S=__state_1;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 1*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "AquilaX-N3";}
function type(){return Type.NORMAL;}
let __state_2 = { last:null, tick:0, lastVel:null, side: ((2*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":180,"rMax":290,"strafe":26,"threatR":180,"threatH":4,"fleeBias":16,"sep":66,"edge":50,"leadCap":20,"leadW":1.08,"aimJitter":0.12,"healthW":1.25,"distW":0.1,"finisherHP":24,"aggrRemain":3,"aggrIn":28,"aggrOut":18,"prefDealer":1,"prefNormal":1,"bias":-6};
  const S=__state_2;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 2*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "AquilaX-T4";}
function type(){return Type.TANKER;}
let __state_3 = { last:null, tick:0, lastVel:null, side: ((3*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":170,"rMax":265,"strafe":22,"threatR":190,"threatH":4,"fleeBias":18,"sep":70,"edge":52,"leadCap":20,"leadW":1.04,"aimJitter":0.1,"healthW":1.25,"distW":0.1,"finisherHP":26,"aggrRemain":3,"aggrIn":26,"aggrOut":16,"prefDealer":1,"prefNormal":0,"bias":10};
  const S=__state_3;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 3*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "AquilaX-D5";}
function type(){return Type.DEALER;}
let __state_4 = { last:null, tick:0, lastVel:null, side: ((4*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":210,"rMax":330,"strafe":30,"threatR":170,"threatH":5,"fleeBias":16,"sep":64,"edge":56,"leadCap":22,"leadW":1.15,"aimJitter":0.08,"healthW":1.2,"distW":0.08,"finisherHP":22,"aggrRemain":2,"aggrIn":35,"aggrOut":24,"prefDealer":1,"prefNormal":0,"aimBias":-0.4,"bias":8};
  const S=__state_4;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 4*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "AquilaX-N6";}
function type(){return Type.NORMAL;}
let __state_5 = { last:null, tick:0, lastVel:null, side: ((5*17)%2?1:-1) };
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":180,"rMax":290,"strafe":26,"threatR":180,"threatH":4,"fleeBias":16,"sep":66,"edge":50,"leadCap":20,"leadW":1.08,"aimJitter":0.12,"healthW":1.25,"distW":0.1,"finisherHP":24,"aggrRemain":3,"aggrIn":28,"aggrOut":18,"prefDealer":1,"prefNormal":1,"bias":6};
  const S=__state_5;
  S.tick=(S.tick||0)+1;

  // 1) Target selection: prioritize low health, then distance; prefer DEALER/normal over TANKER slightly
  let tgt=null, best=1e18;
  for(const e of enemies){
    const typeW = (e.health<=P.finisherHP? -80: 0) + (P.prefDealer? (e.type===2?-10:0):0) + (P.prefNormal? (e.type===0?-6:0):0);
    const k = e.health*P.healthW + e.distance*P.distW + (e.x+e.y)*(P.tieBias||0) + typeW;
    if(k<best){best=k; tgt=e;}
  }

  // 2) Predictive aim with quadratic intercept solve using estimated velocity (graceful fallback)
  if(tgt){
    let ax=tgt.x, ay=tgt.y;
    let vx=0, vy=0;
    if(S.last){
      const lvx=S.lastVel?S.lastVel.vx:0, lvy=S.lastVel?S.lastVel.vy:0;
      const ivx=(tgt.x-S.last.x), ivy=(tgt.y-S.last.y);
      vx = lvx*0.5 + ivx*0.5; vy = lvy*0.5 + ivy*0.5; // low-pass
      S.lastVel={vx,vy};
      // Solve |r + v t|^2 = (s t)^2 where s=8 px/tick
      const rx = tgt.x - tank.x, ry = tgt.y - tank.y, s2 = 64; // 8^2
      const aa = vx*vx + vy*vy - s2;
      const bb = 2*(rx*vx + ry*vy);
      const cc = rx*rx + ry*ry;
      let tHit = 0;
      if (Math.abs(aa) < 1e-6) {
        tHit = bb !== 0 ? CL(-cc / bb, 0, P.leadCap) : 0;
      } else {
        const disc = bb*bb - 4*aa*cc;
        if (disc >= 0) {
          const sd = Math.sqrt(disc);
          const t1 = (-bb - sd) / (2*aa);
          const t2 = (-bb + sd) / (2*aa);
          const tc = t1>0 && t2>0 ? Math.min(t1,t2) : (t1>0?t1:(t2>0?t2:0));
          tHit = CL(tc, 0, P.leadCap);
        }
      }
      ax = tgt.x + vx * P.leadW * tHit;
      ay = tgt.y + vy * P.leadW * tHit;
    }
    const jitter = (((S.tick*13 + tank.x*7 + tank.y*3 + 5*11)%23)-11)*0.07*(P.aimJitter||0) + (P.aimBias||0);
    tank.fire(D(ax-tank.x,ay-tank.y) + jitter);
    S.last={x:tgt.x,y:tgt.y};
  }

  // Helper to attempt moves (HTML allows up to 10 failed moves; we still cap attempts locally)
  let moved=0; const go=(a)=>{ if(moved>20) return true; moved++; return tank.move(N(a)); };

  // 3) Bullet avoidance: project distance to bullet line, weight by time to closest approach
  let hot=null,score=1e18;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
    const proj=dx*nx+dy*ny; // forward progress along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // foot of perpendicular
      const dist=H(px-tank.x,py-tank.y);
      const tt=proj/v; // ticks until closest approach
      const s = dist + tt*(P.threatH||4);
      if(dist<P.threatR && s<score){ score=s; hot=b; }
    }
  }
  if(hot){
    const a=D(hot.vx,hot.vy);
    const side = (S.side||1)*P.fleeBias + (P.bias||0)*0.5;
    const options=[a+90+side, a-90-side, a+120, a-120, a+70, a-70, a+150, a-150];
    for(const c of options){ if(go(c)) return; }
  }

  // 4) Wall avoidance
  if(tank.x<P.edge){ if(go(0)) return; }
  if(tank.x>900-P.edge){ if(go(180)) return; }
  if(tank.y<P.edge){ if(go(90)) return; }
  if(tank.y>600-P.edge){ if(go(270)) return; }

  // 5) Ally separation to reduce collisions and crossfire
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad<P.sep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }

  // 6) Range control and strafing
  if(tgt){
    const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance;
    let r0=P.rMin, r1=P.rMax;
    if((tgt.health<=P.finisherHP)||enemies.length<=P.aggrRemain){
      r0=Math.max(120,r0-(P.aggrIn||30)); r1=Math.max(160,r1-(P.aggrOut||20));
    }
    if(d<r0){ const aw=to+180+(P.bias||0)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; }
    else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; }
    else { const s=to + ((S.side||1) * P.strafe) + (P.bias||0)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; }
  }

  // 7) Fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}