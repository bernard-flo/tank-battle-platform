// Hyperion Prime â€” self-contained bots (no cross-snippet deps)

// ===== R1 =====
function name(){ return "Hyperion-T1"; }
function type(){ return Type.TANKER; }
let __S1={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  // helpers
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:45, allySep:70, horizon:6, bulletRad:24, bulletWeight:0.095, etaW:0.35, inertia:0.0025, edgeW:0.06, rangeInW:0.018, rangeOutW:0.012, minRange:170, maxRange:250, orbit:26, fleeBias:14, wHealth:1.33, wDist:0.08 };
  __S1.tick=(__S1.tick||0)+1;
  // pick target
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  // fire predictive
  if(tgt){ let vx=0,vy=0; if(__S1.last&&Math.abs(__S1.last.x-tgt.x)<96&&Math.abs(__S1.last.y-tgt.y)<96){ vx=tgt.x-__S1.last.x; vy=tgt.y-__S1.last.y; } __S1.vx=__S1.vx*0.6+vx*0.4; __S1.vy=__S1.vy*0.6+vy*0.4; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S1.vx*__S1.vx+__S1.vy*__S1.vy, rv=rx*__S1.vx+ry*__S1.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,18); const ax=tgt.x+__S1.vx*t, ay=tgt.y+__S1.vy*t; const jitter=(((__S1.tick*31+(tank.x*5+tank.y*7)|0)%21)-10)*0.05; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S1.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=30; P.maxRange-=24; }
  if(tank.health<45) P.minRange+=44;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S1.lastMove!==undefined){ const da=Math.abs(((a-__S1.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); const side=((tank.x*13+tank.y*3)|0)%2?1:-1; add(base+P.orbit*side); add(base-P.orbit*side); add(base); add(base+180); add(base+P.orbit*0.5); add(base-P.orbit*0.5); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); }
  for(let s=0;s<360;s+=15) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b));
  for(const a of cands){ if(tank.move(a)){ __S1.lastMove=a; return; } }
  const fb=norm((__S1.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __S1.lastMove=fb; return; }
}

// ===== R2 =====
function name(){ return "Hyperion-T2"; }
function type(){ return Type.TANKER; }
let __S2={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:45, allySep:70, horizon:6, bulletRad:24, bulletWeight:0.095, etaW:0.35, inertia:0.0025, edgeW:0.06, rangeInW:0.018, rangeOutW:0.012, minRange:170, maxRange:250, orbit:26, fleeBias:14, wHealth:1.33, wDist:0.08 };
  __S2.tick=(__S2.tick||0)+1;
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__S2.last&&Math.abs(__S2.last.x-tgt.x)<96&&Math.abs(__S2.last.y-tgt.y)<96){ vx=tgt.x-__S2.last.x; vy=tgt.y-__S2.last.y; } __S2.vx=__S2.vx*0.5+vx*0.5; __S2.vy=__S2.vy*0.5+vy*0.5; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S2.vx*__S2.vx+__S2.vy*__S2.vy, rv=rx*__S2.vx+ry*__S2.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,22); const ax=tgt.x+__S2.vx*t, ay=tgt.y+__S2.vy*t; const jitter=(((__S2.tick*19+(tank.x*11+tank.y*7)|0)%11)-5)*0.08; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S2.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=28; P.maxRange-=24; } if(tank.health<45) P.minRange+=44;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S2.lastMove!==undefined){ const da=Math.abs(((a-__S2.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); const side=((tank.x*11+tank.y*5)|0)%2?1:-1; add(base+P.orbit*side); add(base-P.orbit*side); add(base); add(base+180); add(base+P.orbit*0.5); add(base-P.orbit*0.5); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); }
  for(let s=0;s<360;s+=15) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __S2.lastMove=a; return; } } const fb=norm((__S2.tick*41+tank.x+tank.y)|0); if(tank.move(fb)){ __S2.lastMove=fb; return; }
}

// ===== R3 =====
function name(){ return "Hyperion-D1"; }
function type(){ return Type.DEALER; }
let __S3={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:50, allySep:78, horizon:6, bulletRad:28, bulletWeight:0.095, etaW:0.45, inertia:0.002, edgeW:0.08, rangeInW:0.022, rangeOutW:0.014, minRange:205, maxRange:305, orbit:30, fleeBias:16, wHealth:1.34, wDist:0.07 };
  __S3.tick=(__S3.tick||0)+1;
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__S3.last&&Math.abs(__S3.last.x-tgt.x)<96&&Math.abs(__S3.last.y-tgt.y)<96){ vx=tgt.x-__S3.last.x; vy=tgt.y-__S3.last.y; } __S3.vx=__S3.vx*0.55+vx*0.45; __S3.vy=__S3.vy*0.55+vy*0.45; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S3.vx*__S3.vx+__S3.vy*__S3.vy, rv=rx*__S3.vx+ry*__S3.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,18); const ax=tgt.x+__S3.vx*t, ay=tgt.y+__S3.vy*t; const jitter=(((__S3.tick*13+(tank.x*17+tank.y*11)|0)%21)-10)*0.04; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S3.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=44; P.maxRange-=34; } if(tank.health<40) P.minRange+=56;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S3.lastMove!==undefined){ const da=Math.abs(((a-__S3.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__S3.spin); add(base-90-P.orbit*__S3.spin); add(base+55*__S3.spin); add(base-55*__S3.spin); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); add(a+120); add(a-120); }
  for(let s=0;s<360;s+=15) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __S3.lastMove=a; return; } } const fb=norm((__S3.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __S3.lastMove=fb; return; }
}

// ===== R4 =====
function name(){ return "Hyperion-D2"; }
function type(){ return Type.DEALER; }
let __S4={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:50, allySep:78, horizon:6, bulletRad:28, bulletWeight:0.095, etaW:0.45, inertia:0.002, edgeW:0.08, rangeInW:0.022, rangeOutW:0.014, minRange:205, maxRange:305, orbit:30, fleeBias:16, wHealth:1.34, wDist:0.07 };
  __S4.tick=(__S4.tick||0)+1;
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__S4.last&&Math.abs(__S4.last.x-tgt.x)<96&&Math.abs(__S4.last.y-tgt.y)<96){ vx=tgt.x-__S4.last.x; vy=tgt.y-__S4.last.y; } __S4.vx=__S4.vx*0.56+vx*0.44; __S4.vy=__S4.vy*0.56+vy*0.44; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S4.vx*__S4.vx+__S4.vy*__S4.vy, rv=rx*__S4.vx+ry*__S4.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,18); const ax=tgt.x+__S4.vx*t, ay=tgt.y+__S4.vy*t; const jitter=(((__S4.tick*13+(tank.x*11+tank.y*5)|0)%21)-10)*0.04; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S4.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=42; P.maxRange-=32; } if(tank.health<40) P.minRange+=56;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S4.lastMove!==undefined){ const da=Math.abs(((a-__S4.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__S4.spin); add(base-90-P.orbit*__S4.spin); add(base+55*__S4.spin); add(base-55*__S4.spin); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); add(a+120); add(a-120); }
  for(let s=0;s<360;s+=15) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __S4.lastMove=a; return; } } const fb=norm((__S4.tick*41+tank.x+tank.y)|0); if(tank.move(fb)){ __S4.lastMove=fb; return; }
}

// ===== R5 =====
function name(){ return "Hyperion-D3"; }
function type(){ return Type.DEALER; }
let __S5={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:50, allySep:78, horizon:6, bulletRad:28, bulletWeight:0.095, etaW:0.45, inertia:0.002, edgeW:0.08, rangeInW:0.022, rangeOutW:0.014, minRange:205, maxRange:305, orbit:30, fleeBias:16, wHealth:1.36, wDist:0.07 };
  __S5.tick=(__S5.tick||0)+1;
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__S5.last&&Math.abs(__S5.last.x-tgt.x)<96&&Math.abs(__S5.last.y-tgt.y)<96){ vx=tgt.x-__S5.last.x; vy=tgt.y-__S5.last.y; } __S5.vx=__S5.vx*0.55+vx*0.45; __S5.vy=__S5.vy*0.55+vy*0.45; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S5.vx*__S5.vx+__S5.vy*__S5.vy, rv=rx*__S5.vx+ry*__S5.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,18); const ax=tgt.x+__S5.vx*t, ay=tgt.y+__S5.vy*t; const jitter=(((__S5.tick*11+(tank.x*7+tank.y*13)|0)%21)-10)*0.04; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S5.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=44; P.maxRange-=34; } if(tank.health<40) P.minRange+=56;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S5.lastMove!==undefined){ const da=Math.abs(((a-__S5.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__S5.spin); add(base-90-P.orbit*__S5.spin); add(base+55*__S5.spin); add(base-55*__S5.spin); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); add(a+120); add(a-120); }
  for(let s=0;s<360;s+=15) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __S5.lastMove=a; return; } } const fb=norm((__S5.tick*43+tank.x+tank.y)|0); if(tank.move(fb)){ __S5.lastMove=fb; return; }
}

// ===== R6 =====
function name(){ return "Hyperion-N1"; }
function type(){ return Type.NORMAL; }
let __S6={tick:0,last:null,vx:0,vy:0,lastMove:undefined,spin:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const P={ edge:46, allySep:64, horizon:8, bulletRad:22, bulletWeight:0.118, etaW:0.17, inertia:0.0022, edgeW:0.085, rangeInW:0.017, rangeOutW:0.0105, minRange:210, maxRange:320, orbit:26, fleeBias:13, wHealth:1.33, wDist:0.08 };
  __S6.tick=(__S6.tick||0)+1;
  let tgt=null,best=1e12; for(const e of enemies){ const s=e.health*P.wHealth+e.distance*P.wDist; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__S6.last&&Math.abs(__S6.last.x-tgt.x)<96&&Math.abs(__S6.last.y-tgt.y)<96){ vx=tgt.x-__S6.last.x; vy=tgt.y-__S6.last.y; } __S6.vx=__S6.vx*0.52+vx*0.48; __S6.vy=__S6.vy*0.52+vy*0.48; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__S6.vx*__S6.vx+__S6.vy*__S6.vy, rv=rx*__S6.vx+ry*__S6.vy, rr=rx*rx+ry*ry; const A=vv-BUL*BUL,B=2*rv,C=rr; let t=0; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,24); const ax=tgt.x+__S6.vx*t, ay=tgt.y+__S6.vy*t; const jitter=(((__S6.tick*23+(tank.x*7+tank.y*13)|0)%13)-6)*0.08; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __S6.last={x:tgt.x,y:tgt.y}; }
  if(tgt&&tgt.health<=24){ P.minRange-=36; P.maxRange-=30; } if(tank.health<45) P.minRange+=48;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=relx*ux+rely*uy; const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__S6.lastMove!==undefined){ const da=Math.abs(((a-__S6.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__S6.spin); add(base-90-P.orbit*__S6.spin); add(base+50*__S6.spin); add(base-50*__S6.spin); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); }
  for(let s=0;s<360;s+=30) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __S6.lastMove=a; return; } } const fb=norm((__S6.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __S6.lastMove=fb; return; }
}
