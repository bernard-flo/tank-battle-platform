// Hyperion Prime Team (6 robots) â€” focus fire, predictive aim, evasive strafing
// Shared helpers and state
var HYP = (function(){
  const toDeg = (x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad = (a)=>a*Math.PI/180;
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const H = Math.hypot;
  const BUL_SPEED = 8;
  function pickTarget(enemies, pref){
    // Prefer lowest health, then distance
    let tgt=null, best=1e12;
    for(const e of enemies){
      const s = e.health*pref.wHealth + e.distance*pref.wDist;
      if(s<best){best=s; tgt=e;}
    }
    return tgt;
  }
  function leadAim(tank, tgt, state, lead){
    let vx=0, vy=0;
    if(state.last && Math.abs(state.last.x-tgt.x)<96 && Math.abs(state.last.y-tgt.y)<96){
      vx = tgt.x - state.last.x;
      vy = tgt.y - state.last.y;
    }
    state.vx = (state.vx||0)*lead.smooth + vx*(1-lead.smooth);
    state.vy = (state.vy||0)*lead.smooth + vy*(1-lead.smooth);
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vv=state.vx*state.vx+state.vy*state.vy;
    const rv=rx*state.vx+ry*state.vy;
    const rr=rx*rx+ry*ry;
    const A=vv - BUL_SPEED*BUL_SPEED, B=2*rv, C=rr;
    let t=0;
    if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} }
    t = clamp(t, 0, lead.cap);
    const ax = tgt.x + state.vx*t;
    const ay = tgt.y + state.vy*t;
    state.last = {x:tgt.x,y:tgt.y};
    const jitter = ((((tank.x*17 + tank.y*23)|0)%21)-10)*lead.jitter;
    return toDeg(ax-tank.x, ay-tank.y) + jitter;
  }
  function nearestHotBullet(tank, bullets){
    let hot=null, md=1e9;
    for(const b of bullets){
      const dx=b.x-tank.x, dy=b.y-tank.y;
      const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v;
      const proj=dx*nx+dy*ny; if(proj>0){
        const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y);
        if(d<md){ md=d; hot=b; }
      }
    }
    return hot;
  }
  function evalRisk(tank, a, cfg, allies, bullets, tgt){
    const SPEED = (tank.type===1?3:(tank.type===2?6:5));
    const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED;
    let risk=0; let px=tank.x, py=tank.y;
    for(let k=1;k<=cfg.horizon;k++){
      px+=dx; py+=dy;
      if(px<cfg.edge || px>900-cfg.edge) risk += (cfg.edge - Math.min(px,900-px))*cfg.edgeW;
      if(py<cfg.edge || py>600-cfg.edge) risk += (cfg.edge - Math.min(py,600-py))*cfg.edgeW;
      for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<cfg.allySep) risk += (cfg.allySep-d)*0.03; }
      for(const b of bullets){
        const bx = b.x + b.vx*k, by = b.y + b.vy*k;
        const relx = px - bx, rely = py - by;
        const d = H(relx, rely);
        if(d<cfg.bulletRad){ const vmag = H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along = relx*ux+rely*uy; const eta = Math.max(0,-along)/BUL_SPEED; const w = cfg.bulletWeight*(1+cfg.etaW*(cfg.horizon-k)); risk += (cfg.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); }
      }
      if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<cfg.minRange) risk += (cfg.minRange-d)*cfg.rangeInW; else if(d>cfg.maxRange) risk += (d-cfg.maxRange)*cfg.rangeOutW; }
    }
    if(this && this.lastMove!==undefined){ const da=Math.abs(((a-this.lastMove)%360+540)%360-180); risk += da*cfg.inertia; }
    return risk;
  }
  function decideMoveAngle(state, tank, enemies, allies, bullets, params){
    const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
    const tgt = pickTarget(enemies, params.targetPref);
    if(tgt){
      const base = toDeg(tgt.x-tank.x, tgt.y-tank.y);
      add(base);
      add(base+180);
      add(base+90+params.orbit*state.spin);
      add(base-90-params.orbit*state.spin);
      add(base+50*state.spin);
      add(base-50*state.spin);
    }
    const hot = nearestHotBullet(tank, bullets);
    if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+params.fleeBias); add(a-90-params.fleeBias); add(a+135); add(a-135); }
    for(let s=0;s<360;s+=30) add(s);
    cands.sort((a,b)=>evalRisk.call(state, tank, a, params.moveCfg, allies, bullets, tgt) - evalRisk.call(state, tank, b, params.moveCfg, allies, bullets, tgt));
    for(const a of cands){ if(tank.move(a)){ state.lastMove=a; return true; } }
    const fb = norm(((state.tick*37 + tank.x + tank.y)|0)); if(tank.move(fb)){ state.lastMove=fb; return true; }
    return false;
  }
  function fireIfCan(state, tank, enemies, params){
    const tgt = pickTarget(enemies, params.targetPref);
    if(!tgt) return;
    const aim = leadAim(tank, tgt, state, params.lead);
    tank.fire(aim);
  }
  function makeParams(kind){
    // kind: 'tank','deal','norm' -> tweak ranges/orbit
    const base = {
      targetPref: { wHealth: 1.33, wDist: 0.08 },
      lead: { smooth: 0.52, cap: 24, jitter: 0.08 },
      moveCfg: { edge: 46, allySep: 64, horizon: 8, bulletRad: 22, bulletWeight: 0.118, etaW: 0.17, inertia: 0.0022, edgeW: 0.085, rangeInW: 0.017, rangeOutW: 0.0105, minRange: 220, maxRange: 360 },
      orbit: 22,
      fleeBias: 13,
    };
    if(kind==='tank'){ base.moveCfg.minRange=170; base.moveCfg.maxRange=280; base.orbit=20; base.lead.jitter=0.06; }
    if(kind==='deal'){ base.moveCfg.minRange=250; base.moveCfg.maxRange=420; base.orbit=26; base.lead.jitter=0.085; }
    if(kind==='norm'){ base.moveCfg.minRange=210; base.moveCfg.maxRange=350; base.orbit=24; }
    return base;
  }
  function makeUpdate(kind){
    const params = makeParams(kind);
    const state = { tick:0, lastMove:undefined, last:null, vx:0, vy:0, spin: (Math.random()<0.5?-1:1) };
    return function(tank,enemies,allies,bulletInfo){
      "use strict";
      state.tick=(state.tick||0)+1;
      // Dynamic finishing behavior
      const tgt = pickTarget(enemies, params.targetPref);
      if(tgt && tgt.health<=24){ params.moveCfg.minRange -= 34; params.moveCfg.maxRange -= 28; }
      if(tank.health<45){ params.moveCfg.minRange += 48; }
      fireIfCan(state, tank, enemies, params);
      decideMoveAngle(state, tank, enemies, allies, bulletInfo, params);
    };
  }
  return { makeUpdate };
})();

// ===== R1 =====
function name(){ return "Hyperion-T1"; }
function type(){ return Type.TANKER; }
var __U1 = HYP.makeUpdate('tank');
function update(tank,enemies,allies,bulletInfo){ return __U1(tank,enemies,allies,bulletInfo); }

// ===== R2 =====
function name(){ return "Hyperion-T2"; }
function type(){ return Type.TANKER; }
var __U2 = HYP.makeUpdate('tank');
function update(tank,enemies,allies,bulletInfo){ return __U2(tank,enemies,allies,bulletInfo); }

// ===== R3 =====
function name(){ return "Hyperion-D1"; }
function type(){ return Type.DEALER; }
var __U3 = HYP.makeUpdate('deal');
function update(tank,enemies,allies,bulletInfo){ return __U3(tank,enemies,allies,bulletInfo); }

// ===== R4 =====
function name(){ return "Hyperion-D2"; }
function type(){ return Type.DEALER; }
var __U4 = HYP.makeUpdate('deal');
function update(tank,enemies,allies,bulletInfo){ return __U4(tank,enemies,allies,bulletInfo); }

// ===== R5 =====
function name(){ return "Hyperion-D3"; }
function type(){ return Type.DEALER; }
var __U5 = HYP.makeUpdate('deal');
function update(tank,enemies,allies,bulletInfo){ return __U5(tank,enemies,allies,bulletInfo); }

// ===== R6 =====
function name(){ return "Hyperion-N1"; }
function type(){ return Type.NORMAL; }
var __U6 = HYP.makeUpdate('norm');
function update(tank,enemies,allies,bulletInfo){ return __U6(tank,enemies,allies,bulletInfo); }

