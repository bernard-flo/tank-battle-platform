[
  {
    "preset": "apex",
    "wins": 32,
    "games": 32,
    "winrate": 1,
    "blocks": [
      "// Apex-T1\nfunction name(){return \"Apex-T1\";}\nfunction type(){return Type.TANKER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 70;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (-10);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(-10)))) return;\n      if (tank.move(norm(a-90-(-10)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 170){\n        const away = to+180 + (-10);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 270){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(-10)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Apex-T2\nfunction name(){return \"Apex-T2\";}\nfunction type(){return Type.TANKER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 70;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (10);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(10)))) return;\n      if (tank.move(norm(a-90-(10)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 170){\n        const away = to+180 + (10);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 270){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(10)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Apex-D1\nfunction name(){return \"Apex-D1\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('low'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 78;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (25);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(25)))) return;\n      if (tank.move(norm(a-90-(25)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 230){\n        const away = to+180 + (25);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 340){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(25)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Apex-D2\nfunction name(){return \"Apex-D2\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('low'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 78;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (-25);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(-25)))) return;\n      if (tank.move(norm(a-90-(-25)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 230){\n        const away = to+180 + (-25);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 340){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(-25)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Apex-D3\nfunction name(){return \"Apex-D3\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 78;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (0);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(0)))) return;\n      if (tank.move(norm(a-90-(0)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 230){\n        const away = to+180 + (0);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 330){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(0)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Apex-N\nfunction name(){return \"Apex-N\";}\nfunction type(){return Type.NORMAL;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 72;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (0);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(0)))) return;\n      if (tank.move(norm(a-90-(0)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 210){\n        const away = to+180 + (0);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 310){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(0)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n"
    ]
  },
  {
    "preset": "vanguard",
    "wins": 32,
    "games": 32,
    "winrate": 1,
    "blocks": [
      "// Vanguard-T1\nfunction name(){return \"Vanguard-T1\";}\nfunction type(){return Type.TANKER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 68;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (-5);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(-5)))) return;\n      if (tank.move(norm(a-90-(-5)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 160){\n        const away = to+180 + (-5);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 260){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(-5)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Vanguard-T2\nfunction name(){return \"Vanguard-T2\";}\nfunction type(){return Type.TANKER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 68;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (5);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(5)))) return;\n      if (tank.move(norm(a-90-(5)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 160){\n        const away = to+180 + (5);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 260){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(5)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Vanguard-D1\nfunction name(){return \"Vanguard-D1\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('low'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 80;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (20);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(20)))) return;\n      if (tank.move(norm(a-90-(20)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 240){\n        const away = to+180 + (20);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 350){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(20)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Vanguard-D2\nfunction name(){return \"Vanguard-D2\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('low'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 80;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (-20);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(-20)))) return;\n      if (tank.move(norm(a-90-(-20)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 240){\n        const away = to+180 + (-20);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 350){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(-20)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Vanguard-D3\nfunction name(){return \"Vanguard-D3\";}\nfunction type(){return Type.DEALER;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 80;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (0);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(0)))) return;\n      if (tank.move(norm(a-90-(0)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 230){\n        const away = to+180 + (0);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 340){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(0)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n",
      "// Vanguard-N\nfunction name(){return \"Vanguard-N\";}\nfunction type(){return Type.NORMAL;}\n(function(){\n  let lastSeen = {x:0,y:0,t:0};\n  let lastAim = 0;\n  function norm(a){a%=360; if(a<0)a+=360; return a;}\n  function ang(x,y){return Math.atan2(y,x)*180/Math.PI;}\n  function pickTarget(enemies){\n    if(!enemies.length) return null;\n    if ('closest'==='low'){\n      let r=enemies[0]; for(const e of enemies){ if(e.health < r.health) r=e; } return r;\n    } else {\n      let r=enemies[0]; for(const e of enemies){ if(e.distance < r.distance) r=e; } return r;\n    }\n  }\n  function leadAngle(tx,ty, ex,ey, bs){\n    // 목표의 속도 추정 (마지막 프레임과 비교). dt ~ 50ms per tick 기준 추정\n    const now = Date.now();\n    const dt = Math.max(50, Math.min(250, now - lastSeen.t || 100));\n    const vx = (ex - lastSeen.x) / (dt/50);\n    const vy = (ey - lastSeen.y) / (dt/50);\n    const dx = ex - tx, dy = ey - ty;\n    // 선행 점 t를 근사적으로 추정 (해석적 계산 대신 반복 근사)\n    let t=1.0; // ticks\n    for(let i=0;i<3;i++){\n      const px = ex + vx * t, py = ey + vy * t;\n      const dist = Math.hypot(px - tx, py - ty);\n      t = dist / bs; // ticks to reach\n    }\n    const aimX = ex + vx * t, aimY = ey + vy * t;\n    return ang(aimX - tx, aimY - ty);\n  }\n  function threat(b, tank){\n    // 우리쪽으로 접근하며 경로가 근접\n    const dx=b.x-tank.x, dy=b.y-tank.y; const sp=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/sp, ny=b.vy/sp;\n    const proj = dx*nx + dy*ny; if (proj <= 0) return false; // 지나감\n    const px = b.x - proj*nx, py = b.y - proj*ny; const d = Math.hypot(px-tank.x, py-tank.y);\n    return d < 72;\n  }\n  function avoidAllies(tank, allies){\n    let ax=0, ay=0; let cnt=0;\n    for(const a of allies){ if(a.distance<70){ ax += tank.x - a.x; ay += tank.y - a.y; cnt++; } }\n    if(cnt>0){ const a = ang(ax, ay); if(tank.move(norm(a))) return true; if(tank.move(norm(a+20))) return true; if(tank.move(norm(a-20))) return true; }\n    return false;\n  }\n  function strafeAround(tank, to){\n    const side = to + (0);\n    return tank.move(norm(side)) || tank.move(norm(side+25)) || tank.move(norm(side-25));\n  }\n  function update(tank,enemies,allies,bulletInfo){\n    const tgt = pickTarget(enemies);\n    if (tgt){\n      const aim = leadAngle(tank.x, tank.y, tgt.x, tgt.y, 8);\n      lastAim = aim; tank.fire(aim);\n      lastSeen = {x:tgt.x, y:tgt.y, t: Date.now()};\n    } else {\n      tank.fire(lastAim);\n    }\n    // 회피 최우선\n    let hot=null, md=1e9; for(const b of bulletInfo){ const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<md && threat(b,tank)){ md=d; hot=b; } }\n    if (hot){\n      const a = ang(hot.vx, hot.vy);\n      if (tank.move(norm(a+90+(0)))) return;\n      if (tank.move(norm(a-90-(0)))) return;\n    }\n    if (avoidAllies(tank, allies)) return;\n    if (tgt){\n      const d = tgt.distance; const to = ang(tgt.x - tank.x, tgt.y - tank.y);\n      if (d < 200){\n        const away = to+180 + (0);\n        if (tank.move(norm(away))) return; if (tank.move(norm(away+20))) return; if (tank.move(norm(away-20))) return;\n      } else if (d > 300){\n        if (tank.move(norm(to))) return; if (tank.move(norm(to+20))) return; if (tank.move(norm(to-20))) return;\n      } else {\n        if (strafeAround(tank, to)) return;\n      }\n    }\n    const pref=[0,90,180,270]; for(const p of pref){ if (tank.move(norm(p+(0)))) return; }\n  }\n  this.update = update; // 노출\n})();\nfunction update(tank,enemies,allies,bulletInfo){ return this.update(tank,enemies,allies,bulletInfo); }\n"
    ]
  }
]