function name() {
  return 'Tanker Guardian';
}

function type() {
  return Type.TANKER;
}

function update(tank, enemies, allies, bulletInfo) {
  // -------- utils --------
  const toDeg = (r) => r * 180 / Math.PI;
  const toRad = (d) => d * Math.PI / 180;
  const norm = (a) => ((a % 360) + 360) % 360;
  const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));
  const cross = (ax, ay, bx, by) => ax * by - ay * bx;

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    const cand = [15, -15, 30, -30, 60, -60, 90, -90, 120, -120, 180];
    for (let d of cand) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function pickThreatBullet() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let best = null, bestScore = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r); // approaching speed along LOS
      if (rv <= 0) continue; // moving away
      const ttc = r / (Math.hypot(b.vx, b.vy) + 1e-6);
      const score = rv * 1.2 + 200 / (r + 1) - ttc * 0.1;
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  function dodge(b) {
    const bang = toDeg(Math.atan2(b.vy, b.vx));
    const rx = tank.x - b.x, ry = tank.y - b.y;
    const side = Math.sign(cross(b.vx, b.vy, rx, ry)) || 1;
    const evade = bang + (side > 0 ? 90 : -90);
    moveSafe(evade);
  }

  if (!enemies || enemies.length === 0) return;

  // 공통 타겟: 가장 가까운 적
  let tgt = enemies[0];
  for (const e of enemies) if (e.distance < tgt.distance) tgt = e;

  // 위협 탄 회피 우선
  const threat = pickThreatBullet();
  if (threat) {
    dodge(threat);
  } else {
    // 근접 압박 -> 근접시 오비트로 각 흔들기
    if (tgt.distance > 180) {
      moveSafe(angleTo(tank.x, tank.y, tgt.x, tgt.y));
    } else {
      const base = angleTo(tank.x, tank.y, tgt.x, tgt.y) + 90;
      // 위치 기반 소폭 요동(의사 난수)
      const jitter = ((Math.floor((tank.x + tank.y) / 35) % 2) ? 12 : -12);
      moveSafe(base + jitter);
    }
  }

  // 사격: 단순 조준 + 소폭 오프셋
  const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x ^ tank.y) & 1) ? 2 : -2);
  tank.fire(norm(f));
}



// ===== 다음 로봇 =====

function name() {
  return 'Dealer Sniper';
}

function type() {
  return Type.DEALER;
}

function update(tank, enemies, allies, bulletInfo) {
  // -------- utils --------
  const toDeg = (r) => r * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    for (let d of [15, -15, 30, -30, 60, -60, 90, -90]) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function pickThreatBullet() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let best = null, bestScore = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r);
      if (rv <= 0) continue;
      const score = rv + 150 / (r + 1);
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  function dodge(b) {
    const ang = toDeg(Math.atan2(b.vy, b.vx));
    const evade = ang + (((tank.x + tank.y) % 100 < 50) ? 90 : -90);
    moveSafe(evade);
  }

  if (!enemies || enemies.length === 0) return;

  // 타겟: 체력 낮은 적 우선 → 거리 보조
  let tgt = enemies[0];
  for (const e of enemies) {
    const better = (e.health < tgt.health - 1) || (e.health === tgt.health && e.distance < tgt.distance);
    if (better) tgt = e;
  }

  const threat = pickThreatBullet();
  if (threat) {
    dodge(threat);
  } else {
    const desired = 300; // 유지 거리
    if (tgt.distance < 220) {
      // 이탈
      moveSafe(norm(angleTo(tank.x, tank.y, tgt.x, tgt.y) + 180));
    } else if (tgt.distance > 340) {
      // 접근
      moveSafe(angleTo(tank.x, tank.y, tgt.x, tgt.y));
    } else {
      // 오비트(완만)
      const base = angleTo(tank.x, tank.y, tgt.x, tgt.y) + 90;
      const jitter = ((Math.floor((tank.x * 3 + tank.y) / 57) % 2) ? 10 : -10);
      moveSafe(base + jitter);
    }
  }

  // 사격: 장거리 조준 + 미세 오프셋
  const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x ^ tank.y) & 2) ? 1.5 : -1.5);
  tank.fire(norm(f));
}



// ===== 다음 로봇 =====

function name() {
  return 'Dealer Flanker';
}

function type() {
  return Type.DEALER;
}

function update(tank, enemies, allies, bulletInfo) {
  const toDeg = (r) => r * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    for (let d of [20, -20, 40, -40, 70, -70, 110, -110]) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function mostThreatBullet() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let b0 = null, sc = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r);
      if (rv <= 0) continue;
      const score = rv + 180 / (r + 1);
      if (score > sc) { sc = score; b0 = b; }
    }
    return b0;
  }

  function dodge(b) {
    const a = toDeg(Math.atan2(b.vy, b.vx));
    const flip = ((Math.floor((tank.x - tank.y) / 43) & 1) ? 1 : -1);
    moveSafe(a + 90 * flip);
  }

  if (!enemies || enemies.length === 0) return;
  let tgt = enemies[0];
  for (const e of enemies) if (e.distance < tgt.distance) tgt = e;

  const threat = mostThreatBullet();
  if (threat) {
    dodge(threat);
  } else {
    // 접근 후 측후방 오비트
    if (tgt.distance > 220) {
      moveSafe(angleTo(tank.x, tank.y, tgt.x, tgt.y));
    } else {
      const base = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x + tank.y) % 120 < 60) ? 90 : -90);
      // 반경 보정: 너무 붙으면 약간 이탈, 멀면 접근
      const adj = tgt.distance < 160 ? -20 : (tgt.distance > 240 ? 20 : 0);
      moveSafe(base + adj);
    }
  }

  const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x * 7 + tank.y) % 2) ? 1 : -1);
  tank.fire(norm(f));
}



// ===== 다음 로봇 =====

function name() {
  return 'Normal Interceptor';
}

function type() {
  return Type.NORMAL;
}

function update(tank, enemies, allies, bulletInfo) {
  const toDeg = (r) => r * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    for (let d of [15, -15, 35, -35, 55, -55, 85, -85]) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function mostThreat() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let best = null, score = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r);
      if (rv <= 0) continue;
      const lat = Math.abs(b.vx * ry - b.vy * rx) / r;
      const s = rv * 1.4 + 220 / (r + 1) - 0.2 * lat;
      if (s > score) { score = s; best = b; }
    }
    return best;
  }

  function dodge(b) {
    const ang = toDeg(Math.atan2(b.vy, b.vx));
    // 수직 회피 + 미세 요동
    const off = ((Math.floor((tank.x * 5 - tank.y) / 41) % 2) ? 90 : -90);
    moveSafe(ang + off);
  }

  let tgt = null;
  if (enemies && enemies.length > 0) {
    tgt = enemies[0];
    for (const e of enemies) if (e.distance < tgt.distance) tgt = e;
  }

  const th = mostThreat();
  if (th) {
    dodge(th);
  } else if (tgt) {
    // 약한 전진으로 각 잡기
    if (tgt.distance > 200) moveSafe(angleTo(tank.x, tank.y, tgt.x, tgt.y));
    else {
      const base = angleTo(tank.x, tank.y, tgt.x, tgt.y) + 90;
      moveSafe(base + (((tank.x + tank.y) & 1) ? 8 : -8));
    }
  }

  if (tgt) {
    const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x ^ tank.y) & 1) ? 1 : -1);
    tank.fire(norm(f));
  }
}



// ===== 다음 로봇 =====

function name() {
  return 'Normal Support';
}

function type() {
  return Type.NORMAL;
}

function update(tank, enemies, allies, bulletInfo) {
  const toDeg = (r) => r * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    for (let d of [15, -15, 30, -30, 60, -60, 90, -90]) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function threatBullet() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let b0 = null, sc = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y, r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r);
      if (rv <= 0) continue;
      const s = rv + 160 / (r + 1);
      if (s > sc) { sc = s; b0 = b; }
    }
    return b0;
  }

  function dodge(b) {
    const ang = toDeg(Math.atan2(b.vy, b.vx));
    const flip = (((tank.x * 13 + tank.y) % 101) < 50) ? 1 : -1;
    moveSafe(ang + 90 * flip);
  }

  // 아군 중심
  let cx = tank.x, cy = tank.y;
  if (allies && allies.length > 0) {
    let sx = tank.x, sy = tank.y, n = 1;
    for (const a of allies) { sx += a.x; sy += a.y; n++; }
    cx = sx / n; cy = sy / n;
  }

  // 타겟: 체력 낮음 → 가까움
  let tgt = null;
  if (enemies && enemies.length > 0) {
    tgt = enemies[0];
    for (const e of enemies) {
      const better = (e.health < tgt.health - 1) || (e.health === tgt.health && e.distance < tgt.distance);
      if (better) tgt = e;
    }
  }

  const th = threatBullet();
  if (th) {
    dodge(th);
  } else {
    const dc = Math.hypot(tank.x - cx, tank.y - cy);
    if (dc > 140) moveSafe(angleTo(tank.x, tank.y, cx, cy));
    else {
      // 팀 중심을 기준으로 완만한 오비트
      const base = angleTo(cx, cy, tank.x, tank.y) + 90;
      moveSafe(base + (((tank.x + tank.y) & 1) ? 10 : -10));
    }
  }

  if (tgt) {
    const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x ^ tank.y) & 2) ? 1 : -1);
    tank.fire(norm(f));
  }
}



// ===== 다음 로봇 =====

function name() {
  return 'Tanker Bruiser';
}

function type() {
  return Type.TANKER;
}

function update(tank, enemies, allies, bulletInfo) {
  const toDeg = (r) => r * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angleTo = (x1, y1, x2, y2) => toDeg(Math.atan2(y2 - y1, x2 - x1));

  function moveSafe(a) {
    a = norm(a);
    if (tank.move(a)) return true;
    for (let d of [15, -15, 30, -30, 60, -60, 90, -90, 120, -120]) {
      if (tank.move(norm(a + d))) return true;
    }
    return false;
  }

  function threatBullet() {
    if (!bulletInfo || bulletInfo.length === 0) return null;
    let best = null, score = -1e9;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y, r = Math.hypot(rx, ry) || 1e-6;
      const rv = (-(b.vx * rx + b.vy * ry) / r);
      if (rv <= 0) continue;
      const s = rv * 1.1 + 180 / (r + 1);
      if (s > score) { score = s; best = b; }
    }
    return best;
  }

  function dodge(b) {
    const ang = toDeg(Math.atan2(b.vy, b.vx));
    // 지그재그 유지: 수직 + 오프셋
    const flip = ((Math.floor((tank.x + 2 * tank.y) / 50) % 2) ? 1 : -1);
    moveSafe(ang + 90 * flip);
  }

  if (!enemies || enemies.length === 0) return;
  let tgt = enemies[0];
  for (const e of enemies) if (e.distance < tgt.distance) tgt = e;

  const th = threatBullet();
  if (th) {
    dodge(th);
  } else {
    const base = angleTo(tank.x, tank.y, tgt.x, tgt.y);
    if (tgt.distance > 160) {
      // 지그재그 전진
      const zig = ((Math.floor((tank.x + tank.y) / 40) % 2) ? 22 : -22);
      moveSafe(base + zig);
    } else {
      // 근접 오비트
      moveSafe(base + (((tank.x * 3 + tank.y) % 100 < 50) ? 90 : -90));
    }
  }

  const f = angleTo(tank.x, tank.y, tgt.x, tgt.y) + (((tank.x ^ tank.y) & 1) ? 2 : -2);
  tank.fire(norm(f));
}



