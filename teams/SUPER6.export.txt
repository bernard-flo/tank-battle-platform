// Tanker Guardian — 선두 방패, 팀 중심 유지, 근접 위협 각도 제어
function name() { return 'Tanker Guardian'; }
function type() { try { return Type.TANKER; } catch (e) { return 2; } }

function update(tank, enemies, allies, bulletInfo) {
  // ---- 유틸 ----
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function dist(a, b) { var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function normDeg(a){ a%=360; if(a<-180) a+=360; if(a>180) a-=360; return a; }
  function tryMove(angleDeg) {
    // 실패 시 ±15° 보정 재시도 (최대 10회)
    var step = 15;
    for (var i=0;i<10;i++) {
      var ang = angleDeg + ((i%2===0?1:-1) * Math.ceil(i/2) * step);
      tank.move(ang);
    }
  }
  function nearest(list, from){
    var best=null, bd=1e9;
    for(var i=0;i<list.length;i++){
      var d=dist(list[i], from); if(d<bd){ bd=d; best=list[i]; }
    }
    return best;
  }
  function alliesCenter() {
    if(!allies||allies.length===0) return {x:tank.x,y:tank.y};
    var sx=0, sy=0; for(var i=0;i<allies.length;i++){ sx+=allies[i].x; sy+=allies[i].y; }
    return {x:sx/allies.length, y:sy/allies.length};
  }
  function leadAngle(src, dst, bulletSpeed){
    // 간단한 짧은 리드샷: 상대 속도 평균이 없으므로 vx,vy 기반 추정만 사용
    var rx = dst.x - src.x, ry = dst.y - src.y;
    var dvx = dst.vx||0, dvy = dst.vy||0;
    var a = dvx*dvx + dvy*dvy - bulletSpeed*bulletSpeed;
    var b = 2*(rx*dvx + ry*dvy);
    var c = rx*rx + ry*ry;
    var t; // 충돌 시간 근사
    if (Math.abs(a) < 1e-6) {
      t = (c>1e-6) ? (-c/b) : 0;
    } else {
      var disc = b*b - 4*a*c; if (disc < 0) disc = 0;
      var t1 = (-b + Math.sqrt(disc)) / (2*a);
      var t2 = (-b - Math.sqrt(disc)) / (2*a);
      t = Math.max(t1, t2);
    }
    if (!isFinite(t) || t < 0) t = 0;
    var aimX = dst.x + (dst.vx||0)*t; var aimY = dst.y + (dst.vy||0)*t;
    return angleTo(src.x, src.y, aimX, aimY);
  }

  // ---- 파라미터 ----
  var PARAMS = (typeof PARAMS !== 'undefined') ? PARAMS : {};
  var idealRange = PARAMS.ideal_range ?? 200;
  var bulletSpeed = PARAMS.bulletSpeed ?? 400; // px/s (엔진에서는 per-tick 주입)

  // ---- 위협 탄 분석 ----
  var mostThreat=null, bestScore=-1e9;
  for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){
    var b = bulletInfo[i];
    var rx = tank.x - b.x, ry = tank.y - b.y;
    var d = Math.hypot(rx, ry) + 1e-6;
    var relSpeed = -(rx*(b.vx||0) + ry*(b.vy||0)) / d; // 접근 속도 성분
    var score = relSpeed / d; // 접근속도 · 역거리
    if (score > bestScore) { bestScore=score; mostThreat=b; }
  }

  if (mostThreat && bestScore > 0) {
    // 탄 궤적에 수직 이동(보스턴 회피)
    var ang = Math.atan2(mostThreat.vy||0, mostThreat.vx||0) * 180/Math.PI;
    var evade = ang + 90 * (Math.random()<0.5?1:-1);
    tryMove(evade);
  } else {
    // 팀 중심 근처 유지 + 최근접 적 추적
    var center = alliesCenter();
    var target = nearest(enemies||[], tank) || null;
    if (target) {
      // 거리 유지: idealRange로 수렴
      var d = dist(target, tank);
      var baseAng = angleTo(tank.x, tank.y, target.x, target.y);
      var moveAng = (d>idealRange? baseAng : baseAng+180);
      // 약간의 난수화로 예측 회피
      moveAng += (Math.random()*10-5);
      tryMove(moveAng);

      // 짧은 리드샷
      var aim = leadAngle(tank, target, bulletSpeed);
      var jitter = (Math.random()*4-2);
      tank.fire(aim + jitter);
    } else {
      // 타겟이 없으면 팀 중심에 정렬
      var angToC = angleTo(tank.x, tank.y, center.x, center.y);
      tryMove(angToC);
    }
  }
}



// ===== 다음 로봇 =====


// Dealer Sniper — 장거리 정밀 사격, 카이팅, 탄 회피 우선
function name() { return 'Dealer Sniper'; }
function type() { try { return Type.DEALER; } catch(e) { return 3; } }

function update(tank, enemies, allies, bulletInfo) {
  // ---- 유틸 ----
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(a,b){var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function leadAngle(src,dst,bulletSpeed){
    var rx=dst.x-src.x, ry=dst.y-src.y;
    var dvx=dst.vx||0, dvy=dst.vy||0;
    var a=dvx*dvx+dvy*dvy-bulletSpeed*bulletSpeed;
    var b=2*(rx*dvx+ry*dvy);
    var c=rx*rx+ry*ry; var t;
    if(Math.abs(a)<1e-6){ t=(c>1e-6)?(-c/b):0; }
    else { var disc=b*b-4*a*c; if(disc<0)disc=0; var t1=(-b+Math.sqrt(disc))/(2*a); var t2=(-b-Math.sqrt(disc))/(2*a); t=Math.max(t1,t2); }
    if(!isFinite(t) || t<0) t=0;
    var axx = dst.x + (dst.vx||0)*t; var ayy = dst.y + (dst.vy||0)*t;
    return angleTo(src.x, src.y, axx, ayy);
  }
  function tryMove(angleDeg){
    for(var i=0;i<10;i++){
      var off=(i%2===0?1:-1)*Math.ceil(i/2)*12;
      tank.move(angleDeg+off);
    }
  }
  function pickLowestHP(list){
    var best=null, bh=1e9, bd=1e9; var cx=400, cy=300; // 중앙 근사
    for(var i=0;i<list.length;i++){
      var e=list[i]; var hp=e.hp!=null?e.hp:(e.health!=null?e.health:100);
      var d=dist(e,tank); var c=dist(e,{x:cx,y:cy});
      var key=[hp,d,c]; // hp 우선 → 가까움 → 중앙가까움
      if(!best){best=e; bh=hp; bd=d; var bc=c;}
      else{
        if(hp<bh || (hp===bh && (d<bd || (d===bd && c<bc)))){best=e; bh=hp; bd=d; bc=c;}
      }
    }
    return best;
  }

  // ---- 파라미터 ----
  var P=(typeof PARAMS!=='undefined')?PARAMS:{};
  var keepRange = P.ideal_range ?? 350;
  var orbitDeg = P.orbit_deg ?? 25;
  var bulletSpeed = P.bulletSpeed ?? 400;

  // ---- 탄 회피 우선 ----
  var threat=null, bestScore=-1e9;
  for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){
    var b=bulletInfo[i]; var rx=tank.x-b.x, ry=tank.y-b.y; var d=Math.hypot(rx,ry)+1e-6;
    var rel = -(rx*(b.vx||0)+ry*(b.vy||0))/d; var score=rel/d;
    if(score>bestScore){bestScore=score; threat=b;}
  }
  if(threat && bestScore>0){
    var ang = Math.atan2(threat.vy||0, threat.vx||0)*180/Math.PI;
    var evade = ang + 90*(Math.random()<0.5?1:-1);
    tryMove(evade);
  } else if(enemies && enemies.length){
    var tgt = pickLowestHP(enemies);
    var d = dist(tgt, tank);
    // 카이팅: 최대 사거리 유지 + 큰 오비트
    var base = angleTo(tank.x, tank.y, tgt.x, tgt.y);
    var dir = (tank._sn_dir = (tank._sn_dir|| (Math.random()<0.5?1:-1)) );
    var moveAng = base + dir * orbitDeg + (d>keepRange?0:180);
    tryMove(moveAng);
    // 사격 쿨 관리(간단 타이머)
    var now = (tank._sn_t||0)+1; tank._sn_t=now;
    var fireGap = P.fire_every ?? 6; // 프레임 기준 추정치
    if(now % fireGap === 0){
      var aim = leadAngle(tank, tgt, bulletSpeed);
      tank.fire(aim + (Math.random()*3-1.5));
    }
  }
}



// ===== 다음 로봇 =====


// Dealer Flanker — 측후방 진입, 원운동 오비트, 반경 조절
function name() { return 'Dealer Flanker'; }
function type() { try { return Type.DEALER; } catch(e){ return 3; } }

function update(tank, enemies, allies, bulletInfo){
  // 유틸
  function dist(a,b){var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function tryMove(a){ for(var i=0;i<10;i++){ var off=(i%2===0?1:-1)*Math.ceil(i/2)*12; tank.move(a+off);} }
  function leadAngle(src,dst,bs){
    var rx=dst.x-src.x, ry=dst.y-src.y; var dvx=dst.vx||0, dvy=dst.vy||0;
    var a=dvx*dvx+dvy*dvy-bs*bs, b=2*(rx*dvx+ry*dvy), c=rx*rx+ry*ry; var t;
    if(Math.abs(a)<1e-6){ t=(c>1e-6)?(-c/b):0; } else { var disc=b*b-4*a*c; if(disc<0)disc=0; var t1=(-b+Math.sqrt(disc))/(2*a); var t2=(-b-Math.sqrt(disc))/(2*a); t=Math.max(t1,t2);} if(!isFinite(t)||t<0) t=0;
    return angleTo(src.x,src.y, dst.x+(dst.vx||0)*t, dst.y+(dst.vy||0)*t);
  }

  var P=(typeof PARAMS!=='undefined')?PARAMS:{};
  var orbit = P.orbit_deg ?? 90; // ±90° 원운동 기본
  var radius = P.orbit_radius ?? 180;
  var radiusJitter = P.radius_jitter ?? 40;
  var bulletSpeed = P.bulletSpeed ?? 400;

  // 위협 탄 우선 회피
  var threat=null, s=-1e9; for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){ var b=bulletInfo[i]; var rx=tank.x-b.x, ry=tank.y-b.y; var d=Math.hypot(rx,ry)+1e-6; var rel=-(rx*(b.vx||0)+ry*(b.vy||0))/d; var sc=rel/d; if(sc>s){s=sc;threat=b;} }
  if(threat && s>0){ var ang=Math.atan2(threat.vy||0, threat.vx||0)*180/Math.PI; tryMove(ang+90*(Math.random()<0.5?1:-1)); return; }

  if(!enemies||!enemies.length) return;
  // 최근접 목표 선정
  var tgt=null, bd=1e9; for(var i=0;i<enemies.length;i++){ var d=dist(tank,enemies[i]); if(d<bd){bd=d; tgt=enemies[i];}}

  // 목표 법선 방향으로 원운동
  var base = angleTo(tank.x,tank.y,tgt.x,tgt.y);
  var dir = (tank._fl_dir = (tank._fl_dir || (Math.random()<0.5?1:-1)) );
  var desired = base + dir*orbit;

  // 반경 조절로 벽/충돌 회피(주기적 내/외 반경 스윕)
  var t = (tank._fl_t||0)+1; tank._fl_t=t;
  var rAim = radius + (Math.sin(t*0.1)*0.5+0.5)*radiusJitter; // 0..radiusJitter
  var d = bd;
  if (d < rAim*0.8) desired = base + 180 + dir*(orbit*0.5);
  else if (d > rAim*1.2) desired = base + dir*(orbit*0.8);
  desired += (Math.random()*6-3);

  tryMove(desired);

  // 연속 사격(틈새 노림)
  if (t % (P.fire_every??5) === 0){
    var aim=leadAngle(tank,tgt,bulletSpeed);
    tank.fire(aim + (Math.random()*2-1));
  }
}



// ===== 다음 로봇 =====


// Normal Interceptor — 탄 차단 회피, 반격 및 리드샷
function name(){ return 'Normal Interceptor'; }
function type(){ try { return Type.NORMAL; } catch(e){ return 1; } }

function update(tank, enemies, allies, bulletInfo){
  function dist(a,b){var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function tryMove(a){ for(var i=0;i<10;i++){ var off=(i%2===0?1:-1)*Math.ceil(i/2)*15; tank.move(a+off);} }
  function leadAngle(src,dst,bs){
    var rx=dst.x-src.x, ry=dst.y-src.y; var dvx=dst.vx||0, dvy=dst.vy||0;
    var a=dvx*dvx+dvy*dvy-bs*bs, b=2*(rx*dvx+ry*dvy), c=rx*rx+ry*ry; var t;
    if(Math.abs(a)<1e-6){ t=(c>1e-6)?(-c/b):0; } else { var disc=b*b-4*a*c; if(disc<0)disc=0; var t1=(-b+Math.sqrt(disc))/(2*a); var t2=(-b-Math.sqrt(disc))/(2*a); t=Math.max(t1,t2);} if(!isFinite(t)||t<0) t=0;
    return angleTo(src.x,src.y, dst.x+(dst.vx||0)*t, dst.y+(dst.vy||0)*t);
  }

  var P=(typeof PARAMS!=='undefined')?PARAMS:{};
  var bulletSpeed = P.bulletSpeed ?? 400;

  // 위협 점수 = 접근속도·역거리 가중
  var threat=null, best=-1e9;
  for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){
    var b=bulletInfo[i]; var rx=tank.x-b.x, ry=tank.y-b.y; var d=Math.hypot(rx,ry)+1e-6; var rel=-(rx*(b.vx||0)+ry*(b.vy||0))/d; var sc=rel/d; if(sc>best){best=sc; threat=b;}
  }
  if(threat && best>0){
    var ang=Math.atan2(threat.vy||0, threat.vx||0)*180/Math.PI;
    tryMove(ang+90*(Math.random()<0.5?1:-1));
  } else if(enemies && enemies.length){
    // 여유 시 최근접 적에게 리드샷
    var tgt=null, bd=1e9; for(var i=0;i<enemies.length;i++){ var d=dist(tank,enemies[i]); if(d<bd){bd=d; tgt=enemies[i];}}
    if(tgt){
      var aim=leadAngle(tank,tgt,bulletSpeed);
      tank.fire(aim + (Math.random()*2-1));
      // 접근 각도로 작은 이동
      var moveAng=angleTo(tank.x,tank.y,tgt.x,tgt.y) + (Math.random()<0.5?10:-10);
      tryMove(moveAng);
    }
  }
}



// ===== 다음 로봇 =====


// Normal Support — 아군 중심 보호, 포커스 파이어 동조, 중거리 유지
function name(){ return 'Normal Support'; }
function type(){ try { return Type.NORMAL; } catch(e){ return 1; } }

function update(tank, enemies, allies, bulletInfo){
  function dist(a,b){var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function tryMove(a){ for(var i=0;i<10;i++){ var off=(i%2===0?1:-1)*Math.ceil(i/2)*12; tank.move(a+off);} }
  function leadAngle(src,dst,bs){
    var rx=dst.x-src.x, ry=dst.y-src.y; var dvx=dst.vx||0, dvy=dst.vy||0;
    var a=dvx*dvx+dvy*dvy-bs*bs, b=2*(rx*dvx+ry*dvy), c=rx*rx+ry*ry; var t;
    if(Math.abs(a)<1e-6){ t=(c>1e-6)?(-c/b):0; } else { var disc=b*b-4*a*c; if(disc<0)disc=0; var t1=(-b+Math.sqrt(disc))/(2*a); var t2=(-b-Math.sqrt(disc))/(2*a); t=Math.max(t1,t2);} if(!isFinite(t)||t<0) t=0;
    return angleTo(src.x,src.y, dst.x+(dst.vx||0)*t, dst.y+(dst.vy||0)*t);
  }
  function alliesCenter(){ if(!allies||allies.length===0) return {x:tank.x,y:tank.y}; var sx=0,sy=0; for(var i=0;i<allies.length;i++){sx+=allies[i].x;sy+=allies[i].y;} return {x:sx/allies.length, y:sy/allies.length}; }

  var P=(typeof PARAMS!=='undefined')?PARAMS:{};
  var midRange = P.ideal_range ?? 220;
  var bulletSpeed = P.bulletSpeed ?? 400;

  // 공동 타겟 선정: 아군 중심과 가장 가까운 적
  var center = alliesCenter();
  var focus=null, bd=1e9; if(enemies){ for(var i=0;i<enemies.length;i++){ var d=dist(center,enemies[i]); if(d<bd){bd=d; focus=enemies[i];} } }
  if(!focus && enemies && enemies.length) focus=enemies[0];

  // 탄 회피 우선
  var threat=null, best=-1e9; for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){ var b=bulletInfo[i]; var rx=tank.x-b.x, ry=tank.y-b.y; var d=Math.hypot(rx,ry)+1e-6; var rel=-(rx*(b.vx||0)+ry*(b.vy||0))/d; var sc=rel/d; if(sc>best){best=sc; threat=b;} }
  if(threat && best>0){ var ang=Math.atan2(threat.vy||0, threat.vx||0)*180/Math.PI; tryMove(ang+90*(Math.random()<0.5?1:-1)); return; }

  if(focus){
    var d = dist(tank, focus);
    var base = angleTo(tank.x,tank.y, focus.x, focus.y);
    var moveAng = (d>midRange? base : base+180) + (Math.random()<0.5?8:-8);
    tryMove(moveAng);
    // 동조 사격
    var aim = leadAngle(tank, focus, bulletSpeed);
    if((tank._ns_t=(tank._ns_t||0)+1) % (P.fire_every??5)===0){ tank.fire(aim + (Math.random()*2-1)); }
  }
}



// ===== 다음 로봇 =====


// Tanker Bruiser — 전면 압박, 벽-슬라이딩, 지속 사격, 지그재그
function name(){ return 'Tanker Bruiser'; }
function type(){ try { return Type.TANKER; } catch(e){ return 2; } }

function update(tank, enemies, allies, bulletInfo){
  function dist(a,b){var dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function tryMove(a){ for(var i=0;i<10;i++){ var off=(i%2===0?1:-1)*Math.ceil(i/2)*10; tank.move(a+off);} }
  function leadAngle(src,dst,bs){
    var rx=dst.x-src.x, ry=dst.y-src.y; var dvx=dst.vx||0, dvy=dst.vy||0;
    var a=dvx*dvx+dvy*dvy-bs*bs, b=2*(rx*dvx+ry*dvy), c=rx*rx+ry*ry; var t;
    if(Math.abs(a)<1e-6){ t=(c>1e-6)?(-c/b):0; } else { var disc=b*b-4*a*c; if(disc<0)disc=0; var t1=(-b+Math.sqrt(disc))/(2*a); var t2=(-b-Math.sqrt(disc))/(2*a); t=Math.max(t1,t2);} if(!isFinite(t)||t<0) t=0;
    return angleTo(src.x,src.y, dst.x+(dst.vx||0)*t, dst.y+(dst.vy||0)*t);
  }

  var P=(typeof PARAMS!=='undefined')?PARAMS:{};
  var engageRange = P.ideal_range ?? 180;
  var strafe = P.strafe_deg ?? 18;
  var bulletSpeed = P.bulletSpeed ?? 400;

  // 위협 탄 회피는 짧고 빈도 낮게: 전면 압박 유지
  var threat=null, s=-1e9; for(var i=0;i<(bulletInfo?bulletInfo.length:0);i++){ var b=bulletInfo[i]; var rx=tank.x-b.x, ry=tank.y-b.y; var d=Math.hypot(rx,ry)+1e-6; var rel=-(rx*(b.vx||0)+ry*(b.vy||0))/d; var sc=rel/d; if(sc>s){s=sc; threat=b;} }
  if(threat && s>0 && (tank._br_t||0)%7===0){ var ang=Math.atan2(threat.vy||0, threat.vx||0)*180/Math.PI; tryMove(ang+90*(Math.random()<0.5?1:-1)); }

  if(!enemies||!enemies.length) return;
  // 목표: 최근접 적에게 압박
  var tgt=null, bd=1e9; for(var i=0;i<enemies.length;i++){ var d=dist(tank,enemies[i]); if(d<bd){bd=d; tgt=enemies[i];}}
  var base=angleTo(tank.x,tank.y,tgt.x,tgt.y);
  var t=(tank._br_t||0)+1; tank._br_t=t;
  // 벽-슬라이딩 힌트: 화면 가장자리 근처면 평행 이동 가중(가볍게 ±20°)
  var slide=0; var margin = (tank.size||16)*2;
  if(tank.x < margin) slide = 20; else if(tank.x > 800-margin) slide = -20;
  if(tank.y < margin) slide += 20; else if(tank.y > 600-margin) slide -= 20;
  var zig = (Math.sin(t*0.25)>0?1:-1) * strafe;
  var moveAng = base + slide + zig + (bd>engageRange?0:180);
  tryMove(moveAng);

  // 지속 사격
  if(t % (P.fire_every??4) === 0){ var aim=leadAngle(tank,tgt,bulletSpeed); tank.fire(aim + (Math.random()*2-1)); }
}

