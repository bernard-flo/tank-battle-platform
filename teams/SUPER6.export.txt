// Tanker Guardian v1 — 선두 방패/팀 중심 유지/보스턴 회피/짧은 리드샷
function name() { return 'Tanker Guardian'; }
function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function dist(ax, ay, bx, by) { const dx = bx-ax, dy = by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function normAngle(a){ while(a>180)a-=360; while(a<-180)a+=360; return a; }
  function tryMove(angleDeg) {
    // 실패 시 ±15°씩 보정 재시도 (최대 10회 내)
    const step = 15;
    for (let i=0;i<10;i++) {
      const offs = ((i>>1)+1) * step * (i%2===0?1:-1);
      const ang = angleDeg + (i===0?0:offs);
      if (tank.move(ang)) return true;
    }
    return false;
  }
  function mostCentralEnemyScore(e){
    // 중앙 근접 가중(450,300)
    const dCenter = dist(e.x, e.y, 450, 300);
    return -dCenter;
  }
  function pickTarget() {
    if (enemies.length===0) return null;
    let best = enemies[0];
    function score(e){
      const d = dist(tank.x, tank.y, e.x, e.y);
      return -d + (1000 - e.health)*0.001 + mostCentralEnemyScore(e)*0.0005;
    }
    for (const e of enemies) if (score(e)>score(best)) best = e;
    return best;
  }
  function leadAngle(src, dst, bulletSpeed){
    // 적 속도 불명 → 짧은 리드: 목표각에 소량 랜덤 오프셋
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    const jitter = (Math.random()*2-1)*4; // ±4도
    return base + jitter;
  }
  function evadeFromBullets(){
    if (!bulletInfo || bulletInfo.length===0) return false;
    // 위협 점수: 접근속도 * 역거리
    let best=null, bestScore=-1e9;
    for (const b of bulletInfo){
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const r = Math.hypot(rx, ry)+1e-6;
      const vdot = (b.vx*rx + b.vy*ry) / r; // >0이면 접근
      const score = vdot / r;
      if (score>bestScore){ best=b; bestScore=score; }
    }
    if (!best) return false;
    // 탄 속도 벡터에 수직(±90°)으로 이동, 더 멀어지는 쪽 선택
    const bang = Math.atan2(best.vy, best.vx)*180/Math.PI;
    const a1 = bang + 90, a2 = bang - 90;
    const d1x = Math.cos(a1*Math.PI/180), d1y = Math.sin(a1*Math.PI/180);
    const d2x = Math.cos(a2*Math.PI/180), d2y = Math.sin(a2*Math.PI/180);
    const s1 = d1x*(tank.x-best.x) + d1y*(tank.y-best.y);
    const s2 = d2x*(tank.x-best.x) + d2y*(tank.y-best.y);
    const ang = (s1>s2)?a1:a2;
    return tryMove(ang);
  }

  // ===== 메인 로직 =====
  // 1) 탄 회피 우선
  if (evadeFromBullets()) {
    // 회피 중에도 근접 시 사격
    const tgt = pickTarget();
    if (tgt) tank.fire(leadAngle(tank, tgt, 8));
    return;
  }

  // 2) 팀 중심 유지(선두 방패)
  let cx = tank.x, cy = tank.y;
  if (allies && allies.length>0){
    cx = allies.reduce((s,a)=>s+a.x, 0)/allies.length;
    cy = allies.reduce((s,a)=>s+a.y, 0)/allies.length;
  }
  // 팀 중심과 필드 중심 사이 근방에 위치하도록 약하게 끌림
  const gx = (cx*2 + 450)/3, gy = (cy*2 + 300)/3;

  const target = pickTarget();
  if (target){
    // 근접 위협 각도 제어: 보스턴/각도 조절(짧은 오프셋)
    const desired = angleTo(tank.x, tank.y, target.x, target.y);
    const offset = (Math.random()<0.5? -10: 10);
    tryMove(desired + offset);
    tank.fire(leadAngle(tank, target, 8));
  } else {
    // 타겟 없으면 팀 중심 쪽으로 위치 교정
    const ang = angleTo(tank.x, tank.y, gx, gy);
    tryMove(ang);
  }
}



// ===== 다음 로봇 =====


// Dealer Sniper v1 — 장거리 정밀 사격/카이팅/탄 회피 우선
function name() { return 'Dealer Sniper'; }
function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function dist(ax, ay, bx, by) { const dx = bx-ax, dy = by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function tryMove(angleDeg) {
    const step = 15;
    for (let i=0;i<10;i++){
      const offs = ((i>>1)+1)*step*(i%2===0?1:-1);
      const ang = angleDeg + (i===0?0:offs);
      if (tank.move(ang)) return true;
    }
    return false;
  }
  function pickTarget() {
    if (enemies.length===0) return null;
    // 가장 체력 낮은 적 우선, 동일하면 가까운 순
    return enemies.slice().sort((a,b)=> (a.health-b.health) || (dist(tank.x,tank.y,a.x,a.y)-dist(tank.x,tank.y,b.x,b.y)))[0];
  }
  function leadAngle(src, dst){
    // 평균 속도 기반 근사 → 제공 정보 제한으로 짧은 리드 + 원거리 보정
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    const d = dist(src.x, src.y, dst.x, dst.y);
    const bias = clamp((d-250)/300, 0, 1) * (Math.random()<0.5?-6:6); // 원거리일수록 ±6도까지
    return base + bias;
  }
  function evade(){
    if (!bulletInfo || bulletInfo.length===0) return false;
    let best=null, bestScore=-1e9;
    for (const b of bulletInfo){
      const rx = tank.x - b.x, ry = tank.y - b.y; const r=Math.hypot(rx,ry)+1e-6;
      const vdot = (b.vx*rx + b.vy*ry) / r; // 접근 속도
      const score = vdot / r;
      if (score>bestScore){ best=b; bestScore=score; }
    }
    if (!best) return false;
    const bang = Math.atan2(best.vy, best.vx)*180/Math.PI;
    const a1 = bang + 90, a2 = bang - 90;
    // 더 멀어지는 쪽 선택
    const s = (ang)=>{
      const rad=ang*Math.PI/180; const dx=Math.cos(rad), dy=Math.sin(rad);
      return dx*(tank.x-best.x)+dy*(tank.y-best.y);
    };
    return tryMove(s(a1)>s(a2)?a1:a2);
  }

  // ===== 로직 =====
  if (evade()) { const t=pickTarget(); if (t) tank.fire(leadAngle(tank,t)); return; }

  const target = pickTarget();
  if (!target) return;

  // 장거리 유지(카이팅): 이상 거리 320~420 유지 (난수화)
  const ideal = 370 + (Math.random()*2-1)*50;
  const d = dist(tank.x, tank.y, target.x, target.y);
  const toEnemy = angleTo(tank.x, tank.y, target.x, target.y);
  if (d < ideal*0.85) {
    // 너무 가까우면 반대 방향으로 이탈
    tryMove(toEnemy + 180 + (Math.random()<0.5?-20:20));
  } else if (d > ideal*1.2) {
    // 너무 멀면 접근하되, 옆으로 약간 오비트
    tryMove(toEnemy + (Math.random()<0.5?15:-15));
  } else {
    // 원 궤도 유지 — 넓은 반경 오비트
    tryMove(toEnemy + (Math.random()<0.5?90:-90));
  }

  // 사격 쿨은 엔진에서 처리, 여기선 각 프레임 기회시 정밀 발사 시도
  tank.fire(leadAngle(tank, target));
}



// ===== 다음 로봇 =====


// Dealer Flanker v1 — 측후방 진입/원운동 오비트/주기적 반경 조절
function name() { return 'Dealer Flanker'; }
function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function dist(ax, ay, bx, by) { const dx = bx-ax, dy = by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function tryMove(angleDeg) {
    const step = 15;
    for (let i=0;i<10;i++){
      const offs=((i>>1)+1)*step*(i%2===0?1:-1);
      const ang = angleDeg + (i===0?0:offs);
      if (tank.move(ang)) return true;
    }
    return false;
  }
  function pickTarget(){
    if (enemies.length===0) return null;
    // 가까움 우선 → 체력 낮음
    return enemies.slice().sort((a,b)=>{
      const da = dist(tank.x,tank.y,a.x,a.y), db=dist(tank.x,tank.y,b.x,b.y);
      return (da-db) || (a.health-b.health);
    })[0];
  }
  function leadAngle(src, dst){
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    const jitter = (Math.random()*2-1)*5;
    return base + jitter;
  }
  function evade(){
    if (!bulletInfo || bulletInfo.length===0) return false;
    let best=null, bestScore=-1e9;
    for (const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const r=Math.hypot(rx,ry)+1e-6;
      const vdot=(b.vx*rx+b.vy*ry)/r; const score=vdot/r;
      if (score>bestScore){ best=b; bestScore=score; }
    }
    if (!best) return false;
    const bang=Math.atan2(best.vy,best.vx)*180/Math.PI;
    const a1=bang+90,a2=bang-90;
    const s=(ang)=>{const rad=ang*Math.PI/180;return Math.cos(rad)*(tank.x-best.x)+Math.sin(rad)*(tank.y-best.y);};
    return tryMove(s(a1)>s(a2)?a1:a2);
  }

  // ===== 로직 =====
  if (evade()) { const t=pickTarget(); if (t) tank.fire(leadAngle(tank,t)); return; }
  const target = pickTarget();
  if (!target) return;

  // 원운동: 타겟 법선(±90°)으로 오비트, 주기적으로 반경 가감
  const toEnemy = angleTo(tank.x, tank.y, target.x, target.y);
  const orbitDir = (Math.random()<0.5? -90: 90);
  let ang = toEnemy + orbitDir;
  const d = dist(tank.x, tank.y, target.x, target.y);
  if (d < 220) ang += 20; // 반경 증가
  if (d > 380) ang -= 20; // 반경 감소
  tryMove(ang);

  tank.fire(leadAngle(tank, target));
}



// ===== 다음 로봇 =====


// Normal Interceptor v1 — 탄 차단 회피/반격, 위협 점수 기반 수직 회피
function name() { return 'Normal Interceptor'; }
function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function dist(ax, ay, bx, by) { const dx = bx-ax, dy = by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function tryMove(angleDeg){
    const step=15;
    for(let i=0;i<10;i++){
      const offs=((i>>1)+1)*step*(i%2===0?1:-1);
      const ang = angleDeg + (i===0?0:offs);
      if (tank.move(ang)) return true;
    }
    return false;
  }
  function pickNearest(){
    if (enemies.length===0) return null;
    let best=enemies[0], bd=dist(tank.x,tank.y,best.x,best.y);
    for(const e of enemies){ const d=dist(tank.x,tank.y,e.x,e.y); if(d<bd){bd=d;best=e;} }
    return best;
  }
  function leadAngle(src, dst){
    // 간단한 리드: 근거리일수록 작은 오프셋
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    const d = dist(src.x, src.y, dst.x, dst.y);
    const jitter = Math.max(0, 6 - d*0.01) * (Math.random()<0.5?-1:1);
    return base + jitter;
  }
  function evade(){
    if (!bulletInfo || bulletInfo.length===0) return false;
    let best=null, bestScore=-1e9;
    for (const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const r=Math.hypot(rx,ry)+1e-6;
      const vdot=(b.vx*rx+b.vy*ry)/r; // 접근 양수
      const score = vdot / r; // 역거리 가중
      if (score>bestScore){ best=b; bestScore=score; }
    }
    if (!best) return false;
    const bang=Math.atan2(best.vy,best.vx)*180/Math.PI;
    const a1=bang+90,a2=bang-90;
    const s=(ang)=>{const rad=ang*Math.PI/180;return Math.cos(rad)*(tank.x-best.x)+Math.sin(rad)*(tank.y-best.y);};
    return tryMove(s(a1)>s(a2)?a1:a2);
  }

  // ===== 로직 =====
  if (evade()) { const t=pickNearest(); if (t) tank.fire(leadAngle(tank,t)); return; }
  const t = pickNearest();
  if (!t) return;
  // 여유 시 접근하며 사격
  const to = angleTo(tank.x, tank.y, t.x, t.y);
  tryMove(to);
  tank.fire(leadAngle(tank, t));
}



// ===== 다음 로봇 =====


// Normal Support v1 — 아군 보호/중거리 유지/포커스 파이어 동조
function name() { return 'Normal Support'; }
function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function dist(ax, ay, bx, by) { const dx = bx-ax, dy = by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function tryMove(angleDeg){
    const step=15;
    for(let i=0;i<10;i++){
      const offs=((i>>1)+1)*step*(i%2===0?1:-1);
      const ang=angleDeg+(i===0?0:offs);
      if (tank.move(ang)) return true;
    }
    return false;
  }
  function pickCommonTarget(){
    if (enemies.length===0) return null;
    // 공통 규칙: 가까움 → 체력 낮음 → 중앙 근접
    function score(e){
      const d = dist(tank.x,tank.y,e.x,e.y);
      const dC = dist(e.x,e.y,450,300);
      return -d + (1000-e.health)*0.001 - dC*0.0005;
    }
    let best=enemies[0];
    for(const e of enemies){ if (score(e)>score(best)) best=e; }
    return best;
  }
  function leadAngle(src, dst){
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    const jitter = (Math.random()*2-1)*4;
    return base + jitter;
  }
  function centerAllies(){
    if (!allies || allies.length===0) return {x:tank.x,y:tank.y};
    return { x: allies.reduce((s,a)=>s+a.x,0)/allies.length,
             y: allies.reduce((s,a)=>s+a.y,0)/allies.length };
  }
  function evade(){
    if (!bulletInfo || bulletInfo.length===0) return false;
    let best=null, bestScore=-1e9;
    for(const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const r=Math.hypot(rx,ry)+1e-6;
      const vdot=(b.vx*rx+b.vy*ry)/r; const score=vdot/r;
      if(score>bestScore){best=b;bestScore=score;}
    }
    if(!best) return false;
    const bang=Math.atan2(best.vy,best.vx)*180/Math.PI;
    const a1=bang+90,a2=bang-90;
    const s=(ang)=>{const rad=ang*Math.PI/180;return Math.cos(rad)*(tank.x-best.x)+Math.sin(rad)*(tank.y-best.y);};
    return tryMove(s(a1)>s(a2)?a1:a2);
  }

  // ===== 로직 =====
  if (evade()) { const tgt=pickCommonTarget(); if (tgt) tank.fire(leadAngle(tank,tgt)); return; }

  const center = centerAllies();
  const tgt = pickCommonTarget();
  if (!tgt) return;

  // 아군 중심 근처에서 중거리 유지(260~340)
  const toCenter = angleTo(tank.x, tank.y, center.x, center.y);
  const toEnemy = angleTo(tank.x, tank.y, tgt.x, tgt.y);
  const d = dist(tank.x, tank.y, tgt.x, tgt.y);
  if (d < 240) {
    tryMove(toEnemy + 180 + (Math.random()<0.5?-25:25));
  } else if (d > 360) {
    tryMove(toEnemy + (Math.random()<0.5?10:-10));
  } else {
    // 중심을 끼고 각도 정렬 유지
    tryMove((toCenter*0.3 + toEnemy*0.7));
  }

  tank.fire(leadAngle(tank, tgt));
}



// ===== 다음 로봇 =====


// Tanker Bruiser v1 — 전면 압박/벽-슬라이딩/지그재그 예측 회피
function name() { return 'Tanker Bruiser'; }
function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  function dist(ax, ay, bx, by) { const dx=bx-ax, dy=by-ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function tryMove(angleDeg){
    const step=15;
    for(let i=0;i<10;i++){
      const offs=((i>>1)+1)*step*(i%2===0?1:-1);
      const ang=angleDeg+(i===0?0:offs);
      if(tank.move(ang)) return true;
    }
    return false;
  }
  function pickClosest(){
    if (enemies.length===0) return null;
    let best=enemies[0], bd=dist(tank.x,tank.y,best.x,best.y);
    for(const e of enemies){const d=dist(tank.x,tank.y,e.x,e.y); if(d<bd){bd=d;best=e;}}
    return best;
  }
  function leadAngle(src, dst){
    const base = angleTo(src.x, src.y, dst.x, dst.y);
    return base + ((Math.random()<0.5)?-3:3);
  }
  function evade(){
    if(!bulletInfo||bulletInfo.length===0) return false;
    let best=null,bestScore=-1e9;
    for(const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const r=Math.hypot(rx,ry)+1e-6;
      const vdot=(b.vx*rx+b.vy*ry)/r; const score=vdot/r;
      if(score>bestScore){best=b;bestScore=score;}
    }
    if(!best) return false;
    const bang=Math.atan2(best.vy,best.vx)*180/Math.PI;
    const a1=bang+90,a2=bang-90;
    const s=(ang)=>{const rad=ang*Math.PI/180;return Math.cos(rad)*(tank.x-best.x)+Math.sin(rad)*(tank.y-best.y);};
    return tryMove(s(a1)>s(a2)?a1:a2);
  }

  // ===== 로직 =====
  if (evade()) { const t=pickClosest(); if (t) tank.fire(leadAngle(tank,t)); return; }
  const t = pickClosest(); if (!t) return;

  // 전면 압박 + 지그재그
  const to = angleTo(tank.x,tank.y,t.x,t.y);
  const strafe = (Math.random()<0.5? -20: 20);
  let ang = to + strafe;

  // 벽-슬라이딩: 벽 근처면 평행 이동
  const margin = 40 + tank.size/2;
  if (tank.x < margin) ang = 0 + (Math.random()<0.5? 10:-10);
  else if (tank.x > 900 - margin) ang = 180 + (Math.random()<0.5? 10:-10);
  if (tank.y < margin) ang = 90 + (Math.random()<0.5? 10:-10);
  else if (tank.y > 600 - margin) ang = 270 + (Math.random()<0.5? 10:-10);

  tryMove(ang);
  tank.fire(leadAngle(tank, t));
}

