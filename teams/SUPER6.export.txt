// Tanker Guardian — 선두 방패, 팀 중심 유지, 근접 위협 제어

// Dealer Sniper — 장거리 정밀 사격, 카이팅, 회피 우선

// Dealer Flanker — 측후방 진입, 원운동 오비트, 연속 사격

// Normal Interceptor — 탄 위협 차단 회피 후 반격

// Normal Support — 아군 보호, 포커스 파이어 동조, 중거리 유지

// Tanker Bruiser — 전면 압박, 벽-슬라이딩, 지그재그 예측 회피
// 유틸리티 (파일 내부 전용)

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }

function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }

function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }

function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
// ===== 다음 로봇 =====
function dist(ax, ay, bx, by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }
// ===== 다음 로봇 =====
function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }
// ===== 다음 로봇 =====
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }
// ===== 다음 로봇 =====
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }
// ===== 다음 로봇 =====
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }
function dist(ax, ay, bx, by) { const dx = bx - ax, dy = by - ay; return Math.hypot(dx, dy); }

function angleTo(ax, ay, bx, by){ return Math.atan2(by-ay, bx-ax); }

function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax); }

function safeLead(src, dst, bulletSpeed){

function safeLead(src, dst, bulletSpeed){

function safeLead(src, dst, bulletSpeed){
function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax); }

function safeLead(src, dst, bulletSpeed){

function safeLead(src, dst, bulletSpeed){

  const rx=dst.x-src.x, ry=dst.y-src.y; const vx=dst.vx||0, vy=dst.vy||0;

  const rx=dst.x-src.x, ry=dst.y-src.y; const vx=dst.vx||0, vy=dst.vy||0;

  const rx=dst.x-src.x, ry=dst.y-src.y; const vx=dst.vx||0, vy=dst.vy||0;
function norm(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }

  const rx = dst.x - src.x, ry = dst.y - src.y;

  const rx=dst.x-src.x, ry=dst.y-src.y; const vx=dst.vx||0, vy=dst.vy||0;

  const a=vx*vx+vy*vy-bulletSpeed*bulletSpeed, b=2*(rx*vx+ry*vy), c=rx*rx+ry*ry;

  const a=vx*vx+vy*vy-bulletSpeed*bulletSpeed, b=2*(rx*vx+ry*vy), c=rx*rx+ry*ry; let t=0;

  const a=vx*vx+vy*vy-bulletSpeed*bulletSpeed, b=2*(rx*vx+ry*vy), c=rx*rx+ry*ry; let t=0;
function leadAngle(src, dst, bulletSpeed){

  const vx = dst.vx||0, vy = dst.vy||0;

  const a=vx*vx+vy*vy-bulletSpeed*bulletSpeed, b=2*(rx*vx+ry*vy), c=rx*rx+ry*ry;

  let t=0; if (Math.abs(a)<1e-6){ if(Math.abs(b)>1e-6) t=-c/b; }

  if (Math.abs(a)<1e-6){ if(Math.abs(b)>1e-6) t=-c/b; }

  if (Math.abs(a)<1e-6){ if(Math.abs(b)>1e-6) t=-c/b; }
  const rx = dst.x - src.x, ry = dst.y - src.y;

  const a = vx*vx + vy*vy - bulletSpeed*bulletSpeed;

  let t=0; if (Math.abs(a)<1e-6){ if(Math.abs(b)>1e-6) t=-c/b; }

  else { const disc=b*b-4*a*c; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a); t=Math.min(t1,t2)>0?Math.min(t1,t2):Math.max(t1,t2); if(!isFinite(t)||t<0) t=0; }}

  else { const disc=b*b-4*a*c; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a); t=Math.min(t1,t2)>0?Math.min(t1,t2):Math.max(t1,t2); if(!isFinite(t)||t<0) t=0; }}

  else { const disc=b*b-4*a*c; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a); t=Math.min(t1,t2)>0?Math.min(t1,t2):Math.max(t1,t2); if(!isFinite(t)||t<0) t=0; }}
  const vx = dst.vx||0, vy = dst.vy||0;

  const b = 2*(rx*vx + ry*vy);

  else { const disc=b*b-4*a*c; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a); t=Math.min(t1,t2)>0?Math.min(t1,t2):Math.max(t1,t2); if(!isFinite(t)||t<0) t=0; } }

  const axp=dst.x+(dst.vx||0)*t, ayp=dst.y+(dst.vy||0)*t; return Math.atan2(ayp-src.y, axp-src.x);

  const axp=dst.x+(dst.vx||0)*t, ayp=dst.y+(dst.vy||0)*t; return Math.atan2(ayp-src.y, axp-src.x);

  const axp=dst.x+(dst.vx||0)*t, ayp=dst.y+(dst.vy||0)*t; return Math.atan2(ayp-src.y, axp-src.x);
  const a = vx*vx + vy*vy - bulletSpeed*bulletSpeed;

  const c = rx*rx + ry*ry;

  const axp=dst.x+vx*t, ayp=dst.y+vy*t; return Math.atan2(ayp-src.y, axp-src.x);

}

}

}
  const b = 2*(rx*vx + ry*vy);

  let t=0;

}

function pickTarget(tank, enemies){

function pickCommonTarget(allies, enemies){

function pickPressureTarget(tank, enemies){
  const c = rx*rx + ry*ry;

  if (Math.abs(a) < 1e-6){ if (Math.abs(b)>1e-6) t = -c/b; }

function pickTarget(tank,enemies){

  let best=null, score=1e9; for(const e of enemies||[]){ const d=dist(tank.x,tank.y,e.x,e.y); const s=d*0.6+(e.hp||100)*0.4+Math.hypot(e.x-400,e.y-300)*0.1; if(s<score){score=s;best=e;} } return best;

  // 아군이 이미 조준 중인 가장 가까운 대상 추정: allies의 aim(추정 불가 시 거리/체력 기준)

  let best=null, score=1e9; for(const e of enemies||[]){ const d=dist(tank.x,tank.y,e.x,e.y); const s=d*0.7 + (e.hp||100)*0.3; if(s<score){score=s;best=e;} } return best;
  let t;

  else {

  let best=null,score=1e9; for(const e of enemies||[]){ const d=dist(tank.x,tank.y,e.x,e.y); const s=d*0.6+(e.hp||100)*0.4; if(s<score){score=s;best=e;} } return best;

}

  let best=null, score=1e9;

}
  if (Math.abs(a) < 1e-6) {

    const disc = b*b - 4*a*c;

}

function mostThreatBullet(tank, bullets){

  for(const e of enemies||[]){ const d=Math.hypot(e.x-400, e.y-300); const s=(e.hp||100)*0.7 + d*0.3; if (s<score){score=s; best=e;} }


    t = -c / b; // linear

    if (disc>=0){ const s=Math.sqrt(disc); const t1=(-b+s)/(2*a), t2=(-b-s)/(2*a); t = Math.min(t1,t2)>0?Math.min(t1,t2):Math.max(t1,t2); if(!isFinite(t)||t<0) t=0; }



  let best=null, bestScore=-Infinity;

  return best;

function name(){ return 'Tanker Bruiser'; }
  } else {

  }

function name(){ return 'Dealer Flanker'; }

  for(const b of bullets||[]){

}

function type(){ return Type.TANKER; }
    const disc = b*b - 4*a*c;

  const aimX = dst.x + (dst.vx||0)*t;

function type(){ return Type.DEALER; }

    const d=dist(tank.x,tank.y,b.x,b.y)+1e-3;




    if (disc < 0) return Math.atan2(ry, rx);

  const aimY = dst.y + (dst.vy||0)*t;



    const toMeX=tank.x-b.x, toMeY=tank.y-b.y;

function name(){ return 'Normal Support'; }

function update(tank, enemies, allies, bulletInfo){
    const t1 = (-b + Math.sqrt(disc)) / (2*a);

  return Math.atan2(aimY - src.y, aimX - src.x);

function update(tank, enemies, allies, bulletInfo){

    const approach=((b.vx||0)*toMeX+(b.vy||0)*toMeY)/d;

function type(){ return Type.NORMAL; }

  const BULLET_SPEED=400; const jitter=(Math.random()-0.5)*0.08;
    const t2 = (-b - Math.sqrt(disc)) / (2*a);

}

  const BULLET_SPEED=400; const ORBIT_DIR = (tank.__orbitDir = tank.__orbitDir || (Math.random()<0.5?1:-1));

    const score=approach/(d*d); // 역거리 가중 강화



  const tgt = pickPressureTarget(tank, enemies||[]);
    t = Math.min(t1, t2) > 0 ? Math.min(t1, t2) : Math.max(t1, t2);

function pickTargetSniper(tank, enemies){

  const IDEAL_R = 220; const MIN_R=160; const MAX_R=280;

    if(score>bestScore){ bestScore=score; best=b; }

function update(tank, enemies, allies, bulletInfo){

  // 지그재그 타이머
  }

  // 체력 낮음 우선, 그 다음 거리

  const jitter=(Math.random()-0.5)*0.08;

  }

  const BULLET_SPEED=400; const IDEAL_R=260; const MIN_R=200; const MAX_R=320; const jitter=(Math.random()-0.5)*0.06;

  if (!tank.__zig) tank.__zig = {dir: (Math.random()<0.5?1:-1), t: 30+Math.floor(Math.random()*30)};
  if (!isFinite(t) || t < 0) t = 0;

  let best=null, score=1e9;



  return best;

  // 1) 아군 최근접 보호: 가장 가까운 아군 기준 중심 유지

  tank.__zig.t -= 1; if (tank.__zig.t<=0){ tank.__zig.t = 30+Math.floor(Math.random()*30); tank.__zig.dir *= -1; }
  const aimX = dst.x + (dst.vx||0)*t;

  for(const e of enemies||[]){

  const tgt = pickTarget(tank, enemies||[]);

}

  let closestAlly=null, bestD=1e9; for(const a of allies||[]){ const d=dist(tank.x,tank.y,a.x,a.y); if(d<bestD){bestD=d; closestAlly=a;} }


  const aimY = dst.y + (dst.vy||0)*t;

    const d = dist(tank.x,tank.y,e.x,e.y);

  if (!tgt){ tank.move((Math.random()*2-1)*Math.PI); return; }



  let anchorX=400, anchorY=300; if (closestAlly){ anchorX=closestAlly.x; anchorY=closestAlly.y; }

  if (tgt){
  return Math.atan2(aimY - src.x2, aimX - src.x1); // fallback guard not used; correct below

    const hp = e.hp!=null? e.hp: 100;

  const d = dist(tank.x,tank.y,tgt.x,tgt.y);

function name(){ return 'Normal Interceptor'; }



    let base = angleTo(tank.x,tank.y,tgt.x,tgt.y);
}

    const s = hp*0.7 + d*0.3;

  // 원운동 각도: 타겟 법선(±90°)에 방사 보정

function type(){ return Type.NORMAL; }

  // 2) 공통 타겟 선정

    // 벽-슬라이딩 보정
// 안전한 리드샷 (간단 버전)

    if (s<score){ score=s; best=e; }

  let base = angleTo(tank.x,tank.y,tgt.x,tgt.y);



  const tgt = pickCommonTarget(allies, enemies||[]);

    const M=26; if (tank.x<M) base = 0; else if (tank.x>800-M) base=Math.PI; if (tank.y<M) base=Math.PI/2; else if (tank.y>600-M) base=-Math.PI/2;
function safeLead(src, dst, bulletSpeed){

  }

  let moveAng = base + ORBIT_DIR*Math.PI/2;

function update(tank, enemies, allies, bulletInfo){

  if (tgt){

    // 지그재그 측면 오프셋
  const rx = dst.x - src.x, ry = dst.y - src.y;

  return best;

  if (d < MIN_R) moveAng = base + ORBIT_DIR*(Math.PI/2 + 20*Math.PI/180);

  const BULLET_SPEED=400; const jitter=(Math.random()-0.5)*0.06;

    const d = dist(anchorX, anchorY, tgt.x, tgt.y);

    let moveAng = base + tank.__zig.dir * 20*Math.PI/180 + jitter;
  const vx = dst.vx||0, vy = dst.vy||0;

}

  if (d > MAX_R) moveAng = base + ORBIT_DIR*(Math.PI/2 - 20*Math.PI/180);

  // 1) 위협 탄 회피(수직 이동)

    let moveAng = angleTo(tank.x,tank.y, tgt.x, tgt.y);

    for(let i=0;i<10;i++){ if (tank.move(moveAng)) break; moveAng += ((i%2?1:-1) * 12*Math.PI/180); }
  const a = vx*vx + vy*vy - bulletSpeed*bulletSpeed;

function mostThreatBullet(tank, bullets){



  const b=mostThreatBullet(tank, bulletInfo);

    if (d < MIN_R) moveAng += Math.PI; // 거리 벌림

    const fireAng = safeLead(tank, tgt, BULLET_SPEED) + (Math.random()-0.5)*0.02; tank.fire(fireAng);
  const b = 2*(rx*vx + ry*vy);

  let best=null, bestScore=-Infinity;

  // 주기적 반전으로 예측 회피

  if (b){

    else if (d > MAX_R) moveAng += 0; // 접근

  } else {
  const c = rx*rx + ry*ry;

  for(const b of bullets||[]){

  if (!tank.__flipTimer) tank.__flipTimer = 60 + Math.floor(Math.random()*60);

    let ang=Math.atan2(b.vy||0, b.vx||0) + (Math.random()<0.5?1:-1)*Math.PI/2 + jitter;

    else moveAng += (Math.random()<0.5?1:-1)*60*Math.PI/180; // 측방 유지

    // 타겟 없을 때 중앙으로 압박
  let t = 0;

    const d = dist(tank.x,tank.y,b.x,b.y)+1e-3;

  tank.__flipTimer -= 1;

    for(let i=0;i<10;i++){ if (tank.move(ang)) break; ang += ((i%2?1:-1)*15*Math.PI/180); }

    moveAng += jitter;

    let ang = angleTo(tank.x,tank.y,400,300) + tank.__zig.dir*20*Math.PI/180 + jitter;
  if (Math.abs(a) < 1e-6) {

    const toMeX = tank.x - b.x, toMeY = tank.y - b.y;

  if (tank.__flipTimer<=0){ tank.__flipTimer = 60 + Math.floor(Math.random()*60); tank.__orbitDir *= -1; }

  }

    for(let i=0;i<10;i++){ if (tank.move(moveAng)) break; moveAng += ((i%2?1:-1)*12*Math.PI/180); }

    for(let i=0;i<10;i++){ if (tank.move(ang)) break; ang += ((i%2?1:-1) * 12*Math.PI/180); }
    if (Math.abs(b) > 1e-6) t = -c / b; else t = 0;

    const approach = ((b.vx||0)*toMeX + (b.vy||0)*toMeY)/d;

  moveAng += jitter;





  }
  } else {

    const score = approach / d;



  // 2) 반격: 여유 시 최근접 적 리드샷

    const fireAng = safeLead(tank, tgt, BULLET_SPEED) + (Math.random()-0.5)*0.02;

}
    const disc = b*b - 4*a*c;

    if (score>bestScore){ bestScore=score; best=b; }

  // 벽 회피: 벽 평행 이동으로 보정

  const tgt=pickTarget(tank, enemies||[]);

    tank.fire(fireAng);


    if (disc >= 0) {

  }

  const M=28; if (tank.x<M) moveAng = 0; else if (tank.x>800-M) moveAng = Math.PI;

  if (tgt){ const a=safeLead(tank,tgt,BULLET_SPEED) + (Math.random()-0.5)*0.02; tank.fire(a); }

  } else {


      const s = Math.sqrt(disc);

  return best;

  if (tank.y<M) moveAng = Math.PI/2; else if (tank.y>600-M) moveAng = -Math.PI/2;

}

    // 타겟 없으면 아군 근처 순찰


      const t1 = (-b + s) / (2*a);

}





    let ang = angleTo(tank.x,tank.y, anchorX, anchorY) + (Math.random()<0.5?1:-1)*Math.PI/2 + jitter;


      const t2 = (-b - s) / (2*a);



  for(let i=0;i<10;i++){ if (tank.move(moveAng)) break; moveAng += ((i%2?1:-1) * 12*Math.PI/180); }



    for(let i=0;i<10;i++){ if (tank.move(ang)) break; ang += ((i%2?1:-1)*12*Math.PI/180); }


      t = Math.min(t1, t2) > 0 ? Math.min(t1, t2) : Math.max(t1, t2);

function name(){ return 'Dealer Sniper'; }





  }


      if (!isFinite(t) || t < 0) t = 0;

function type(){ return Type.DEALER; }

  const fireAng = safeLead(tank,tgt,BULLET_SPEED) + (Math.random()-0.5)*0.02;



}


    }



  tank.fire(fireAng);






  }

function update(tank, enemies, allies, bulletInfo){

}






  const aimX = dst.x + vx*t;

  const BULLET_SPEED = 400;








  const aimY = dst.y + vy*t;

  const IDEAL_RANGE = 300; // 카이팅 유지 사거리








  return Math.atan2(aimY - src.y, aimX - src.x);

  const FAR_RANGE = 360;   // 멀어지기 임계








}

  const NEAR_RANGE = 220;  // 거리 벌리기 임계








function pickTarget(tank, enemies){

  const jitter = (Math.random()-0.5)*0.08;








  let best=null, score=1e9;










  for (const e of enemies){

  // 1) 회피 최우선: 위협탄 수직 회피








    if (!e) continue;

  const th = mostThreatBullet(tank, bulletInfo);








    const d = dist(tank.x, tank.y, e.x, e.y);

  if (th){








    const s = d*0.6 + (e.hp||100)*0.4 + Math.hypot(e.x-400, e.y-300)*0.1;

    let ang = Math.atan2(th.vy||0, th.vx||0) + (Math.random()<0.5?1:-1)*Math.PI/2;








    if (s < score){ score=s; best=e; }

    for(let i=0;i<10;i++){ if (tank.move(ang)) break; ang += ((i%2?1:-1) * 15*Math.PI/180); }








  }

  }








  return best;










}

  // 2) 타겟팅 및 카이팅








function mostThreatBullet(tank, bulletInfo){

  const tgt = pickTargetSniper(tank, enemies||[]);








  let best=null, bestScore=-Infinity;

  if (tgt){








  for (const b of bulletInfo||[]){

    const d = dist(tank.x,tank.y,tgt.x,tgt.y);








    const d = dist(tank.x, tank.y, b.x, b.y) + 1e-3;

    // 카이팅: 너무 가까우면 멀어지고, 너무 멀면 접근하되 대각으로








    const toMeX = tank.x - b.x, toMeY = tank.y - b.y;

    let moveAng;








    const relSpeed = (b.vx||0)*(toMeX/d) + (b.vy||0)*(toMeY/d); // 접근속도(양수면 접근)

    if (d < NEAR_RANGE) moveAng = angleTo(tank.x,tank.y,tank.x - (tgt.x - tank.x), tank.y - (tgt.y - tank.y));








    const score = relSpeed/d;

    else if (d > FAR_RANGE) moveAng = angleTo(tank.x,tank.y,tgt.x,tgt.y) + (Math.random()<0.5?1:-1)*20*Math.PI/180; 








    if (score > bestScore){ bestScore=score; best=b; }

    else moveAng = angleTo(tank.x,tank.y,tgt.x,tgt.y) + (Math.random()<0.5?1:-1)*90*Math.PI/180; // 큰 오비트








  }

    moveAng += jitter;








  return best;

    for(let i=0;i<10;i++){ if (tank.move(moveAng)) break; moveAng += ((i%2?1:-1) * 12*Math.PI/180); }








}












    // 사격: 평균 속도 리드샷








function name(){ return 'Tanker Guardian'; }

    const ang = safeLead(tank, tgt, BULLET_SPEED) + (Math.random()-0.5)*0.02;








function type(){ return Type.TANKER; }

    tank.fire(ang);










  }








function update(tank, enemies, allies, bulletInfo){

}








  // 기본 파라미터










  const BULLET_SPEED = 400;










  const CENTER_X = 400, CENTER_Y = 300;










  const WALL_MARGIN = 32;










  const jitter = (Math.random()-0.5)*0.1;





















  // 1) 우선 회피










  const threat = mostThreatBullet(tank, bulletInfo);










  if (threat){










    const ang = Math.atan2(threat.vy||0, threat.vx||0) + (Math.random()<0.5?1:-1)*Math.PI/2;










    let tryAng = ang;










    for (let i=0;i<10;i++){










      const ok = tank.move(tryAng);










      if (ok) break;










      tryAng += ((i%2?1:-1) * (15*Math.PI/180));










    }










  } else {










    // 팀 중심 유지 (아군 평균으로 보정)










    let cx=CENTER_X, cy=CENTER_Y;










    if (allies && allies.length){










      let sx=0, sy=0, n=0;










      for(const a of allies){ if(!a) continue; sx+=a.x; sy+=a.y; n++; }










      if (n){ cx=sx/n; cy=sy/n; }










    }










    const toCenter = angleTo(tank.x, tank.y, cx, cy) + jitter;










    let moveAng = toCenter;





















    // 벽/충돌 방지 재시도










    const nearWall = (tank.x < WALL_MARGIN || tank.x > 800-WALL_MARGIN || tank.y < WALL_MARGIN || tank.y > 600-WALL_MARGIN);










    if (nearWall){










      // 벽과 평행하게 미끄러지기










      if (tank.x < WALL_MARGIN || tank.x > 800-WALL_MARGIN) moveAng = Math.sign(tank.vy||1)>0 ? Math.PI/2 : -Math.PI/2;










      if (tank.y < WALL_MARGIN || tank.y > 600-WALL_MARGIN) moveAng = Math.sign(tank.vx||1)>0 ? 0 : Math.PI;










    }










    for (let i=0;i<10;i++){










      if (tank.move(moveAng)) break;










      moveAng += ((i%2?1:-1) * (12*Math.PI/180));










    }










  }





















  // 2) 타겟팅: 최근접 우선, 짧은 리드샷










  const tgt = pickTarget(tank, enemies||[]);










  if (tgt){










    const base = angleTo(tank.x, tank.y, tgt.x, tgt.y);










    const lead = safeLead(tank, tgt, BULLET_SPEED);










    const mix = base*0.6 + lead*0.4 + jitter;










    tank.fire(mix);










  }










}





















