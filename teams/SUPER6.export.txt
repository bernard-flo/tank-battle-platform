// Tanker Guardian — 선두 방패, 팀 중심 유지, 근접 위협 각도 제어 및 짧은 리드샷
function name() { return 'Tanker Guardian'; }
function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸리티 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const angDiff = (a, b) => {
    let d = norm(a) - norm(b); if (d > 180) d -= 360; if (d < -180) d += 360; return d;
  };
  // 발사체 속도(엔진 기준 8)
  const BULLET_SPEED = 8;
  const shortLeadAngle = (sx, sy, tx, ty) => {
    // 짧은 리드샷: 목표까지 각도 + 작은 가속 오프셋
    const base = angleTo(sx, sy, tx, ty);
    // 거리 비례로 0~6도 사이 보정
    const d = Math.hypot(tx - sx, ty - sy);
    const off = clamp(d / 100, 0, (P.short_lead_max_deg ?? 6));
    return base + (hashSign(sx + sy + tx + ty) * off);
  };
  const tryMove = (ang) => {
    // 실패 시 ±15° 보정 재시도 (최대 9회)
    const deltas = [0, 15, -15, 30, -30, 45, -45, 60, -60, 90];
    for (let d of deltas) {
      if (tank.move(norm(ang + d))) return true;
    }
    return false;
  };
  const hashSign = (v) => (Math.sin(v * 0.001) >= 0 ? 1 : -1);

  // ===== 팀 중심/전장 중심 =====
  const center = { x: 450, y: 300 };
  let allyCenter = { x: tank.x, y: tank.y };
  if (allies.length > 0) {
    let sx = tank.x, sy = tank.y, n = 1;
    for (const a of allies) { sx += a.x; sy += a.y; n++; }
    allyCenter = { x: sx / n, y: sy / n };
  }

  // ===== 위협 탄환 평가: 접근속도 * 역거리 =====
  const bestThreat = (() => {
    let best = null; let bestScore = 0;
    for (const b of bulletInfo) {
      const dx = tank.x - b.x, dy = tank.y - b.y;
      const d = Math.hypot(dx, dy) + 1e-3;
      const relSpeedToward = -(b.vx * (dx / d) + b.vy * (dy / d)); // +면 접근
      if (relSpeedToward <= 0) continue;
      const score = relSpeedToward * (1 / d);
      if (score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  })();

  // ===== 회피 우선 =====
  if (bestThreat) {
    const ba = Math.atan2(bestThreat.vy, bestThreat.vx) * 180 / Math.PI;
    const dx = tank.x - bestThreat.x, dy = tank.y - bestThreat.y;
    const cross = bestThreat.vx * dy - bestThreat.vy * dx;
    const side = cross >= 0 ? -1 : 1; // 궤적 법선 중 멀어지는 쪽 선택
    const evade = norm(ba + side * 90);
    if (!tryMove(evade)) {
      // 마지막 수단: 반대편으로
      tryMove(norm(ba - side * 90));
    }
  } else {
    // ===== 기본 포지셔닝: 아군 중심과 전장 중심 사이에서 방패 역할 =====
    // 최근접 적을 추적하며 접근 각도 제어
    let target = null;
    for (const e of enemies) {
      if (!target || e.distance < target.distance ||
          (Math.abs(e.distance - target.distance) < 1e-3 && e.health < target.health)) {
        target = e;
      }
    }

    const stayPoint = {
      x: allyCenter.x * 0.7 + center.x * 0.3,
      y: allyCenter.y * 0.7 + center.y * 0.3
    };

    if (target) {
      // 타깃과 아군 중심 사이에 위치하도록 살짝 전진
      const mid = { x: (target.x + allyCenter.x) / 2, y: (target.y + allyCenter.y) / 2 };
      const desired = angleTo(tank.x, tank.y, mid.x, mid.y);
      // 보스턴 느낌의 작은 선회(±12도)로 각도 제어
      const spin = (P.spin_deg ?? 12) * hashSign(tank.x + tank.y + target.x + target.y);
      tryMove(norm(desired + spin));

      // 짧은 리드샷
      const fireAng = shortLeadAngle(tank.x, tank.y, target.x, target.y);
      tank.fire(fireAng);
    } else {
      // 타겟 없으면 아군 중심 근처 유지
      const a = angleTo(tank.x, tank.y, stayPoint.x, stayPoint.y);
      tryMove(a);
    }
  }
}


// ===== 다음 로봇 =====


// Dealer Sniper — 장거리 정밀 사격, 카이팅, 탄 회피 우선
function name() { return 'Dealer Sniper'; }
function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const hashSign = (v) => (Math.sin(v * 0.002) >= 0 ? 1 : -1);
  const tryMove = (ang) => {
    const deltas = [0, 15, -15, 30, -30, 45, -45, 60, -60, 90];
    for (let d of deltas) { if (tank.move(norm(ang + d))) return true; }
    return false;
  };
  const BULLET_SPEED = 8;
  const assumedTargetSpeed = 4.5; // 평균적 이동속도 가정
  const leadAngle = (sx, sy, tx, ty) => {
    // 간이 리드: 거리 기반 작은 보정(최대 10도)
    const base = angleTo(sx, sy, tx, ty);
    const d = Math.hypot(tx - sx, ty - sy);
    const off = clamp((assumedTargetSpeed / BULLET_SPEED) * (d / 80), 0, (P.lead_max_deg ?? 10));
    return base + off * hashSign(sx + sy + tx + ty);
  };

  // ===== 탄 위협 우선 회피 =====
  const threat = (() => {
    let bBest = null, sBest = 0;
    for (const b of bulletInfo) {
      const dx = tank.x - b.x, dy = tank.y - b.y;
      const d = Math.hypot(dx, dy) + 1e-3;
      const toward = -(b.vx * (dx / d) + b.vy * (dy / d));
      if (toward <= 0) continue;
      const score = toward * (1 / d);
      if (score > sBest) { sBest = score; bBest = b; }
    }
    return bBest;
  })();

  if (threat) {
    const ba = Math.atan2(threat.vy, threat.vx) * 180 / Math.PI;
    const dx = tank.x - threat.x, dy = tank.y - threat.y;
    const cross = threat.vx * dy - threat.vy * dx;
    const side = cross >= 0 ? -1 : 1;
    const evade = norm(ba + side * 90);
    if (!tryMove(evade)) tryMove(norm(ba - side * 90));
  } else {
    // ===== 타겟 선정: 체력 낮음 우선, 이후 근접 =====
    let target = null;
    for (const e of enemies) {
      if (!target) { target = e; continue; }
      if (e.health < target.health - 1e-6) target = e;
      else if (Math.abs(e.health - target.health) < 1e-6 && e.distance < target.distance) target = e;
    }

    if (target) {
      const d = target.distance;
      // 카이팅: 이상적 사거리
      const ideal = (P.ideal_range ?? 320);
      const aTo = angleTo(tank.x, tank.y, target.x, target.y);
      const orbitDir = hashSign(tank.x * 7.7 + tank.y * 3.1 + target.x * 2.3);

      if (d < ideal * 0.85) {
        // 너무 가까우면 멀어지며 스트레이프
        const away = norm(aTo + 180 + orbitDir * (P.strafe_deg ?? 20));
        tryMove(away);
      } else if (d > ideal * 1.25) {
        // 너무 멀면 접근하되 큰 반경 유지
        const inA = norm(aTo + orbitDir * (P.strafe_deg ?? 20));
        tryMove(inA);
      } else {
        // 적을 크게 오비트(±90 근처)
        const strafe = norm(aTo + orbitDir * (P.orbit_deg ?? 90));
        tryMove(strafe);
      }

      // 사격: 리드샷 + 소량 난수 오프셋
      const fireAng = leadAngle(tank.x, tank.y, target.x, target.y);
      tank.fire(fireAng);
    } else {
      // 타겟 없으면 중앙과의 거리 유지하며 라우팅
      const center = { x: 450, y: 300 };
      const a = angleTo(tank.x, tank.y, center.x, center.y) + 90 * hashSign(tank.x + tank.y);
      tryMove(norm(a));
    }
  }
}


// ===== 다음 로봇 =====


// Dealer Flanker — 측후방 진입, 원운동 오비트, 연속 사격
function name() { return 'Dealer Flanker'; }
function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const tryMove = (ang) => {
    const deltas = [0, 15, -15, 30, -30, 45, -45, 60, -60, 90];
    for (let d of deltas) { if (tank.move(norm(ang + d))) return true; }
    return false;
  };
  const hashSign = (v) => (Math.sin(v * 0.003) >= 0 ? 1 : -1);

  // ===== 탄 회피(간단) =====
  let danger = null, best = 0;
  for (const b of bulletInfo) {
    const dx = tank.x - b.x, dy = tank.y - b.y; const d = Math.hypot(dx, dy) + 1e-3;
    const toward = -(b.vx * (dx / d) + b.vy * (dy / d));
    const score = toward > 0 ? toward / d : 0;
    if (score > best) { best = score; danger = b; }
  }
  if (danger) {
    const ba = Math.atan2(danger.vy, danger.vx) * 180 / Math.PI;
    const dx = tank.x - danger.x, dy = tank.y - danger.y;
    const side = (danger.vx * dy - danger.vy * dx) >= 0 ? -1 : 1;
    if (tryMove(norm(ba + side * 90))) return; else tryMove(norm(ba - side * 90));
  }

  // ===== 타겟 선정: 가장 가까운 적 =====
  let target = null;
  for (const e of enemies) { if (!target || e.distance < target.distance) target = e; }
  if (!target) {
    // 중앙 근처 순찰
    const center = { x: 450, y: 300 };
    return void tryMove(norm(angleTo(tank.x, tank.y, center.x, center.y) + 90));
  }

  // ===== 원운동: 타겟 법선 방향(±90°)
  const aTo = angleTo(tank.x, tank.y, target.x, target.y);
  const orbitSign = hashSign(tank.x * 5.1 + tank.y * 2.9 + target.x * 1.7);
  let radius = clamp(target.distance, (P.radius_min ?? 140), (P.radius_max ?? 260));
  // 주기적 반경 조절: 벽/충돌 회피를 위한 미세 진폭
  const wiggle = (P.wiggle ?? 20) * orbitSign;
  const want = norm(aTo + orbitSign * (P.orbit_deg ?? 90));
  // 반경 보정: 너무 가깝다면 바깥쪽으로, 멀다면 안쪽으로 살짝
  const radialBias = (target.distance < radius ? -15 : (target.distance > radius ? 15 : 0));
  tryMove(norm(want + radialBias + wiggle * Math.sin((tank.x + tank.y) * 0.01)));

  // ===== 사격: 기본 조준 + 소량 오프셋
  const fireAngle = aTo + orbitSign * clamp(target.distance / 50, 0, 8);
  tank.fire(norm(fireAngle));
}


// ===== 다음 로봇 =====


// Normal Interceptor — 위협탄 우선 수직 회피, 여유 시 리드샷
function name() { return 'Normal Interceptor'; }
function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const tryMove = (ang) => { const ds=[0,15,-15,30,-30,45,-45,60,-60,90]; for(const d of ds){ if(tank.move(norm(ang+d))) return true; } return false; };
  const BULLET_SPEED = 8;
  const assumedTargetSpeed = 4.5;
  const leadAngle = (sx, sy, tx, ty) => {
    const base = angleTo(sx, sy, tx, ty);
    const d = Math.hypot(tx - sx, ty - sy);
    const off = clamp((assumedTargetSpeed / BULLET_SPEED) * (d / 100), 0, (P.lead_max_deg ?? 8));
    return base + off * (Math.sin((sx + sy + tx + ty) * 0.002) >= 0 ? 1 : -1);
  };

  // ===== 위협 평가: 접근속도 * 역거리 =====
  let danger = null, bestScore = 0;
  for (const b of bulletInfo) {
    const dx = tank.x - b.x, dy = tank.y - b.y; const d = Math.hypot(dx, dy) + 1e-3;
    const toward = -(b.vx * (dx / d) + b.vy * (dy / d));
    if (toward <= 0) continue;
    const score = toward * (1 / d);
    if (score > bestScore) { bestScore = score; danger = b; }
  }

  if (danger) {
    const ba = Math.atan2(danger.vy, danger.vx) * 180 / Math.PI;
    const dx = tank.x - danger.x, dy = tank.y - danger.y;
    const side = (danger.vx * dy - danger.vy * dx) >= 0 ? -1 : 1;
    if (!tryMove(norm(ba + side * 90))) tryMove(norm(ba - side * 90));
  } else {
    // 여유 시 최근접 적에게 리드샷 + 얕은 스트레이프
    let target = null;
    for (const e of enemies) { if (!target || e.distance < target.distance) target = e; }
    if (target) {
      const aTo = angleTo(tank.x, tank.y, target.x, target.y);
      // 얕은 스트레이프 이동(±P.strafe_deg)
      const sign = (Math.sin((tank.x + tank.y + target.x) * 0.003) >= 0) ? 1 : -1;
      tryMove(norm(aTo + sign * (P.strafe_deg ?? 70)));
      tank.fire(leadAngle(tank.x, tank.y, target.x, target.y));
    } else {
      // 타겟 없을 때 중앙 순찰
      const center = { x: 450, y: 300 };
      tryMove(norm(angleTo(tank.x, tank.y, center.x, center.y) + 120));
    }
  }
}


// ===== 다음 로봇 =====


// Normal Support — 아군 중심 보호, 포커스 파이어 동조, 중거리 유지
function name() { return 'Normal Support'; }
function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const tryMove = (ang) => { const ds=[0,15,-15,30,-30,45,-45,60,-60,90]; for (const d of ds){ if (tank.move(norm(ang+d))) return true; } return false; };
  const hash = (v) => Math.abs(Math.sin(v * 0.001));

  // ===== 팀 중심 계산 =====
  let ax = tank.x, ay = tank.y, n = 1;
  for (const a of allies) { ax += a.x; ay += a.y; n++; }
  const allyC = { x: ax / n, y: ay / n };

  // ===== 공통 타겟 선정(동일 규칙) =====
  // 규칙: f = (팀중심과의 거리) + w*health, w=0.15 — 최소값을 선택
  let target = null; let bestF = Infinity;
  for (const e of enemies) {
    const dC = Math.hypot(e.x - allyC.x, e.y - allyC.y);
    const f = dC + (P.focus_health_weight ?? 0.15) * e.health;
    if (f < bestF) { bestF = f; target = e; }
  }

  // ===== 탄 회피(간단) =====
  let danger = null, best = 0;
  for (const b of bulletInfo) {
    const dx = tank.x - b.x, dy = tank.y - b.y; const d = Math.hypot(dx, dy) + 1e-3;
    const toward = -(b.vx * (dx / d) + b.vy * (dy / d));
    const s = toward > 0 ? toward / d : 0;
    if (s > best) { best = s; danger = b; }
  }
  if (danger) {
    const ba = Math.atan2(danger.vy, danger.vx) * 180 / Math.PI;
    const dx = tank.x - danger.x, dy = tank.y - danger.y;
    const side = (danger.vx * dy - danger.vy * dx) >= 0 ? -1 : 1;
    if (!tryMove(norm(ba + side * 90))) tryMove(norm(ba - side * 90));
  } else {
    // ===== 중거리 유지 =====
    if (target) {
      const d = target.distance;
      const mid = (P.mid_range ?? 220); // 중거리 목표 반경
      const aTo = angleTo(tank.x, tank.y, target.x, target.y);
      const orbit = (hash(tank.x + tank.y + target.x) >= 0.5) ? 1 : -1;

      if (d < mid * 0.85) {
        // 살짝 이탈하며 아군중심과 각 정렬
        const towardAllies = angleTo(tank.x, tank.y, allyC.x, allyC.y);
        tryMove(norm(towardAllies + 160 * orbit));
      } else if (d > mid * 1.2) {
        tryMove(norm(aTo + orbit * 20));
      } else {
        tryMove(norm(aTo + orbit * (P.orbit_deg ?? 85)));
      }

      // 포커스 파이어: 동일 타겟으로 발사
      tank.fire(aTo);
    } else {
      // 타겟 없을 때는 아군 중심 방어 위치로 이동
      const a = angleTo(tank.x, tank.y, allyC.x, allyC.y) + 100;
      tryMove(norm(a));
    }
  }
}


// ===== 다음 로봇 =====


// Tanker Bruiser — 전면 압박, 벽-슬라이딩, 지속 사격, 지그재그 회피
function name() { return 'Tanker Bruiser'; }
function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  "use strict";
  // ===== 유틸 =====
  const P = (typeof PARAMS === 'object' && PARAMS) || {};
  const angleTo = (ax, ay, bx, by) => Math.atan2(by - ay, bx - ax) * 180 / Math.PI;
  const norm = (a) => ((a % 360) + 360) % 360;
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const tryMove = (ang) => { const ds=[0,15,-15,30,-30,45,-45,60,-60,90]; for (const d of ds){ if (tank.move(norm(ang+d))) return true; } return false; };
  const hashSign = (v) => (Math.sin(v * 0.0025) >= 0 ? 1 : -1);

  // ===== 위협 탄 회피(간헐) =====
  let danger = null, score = 0;
  for (const b of bulletInfo) {
    const dx = tank.x - b.x, dy = tank.y - b.y; const d = Math.hypot(dx, dy) + 1e-3;
    const toward = -(b.vx * (dx / d) + b.vy * (dy / d));
    const s = toward > 0 ? toward / d : 0;
    if (s > score) { score = s; danger = b; }
  }
  if (danger) {
    const ba = Math.atan2(danger.vy, danger.vx) * 180 / Math.PI;
    const dx = tank.x - danger.x, dy = tank.y - danger.y;
    const side = (danger.vx * dy - danger.vy * dx) >= 0 ? -1 : 1;
    if (!tryMove(norm(ba + side * 90))) tryMove(norm(ba - side * 90));
  } else {
    // ===== 압박 방향: 적 군집 중심 향해 전진
    let cx = 450, cy = 300, n = 0;
    for (const e of enemies) { cx += e.x; cy += e.y; n++; }
    if (n > 0) { cx = cx / (n + 1); cy = cy / (n + 1); }
    const aTo = angleTo(tank.x, tank.y, cx, cy);

    // 벽-슬라이딩: 벽 근처면 평행 이동(±90)
    const margin = (P.wall_margin ?? 60) + tank.size * 0.5;
    const nearLeft = tank.x < margin, nearRight = tank.x > 900 - margin;
    const nearTop = tank.y < margin, nearBot = tank.y > 600 - margin;
    let moveAng = aTo;
    if (nearLeft || nearRight) {
      moveAng = norm((nearLeft ? 0 : 180) + hashSign(tank.y) * 90); // 수평 벽과 평행
    } else if (nearTop || nearBot) {
      moveAng = norm((nearTop ? 90 : 270) + hashSign(tank.x) * 90); // 수직 벽과 평행
    } else {
      // 지그재그 오프셋
      const zig = (P.zig_deg ?? 20) * hashSign(Math.floor((tank.x + tank.y) / 20));
      moveAng = norm(aTo + zig);
    }
    tryMove(moveAng);

    // 지속 사격: 전진 방향 또는 가장 가까운 적 조준
    let target = null;
    for (const e of enemies) { if (!target || e.distance < target.distance) target = e; }
    if (target) tank.fire(angleTo(tank.x, tank.y, target.x, target.y));
    else tank.fire(moveAng);
  }
}
