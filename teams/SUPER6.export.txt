function name() { return 'Tanker Guardian'; }

function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  'use strict';

  // ===== Utilities (local only) =====
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function dist(ax, ay, bx, by) { const dx = bx - ax, dy = by - ay; return Math.hypot(dx, dy); }
  function angleTo(ax, ay, bx, by) { return Math.atan2(by - ay, bx - ax) * 180 / Math.PI; }
  function normAngle(a){ while(a>180) a-=360; while(a<-180) a+=360; return a; }
  function tryMove(angle){
    // engine limits to 10 attempts per tick
    const order = [0, 15, -15, 30, -30, 45, -45, 60, -60, 90];
    for (let i=0;i<order.length;i++){
      if (tank.move(angle + order[i])) return true;
    }
    return false;
  }
  function fireAtAngle(a){ tank.fire(a + (Math.random()*2-1)*3); }
  const BULLET_SPEED = 8;

  // Lead shot: short lead using assumed target lateral motion (unknown), add tiny jitter
  function leadAngle(src, dst){
    // Without velocity info, use direct aim with tiny forward bias
    return angleTo(src.x, src.y, dst.x, dst.y);
  }

  // Threat scoring for bullets: approaching speed * inverse distance
  function mostThreateningBullet() {
    let best = null; let bestScore = 0;
    for (const b of bulletInfo){
      const dx = tank.x - b.x, dy = tank.y - b.y;
      const d = Math.hypot(dx, dy) + 1e-6;
      const approach = (-(b.vx*dx + b.vy*dy) / d); // >0 if approaching
      const score = (approach>0?approach:0) * (1/(d));
      if (score > bestScore){ bestScore = score; best = b; }
    }
    return {bullet: best, score: bestScore};
  }

  function evadeBullet(b){
    // Move perpendicular to bullet velocity, pick side that increases separation
    const base = Math.atan2(b.vy, b.vx) * 180/Math.PI;
    const left = base + 90;
    const right = base - 90;
    // Pick the side with greater dot product away from bullet path
    const toTank = {x: tank.x - b.x, y: tank.y - b.y};
    function projAway(moveDeg){
      const r = moveDeg * Math.PI/180;
      const ux = Math.cos(r), uy = Math.sin(r);
      return (ux*toTank.x + uy*toTank.y);
    }
    const dir = projAway(left) > projAway(right) ? left : right;
    // small random to avoid predictability
    return tryMove(dir + (Math.random()*2-1)*8);
  }

  // Target selection: distance -> low health -> centrality of enemy
  function pickTarget(list){
    if (!list || list.length===0) return null;
    const cx = 450, cy = 300;
    let best = null; let bestKey = null;
    for (const e of list){
      const k = [ Math.round(e.distance), Math.round(e.health), Math.round(dist(e.x,e.y,cx,cy)) ];
      if (!best || k[0]<bestKey[0] || (k[0]===bestKey[0] && (k[1]<bestKey[1] || (k[1]===bestKey[1] && k[2]<bestKey[2])))){
        best = e; bestKey = k;
      }
    }
    return best;
  }

  // ===== Behavior =====
  // 1) Bullet evasion (high priority)
  const threat = mostThreateningBullet();
  if (threat.bullet && threat.score > 0.002) { // threshold tuned for MVP
    if (!evadeBullet(threat.bullet)) {
      // fallback: radial move away from bullet
      const away = angleTo(threat.bullet.x, threat.bullet.y, tank.x, tank.y);
      tryMove(away + (Math.random()*2-1)*10);
    }
  } else {
    // 2) Defensive positioning: stay near team center as front shield
    let ax=0, ay=0, n=0;
    for (const a of allies){ ax+=a.x; ay+=a.y; n++; }
    const center = n>0 ? {x: ax/n, y: ay/n} : {x: 450, y: 300};
    const toCenter = angleTo(tank.x, tank.y, center.x, center.y);
    const dCenter = dist(tank.x, tank.y, center.x, center.y);
    // Keep ~80px radius from allied center
    const desired = dCenter>90 ? toCenter : (toCenter+180);
    tryMove(desired + (Math.random()*2-1)*6);
  }

  // 3) Engage nearest threat with short lead
  const target = pickTarget(enemies);
  if (target){
    const fireDeg = leadAngle({x:tank.x,y:tank.y}, target) + (Math.random()*2-1)*2;
    fireAtAngle(fireDeg);
  }
}



// ===== 다음 로봇 =====


function name() { return 'Dealer Sniper'; }

function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo){
  'use strict';

  // ===== Utils =====
  function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
  function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax)*180/Math.PI; }
  function tryMove(base){
    const seq = [0, 20, -20, 40, -40, 60, -60, 80, -80, 100];
    for (let o of seq){ if (tank.move(base+o)) return true; }
    return false;
  }
  function mostThreatBullet(){
    let best=null, score=0;
    for (const b of bulletInfo){
      const dx=tank.x-b.x, dy=tank.y-b.y, d=Math.hypot(dx,dy)+1e-6;
      const approach = (-(b.vx*dx + b.vy*dy)/d);
      const s = (approach>0?approach:0)/(d);
      if (s>score){ score=s; best=b; }
    }
    return {b:best, s:score};
  }
  function evade(b){
    const base = Math.atan2(b.vy,b.vx)*180/Math.PI;
    const left = base+90, right=base-90;
    const toTankX=tank.x-b.x, toTankY=tank.y-b.y;
    function proj(a){ const r=a*Math.PI/180; return Math.cos(r)*toTankX+Math.sin(r)*toTankY; }
    const dir = proj(left)>proj(right)?left:right;
    return tryMove(dir + (Math.random()*2-1)*10);
  }
  function pickLowestHP(list){
    if (!list||!list.length) return null;
    let best=list[0];
    for (const e of list){ if (e.health<best.health || (e.health===best.health && e.distance<best.distance)) best=e; }
    return best;
  }

  // ===== Behavior =====
  const threat = mostThreatBullet();
  if (threat.b && threat.s>0.002){
    if(!evade(threat.b)){
      const away = angleTo(threat.b.x,threat.b.y,tank.x,tank.y);
      tryMove(away);
    }
  } else {
    // Kiting/orbiting around target
    const tgt = pickLowestHP(enemies);
    if (tgt){
      // Keep long distance ~350-420
      const d = tgt.distance;
      const toTgt = angleTo(tank.x,tank.y,tgt.x,tgt.y);
      let moveDir;
      if (d < 280) moveDir = toTgt + 180; // back off
      else if (d > 450) moveDir = toTgt; // close in slightly
      else {
        // orbit with large radius
        const sign = Math.random()<0.5?1:-1;
        moveDir = toTgt + sign*90;
      }
      tryMove(moveDir + (Math.random()*2-1)*6);

      // Fire with slight jitter (bullet speed 8)
      const fireDeg = toTgt + (Math.random()*2-1)*3;
      tank.fire(fireDeg);
    } else {
      // No target: drift towards arena center to gain vision
      const centerDir = angleTo(tank.x,tank.y,450,300);
      tryMove(centerDir + (Math.random()*2-1)*10);
    }
  }
}



// ===== 다음 로봇 =====


function name() { return 'Dealer Flanker'; }

function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo){
  'use strict';

  // ===== Utils =====
  function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
  function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax)*180/Math.PI; }
  function tryMove(a){
    const seq=[0,15,-15,30,-30,45,-45,60,-60,90];
    for(const o of seq){ if(tank.move(a+o)) return true; }
    return false;
  }
  function mostThreatBullet(){
    let best=null,score=0;
    for(const b of bulletInfo){
      const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-6;
      const approach = (-(b.vx*dx + b.vy*dy)/d);
      const s=(approach>0?approach:0)/(d);
      if(s>score){score=s;best=b;}
    }
    return {b:best,s:score};
  }
  function evade(b){
    const base=Math.atan2(b.vy,b.vx)*180/Math.PI;
    const left=base+90,right=base-90;
    const tx=tank.x-b.x, ty=tank.y-b.y;
    function proj(a){const r=a*Math.PI/180;return Math.cos(r)*tx+Math.sin(r)*ty;}
    const dir=proj(left)>proj(right)?left:right;
    return tryMove(dir + (Math.random()*2-1)*10);
  }
  function pickTarget(list){
    if(!list||!list.length) return null;
    let best=list[0];
    for(const e of list){ if(e.distance<best.distance) best=e; }
    return best;
  }
  function nearWall(x,y,margin){ return (x<margin||x>900-margin||y<margin||y>600-margin); }

  // ===== Behavior =====
  const threat=mostThreatBullet();
  if(threat.b && threat.s>0.002){
    if(!evade(threat.b)){
      const away=angleTo(threat.b.x,threat.b.y,tank.x,tank.y);
      tryMove(away);
    }
    // still try to fire at nearest while evading
  }

  const tgt=pickTarget(enemies);
  if(tgt){
    const d=tgt.distance; const toTgt=angleTo(tank.x,tank.y,tgt.x,tgt.y);
    const flip = (Math.random()<0.5?1:-1);
    let moveDir;
    // modulate radius to avoid collisions/walls
    if (nearWall(tank.x,tank.y,50)){
      // slide parallel to nearest wall: choose direction that increases in-bounds
      if (tank.x<50) moveDir=0; else if (tank.x>850) moveDir=180; else if (tank.y<50) moveDir=90; else moveDir=270;
    } else if (d<160){
      moveDir = toTgt + 180; // pull out
    } else if (d>260){
      moveDir = toTgt; // close in a bit
    } else {
      moveDir = toTgt + flip*90; // orbit
    }
    tryMove(moveDir + (Math.random()*2-1)*8);

    // Continuous fire with small offset
    tank.fire(toTgt + (Math.random()*2-1)*4);
  } else {
    // regroup towards center when target missing
    const cdir=angleTo(tank.x,tank.y,450,300);
    tryMove(cdir);
  }
}



// ===== 다음 로봇 =====


function name() { return 'Normal Interceptor'; }

function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo){
  'use strict';

  // ===== Utils =====
  function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax)*180/Math.PI; }
  function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
  function tryMove(a){ const seq=[0,15,-15,30,-30,45,-45,60,-60,90]; for(const o of seq){ if(tank.move(a+o)) return true; } return false; }
  function mostThreat(){ let best=null,score=0; for(const b of bulletInfo){ const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-6; const approach=(-(b.vx*dx+b.vy*dy)/d); const s=(approach>0?approach:0)/(d); if(s>score){score=s;best=b;} } return {b:best,s:score}; }
  function evade(b){ const base=Math.atan2(b.vy,b.vx)*180/Math.PI; const l=base+90, r=base-90; const tx=tank.x-b.x, ty=tank.y-b.y; function proj(a){const r=a*Math.PI/180; return Math.cos(r)*tx+Math.sin(r)*ty;} const dir = proj(l)>proj(r)?l:r; return tryMove(dir + (Math.random()*2-1)*8); }
  function pickNearest(list){ if(!list||!list.length) return null; let best=list[0]; for(const e of list){ if(e.distance<best.distance) best=e; } return best; }

  // ===== Behavior =====
  const threat = mostThreat();
  if (threat.b && threat.s>0.002){
    if(!evade(threat.b)){
      const away=angleTo(threat.b.x,threat.b.y,tank.x,tank.y);
      tryMove(away);
    }
  } else {
    // proactive intercept positioning: hover midline
    const midDir = angleTo(tank.x,tank.y,450,300);
    tryMove(midDir + (Math.random()*2-1)*10);
  }

  // Counter-fire when possible
  const tgt = pickNearest(enemies);
  if (tgt){
    const fireDeg = angleTo(tank.x,tank.y,tgt.x,tgt.y) + (Math.random()*2-1)*3;
    tank.fire(fireDeg);
  }
}



// ===== 다음 로봇 =====


function name() { return 'Normal Support'; }

function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo){
  'use strict';

  // ===== Utils =====
  function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
  function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax)*180/Math.PI; }
  function tryMove(a){ const seq=[0,15,-15,30,-30,45,-45,60,-60,90]; for(const o of seq){ if(tank.move(a+o)) return true; } return false; }
  function mostThreat(){ let best=null,score=0; for(const b of bulletInfo){ const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-6; const approach=(-(b.vx*dx+b.vy*dy)/d); const s=(approach>0?approach:0)/d; if(s>score){score=s;best=b;} } return {b:best,s:score}; }
  function evade(b){ const base=Math.atan2(b.vy,b.vx)*180/Math.PI; const l=base+90, r=base-90; const tx=tank.x-b.x, ty=tank.y-b.y; function proj(a){const r=a*Math.PI/180; return Math.cos(r)*tx+Math.sin(r)*ty;} const dir=proj(l)>proj(r)?l:r; return tryMove(dir + (Math.random()*2-1)*8); }
  function pickCommonTarget(list){
    if(!list||!list.length) return null;
    const cx=450, cy=300;
    let best=null,bkey=null;
    for(const e of list){
      const key=[Math.round(e.distance), Math.round(e.health), Math.round(dist(e.x,e.y,cx,cy))];
      if(!best || key[0]<bkey[0] || (key[0]===bkey[0] && (key[1]<bkey[1] || (key[1]===bkey[1] && key[2]<bkey[2])))){
        best=e; bkey=key;
      }
    }
    return best;
  }

  // ===== Behavior =====
  const threat=mostThreat();
  if(threat.b && threat.s>0.002){
    if(!evade(threat.b)){
      const away=angleTo(threat.b.x,threat.b.y,tank.x,tank.y);
      tryMove(away);
    }
  }

  // Compute ally centroid
  let ax=0, ay=0, n=0; for(const a of allies){ ax+=a.x; ay+=a.y; n++; }
  const center = n?{x:ax/n,y:ay/n}:{x:450,y:300};

  const tgt = pickCommonTarget(enemies);
  if (tgt){
    const toTgt=angleTo(tank.x,tank.y,tgt.x,tgt.y);
    const d=tgt.distance;
    // Maintain mid range 220-300, and align with allies
    let moveDir;
    if (d<200) moveDir = toTgt+180; else if (d>320) moveDir = toTgt; else moveDir = toTgt + (Math.random()<0.5?90:-90);
    // Blend toward ally center if far from it
    const toCenter = angleTo(tank.x,tank.y,center.x,center.y);
    const farFromPack = dist(tank.x,tank.y,center.x,center.y) > 140;
    if (farFromPack) moveDir = (moveDir*0.4 + toCenter*0.6);
    tryMove(moveDir + (Math.random()*2-1)*6);

    // Focus fire
    tank.fire(toTgt + (Math.random()*2-1)*3);
  } else {
    // No target: regroup to allies
    const dir=angleTo(tank.x,tank.y,center.x,center.y);
    tryMove(dir);
  }
}



// ===== 다음 로봇 =====


function name() { return 'Tanker Bruiser'; }

function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo){
  'use strict';

  // ===== Utils =====
  function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay, bx-ax)*180/Math.PI; }
  function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
  function tryMove(a){ const seq=[0,10,-10,20,-20,35,-35,50,-50,80]; for(const o of seq){ if(tank.move(a+o)) return true; } return false; }
  function mostThreat(){ let best=null,score=0; for(const b of bulletInfo){ const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-6; const approach=(-(b.vx*dx+b.vy*dy)/d); const s=(approach>0?approach:0)/d; if(s>score){score=s;best=b;} } return {b:best,s:score}; }
  function evade(b){ const base=Math.atan2(b.vy,b.vx)*180/Math.PI; const l=base+90,r=base-90; const tx=tank.x-b.x, ty=tank.y-b.y; function proj(a){const r=a*Math.PI/180; return Math.cos(r)*tx+Math.sin(r)*ty;} const dir=proj(l)>proj(r)?l:r; return tryMove(dir + (Math.random()*2-1)*6); }
  function pickFront(list){ if(!list||!list.length) return null; let best=list[0]; for(const e of list){ if(e.distance<best.distance) best=e; } return best; }
  function nearWall(x,y,m){ return (x<m||x>900-m||y<m||y>600-m); }

  // ===== Behavior =====
  const threat = mostThreat();
  if (threat.b && threat.s>0.002) {
    if(!evade(threat.b)){
      const away=angleTo(threat.b.x,threat.b.y,tank.x,tank.y);
      tryMove(away);
    }
  }

  const tgt = pickFront(enemies);
  if (tgt){
    const d=tgt.distance; const toTgt=angleTo(tank.x,tank.y,tgt.x,tgt.y);
    // Zig-zag strafe sign from position-based parity
    const zig = ((Math.floor((tank.x+tank.y)/50)%2) ? 1 : -1);
    let moveDir;
    if (nearWall(tank.x,tank.y,40)){
      // wall sliding: move parallel along nearest wall
      if (tank.x<40) moveDir = 0 + zig*15; else if (tank.x>860) moveDir = 180 + zig*15; else if (tank.y<40) moveDir = 90 + zig*15; else moveDir = 270 + zig*15;
    } else if (d>220){
      moveDir = toTgt + zig*20; // advance with slight strafe
    } else if (d<120){
      moveDir = toTgt + 180 + zig*15; // create breathing room
    } else {
      moveDir = toTgt + zig*90; // orbit pressure
    }
    tryMove(moveDir + (Math.random()*2-1)*6);

    // constant pressure fire
    tank.fire(toTgt + (Math.random()*2-1)*3);
  } else {
    // push toward center if no visible enemies
    const c=angleTo(tank.x,tank.y,450,300);
    tryMove(c);
  }
}

