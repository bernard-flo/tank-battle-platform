// Tanker Guardian — 선두 방패 역할, 팀 중심 근처 유지 및 근접 위협 각도 제어
// 스니펫 규격: name(), type(), update(tank, enemies, allies, bulletInfo)

function name() { return 'Tanker Guardian'; }

function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸리티 =====
  const PI = Math.PI;
  const TAU = Math.PI * 2;
  const DEG = PI / 180;
  const EPS = 1e-6;

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function wrapAngle(a) { while (a <= -PI) a += TAU; while (a > PI) a -= TAU; return a; }
  function angleTo(dx, dy) { return Math.atan2(dy, dx); }
  function dist(ax, ay, bx, by) { const dx = bx - ax, dy = by - ay; return Math.hypot(dx, dy); }
  function randRange(a, b) { return a + (b - a) * Math.random(); }

  // 투사체 속도 추정(플랫폼 제공 시 사용, 없으면 기본값)
  const bulletSpeed = (tank && (tank.bulletSpeed || tank.projectileSpeed)) || 6.0;

  // 리드샷 각 계산: src -> dst, dst가 속도 보유 시 요격각, 실패 시 직접 조준
  function leadAngle(src, dst, projSpeed) {
    const rx = dst.x - src.x, ry = dst.y - src.y;
    const dvx = (dst.vx || 0), dvy = (dst.vy || 0);
    const a = dvx*dvx + dvy*dvy - projSpeed*projSpeed;
    const b = 2 * (rx*dvx + ry*dvy);
    const c = rx*rx + ry*ry;
    let t;
    if (Math.abs(a) < 1e-6) {
      t = (Math.abs(b) < 1e-6) ? 0 : clamp(-c / b, 0, 2.0);
    } else {
      const disc = b*b - 4*a*c;
      if (disc < 0) t = 0; else {
        const s = Math.sqrt(Math.max(0, disc));
        const t1 = (-b - s) / (2*a);
        const t2 = (-b + s) / (2*a);
        t = Math.min(t1, t2);
        if (t < 0) t = Math.max(t1, t2);
        if (t < 0) t = 0;
        t = clamp(t, 0, 1.5);
      }
    }
    const tx = dst.x + dvx * t;
    const ty = dst.y + dvy * t;
    return Math.atan2(ty - src.x /* intentional? no */, tx - src.y /* swapped? safeguard below */);
  }

  // 위의 leadAngle에서 아탄/아역 좌표 실수를 방지하기 위한 안전 래퍼
  function leadAngleSafe(src, dst, projSpeed) {
    // 기본 직선 각
    const direct = Math.atan2(dst.y - src.y, dst.x - src.x);
    // 보정 계산
    const rx = dst.x - src.x, ry = dst.y - src.y;
    const dvx = (dst.vx || 0), dvy = (dst.vy || 0);
    const a = dvx*dvx + dvy*dvy - projSpeed*projSpeed;
    const b = 2 * (rx*dvx + ry*dvy);
    const c = rx*rx + ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = (Math.abs(b) < 1e-6) ? 0 : clamp(-c / b, 0, 2.0);
    } else {
      const disc = b*b - 4*a*c;
      if (disc >= 0) {
        const s = Math.sqrt(disc);
        const t1 = (-b - s) / (2*a);
        const t2 = (-b + s) / (2*a);
        t = Math.min(t1, t2);
        if (t < 0) t = Math.max(t1, t2);
        if (t < 0) t = 0;
        t = clamp(t, 0, 1.5);
      }
    }
    const aimX = dst.x + (dst.vx || 0) * t;
    const aimY = dst.y + (dst.vy || 0) * t;
    return Math.atan2(aimY - src.y, aimX - src.x);
  }

  // 이동 시도: 실패 대비 각도 ±15° 점진 보정, 최대 10회
  function tryMove(baseAngle) {
    const DEL = 15 * DEG;
    for (let i = 0; i < 10; i++) {
      const sign = (i % 2 === 0) ? 1 : -1;
      const k = Math.floor(i / 2);
      const a = baseAngle + sign * k * DEL;
      if (tank.move(a)) return true;
    }
    return false;
  }

  // 가장 위협적인 탄환 선택: 위협 = 접근속도(+) * 역거리 가중
  function pickThreatBullet() {
    let best = null, bestScore = -Infinity;
    for (let i = 0; i < (bulletInfo ? bulletInfo.length : 0); i++) {
      const b = bulletInfo[i];
      const dx = tank.x - b.x, dy = tank.y - b.y;
      const d = Math.hypot(dx, dy) + 1e-3;
      const dirx = dx / d, diry = dy / d;
      const rv = -(b.vx * dirx + b.vy * diry); // 양수면 접근 중
      const score = rv * (1 / d);
      if (rv > 0 && score > bestScore) { bestScore = score; best = b; }
    }
    return best;
  }

  // 팀 중심 계산
  function teamCenter() {
    let sumx = 0, sumy = 0, n = 0;
    for (let i = 0; i < allies.length; i++) { sumx += allies[i].x; sumy += allies[i].y; n++; }
    if (n === 0) return { x: tank.x, y: tank.y };
    return { x: sumx / n, y: sumy / n };
  }

  // 적 우선순위 선택: 가까움 → 체력 낮음 → 중앙에 가까움
  function pickTarget() {
    if (!enemies || enemies.length === 0) return null;
    const cx = (tank.arenaWidth || 1000) / 2, cy = (tank.arenaHeight || 1000) / 2;
    let best = null, bestKey = Infinity;
    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      const d = dist(tank.x, tank.y, e.x, e.y);
      const centerD = dist(cx, cy, e.x, e.y);
      const hp = (e.hp != null ? e.hp : 100);
      const key = d + hp * 0.5 + centerD * 0.1;
      if (key < bestKey) { bestKey = key; best = e; }
    }
    return best;
  }

  // ===== 행동안 =====
  // 1) 탄 회피 우선: 탄 궤적에 수직 이동 (보스턴 회피)
  const threat = pickThreatBullet();
  if (threat) {
    // 수직 방향 두 개 중 탱크에서 탄을 멀어지게 하는 쪽 선택
    const ang = Math.atan2(threat.vy, threat.vx);
    const a1 = wrapAngle(ang + PI/2);
    const a2 = wrapAngle(ang - PI/2);
    const nx = Math.cos(a1), ny = Math.sin(a1);
    const relx = tank.x - threat.x, rely = tank.y - threat.y;
    const away1 = nx*relx + ny*rely; // 양수면 멀어지는 성분
    const evade = away1 >= 0 ? a1 : a2;
    if (!tryMove(evade)) {
      // 보정 실패 시 미세 난수 보정
      tryMove(evade + randRange(-10*DEG, 10*DEG));
    }
  } else {
    // 2) 팀 중심을 기준으로 선두 방패: 중심 근처에서 가장 가까운 적을 향해 각도 제어
    const tgt = pickTarget();
    const center = teamCenter();
    let moveAngle = 0;
    if (tgt) {
      const toEnemy = Math.atan2(tgt.y - center.y, tgt.x - center.x);
      // 중심과 적을 잇는 선상에서 약간 앞쪽(선두) 위치를 유지
      const desiredRadius = 140; // 팀 중심으로부터 유지 반경
      const toCenter = Math.atan2(center.y - tank.y, center.x - tank.x);
      const r = dist(tank.x, tank.y, center.x, center.y);
      if (r < desiredRadius * 0.8) moveAngle = wrapAngle(toCenter - PI); // 바깥으로
      else if (r > desiredRadius * 1.2) moveAngle = toCenter; // 안쪽으로
      else moveAngle = toEnemy; // 반경 만족 시 적 방향
    } else {
      moveAngle = Math.atan2(center.y - tank.y, center.x - tank.x);
    }
    tryMove(moveAngle + randRange(-5*DEG, 5*DEG));
  }

  // 3) 사격: 최근접 적에게 짧은 리드샷, 약간의 난수화
  const target = pickTarget();
  if (target) {
    let fireAng = leadAngleSafe(tank, target, bulletSpeed);
    fireAng += randRange(-3*DEG, 3*DEG);
    tank.fire(fireAng);
  }
}



// ===== 다음 로봇 =====


// Dealer Sniper — 장거리 정밀 사격, 카이팅 및 회피 우선

function name() { return 'Dealer Sniper'; }

function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸리티 =====
  const PI = Math.PI; const TAU = Math.PI * 2; const DEG = PI / 180;
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function dist(ax, ay, bx, by) { return Math.hypot(bx - ax, by - ay); }
  function wrapAngle(a) { while (a <= -PI) a += TAU; while (a > PI) a -= TAU; return a; }
  function randRange(a, b) { return a + (b - a) * Math.random(); }
  const bulletSpeed = (tank && (tank.bulletSpeed || tank.projectileSpeed)) || 7.0;

  function leadAngle(src, dst, projSpeed) {
    const rx = dst.x - src.x, ry = dst.y - src.y;
    const dvx = (dst.vx || 0), dvy = (dst.vy || 0);
    const a = dvx*dvx + dvy*dvy - projSpeed*projSpeed;
    const b = 2 * (rx*dvx + ry*dvy);
    const c = rx*rx + ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) t = (Math.abs(b) < 1e-6) ? 0 : clamp(-c / b, 0, 2.0);
    else {
      const disc = b*b - 4*a*c; if (disc >= 0) {
        const s = Math.sqrt(disc); let t1 = (-b - s)/(2*a), t2 = (-b + s)/(2*a);
        t = Math.min(t1, t2); if (t < 0) t = Math.max(t1, t2); if (t < 0) t = 0; t = clamp(t, 0, 2.0);
      }
    }
    const ax = dst.x + (dst.vx || 0) * t; const ay = dst.y + (dst.vy || 0) * t;
    return Math.atan2(ay - src.y, ax - src.x);
  }

  function tryMove(base) {
    const step = 15 * DEG; for (let i = 0; i < 10; i++) {
      const s = (i % 2 === 0) ? 1 : -1; const k = Math.floor(i/2);
      const a = base + s * k * step; if (tank.move(a)) return true;
    } return false;
  }

  function pickThreatBullet() {
    let best=null, score=-Infinity; if (!bulletInfo) return null;
    for (let i=0;i<bulletInfo.length;i++){ const b=bulletInfo[i];
      const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-3;
      const dirx=dx/d, diry=dy/d; const rv=-(b.vx*dirx + b.vy*diry);
      const s=rv*(1/d); if (rv>0 && s>score){score=s; best=b;}
    } return best;
  }

  function pickLowHpTarget() {
    if (!enemies || enemies.length===0) return null;
    let best=null, key=Infinity; const cx=(tank.arenaWidth||1000)/2, cy=(tank.arenaHeight||1000)/2;
    for (let i=0;i<enemies.length;i++){ const e=enemies[i];
      const d=dist(tank.x,tank.y,e.x,e.y); const hp=(e.hp!=null?e.hp:100);
      const center=dist(cx,cy,e.x,e.y); const k=d*0.6 + hp*1.0 + center*0.1;
      if (k<key){key=k; best=e;}
    } return best;
  }

  // ===== 행동 =====
  const threat = pickThreatBullet();
  if (threat){
    const ang=Math.atan2(threat.vy, threat.vx);
    const perp1=ang+PI/2, perp2=ang-PI/2;
    const relx=tank.x-threat.x, rely=tank.y-threat.y;
    const dot1=Math.cos(perp1)*relx + Math.sin(perp1)*rely;
    const evade = (dot1>=0)?perp1:perp2;
    if (!tryMove(evade)) tryMove(evade + randRange(-10*DEG,10*DEG));
  } else {
    const tgt = pickLowHpTarget();
    let moveAng = 0; const orbitDir = (Math.random()<0.5)?-1:1; // 난수화 오비트 방향
    const desired = 320; // 큰 오비트 반경
    if (tgt){
      const d = dist(tank.x,tank.y,tgt.x,tgt.y);
      const toTarget = Math.atan2(tgt.y - tank.y, tgt.x - tank.x);
      if (d < desired*0.9) moveAng = wrapAngle(toTarget + PI); // 카이팅(거리 벌리기)
      else if (d > desired*1.2) moveAng = toTarget; // 진입
      else moveAng = wrapAngle(toTarget + orbitDir * 90*DEG); // 오비트 유지
    } else {
      moveAng = randRange(-PI, PI);
    }
    tryMove(moveAng + randRange(-5*DEG,5*DEG));
  }

  const target = pickLowHpTarget();
  if (target){
    const ang = leadAngle(tank, target, bulletSpeed);
    tank.fire(ang + randRange(-2*DEG, 2*DEG));
  }
}



// ===== 다음 로봇 =====


// Dealer Flanker — 측후방 침투, 원운동 오비트, 틈새 연속 사격

function name() { return 'Dealer Flanker'; }

function type() { return Type.DEALER; }

function update(tank, enemies, allies, bulletInfo) {
  // ===== 유틸 =====
  const PI=Math.PI, TAU=PI*2, DEG=PI/180; const EPS=1e-6;
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(ax,ay,bx,by){return Math.hypot(bx-ax,by-ay);} 
  function wrap(a){while(a<=-PI)a+=TAU;while(a>PI)a-=TAU;return a;}
  function rand(a,b){return a+(b-a)*Math.random();}
  const proj=(tank&&(tank.bulletSpeed||tank.projectileSpeed))||6.5;

  function lead(src,dst,speed){
    const rx=dst.x-src.x, ry=dst.y-src.y; const vx=(dst.vx||0), vy=(dst.vy||0);
    const A=vx*vx+vy*vy-speed*speed, B=2*(rx*vx+ry*vy), C=rx*rx+ry*ry; let t=0;
    if(Math.abs(A)<1e-6) t=(Math.abs(B)<1e-6)?0:clamp(-C/B,0,2.0); else {
      const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); let t1=(-B-s)/(2*A), t2=(-B+s)/(2*A);
        t=Math.min(t1,t2); if(t<0) t=Math.max(t1,t2); if(t<0) t=0; t=clamp(t,0,1.5);
      }
    }
    const ax=dst.x+vx*t, ay=dst.y+vy*t; return Math.atan2(ay-src.y, ax-src.x);
  }

  function tryMove(base){ const step=15*DEG; for(let i=0;i<10;i++){ const s=(i%2===0)?1:-1; const k=Math.floor(i/2); if(tank.move(base + s*k*step)) return true;} return false; }

  function threatBullet(){ let best=null,score=-Infinity; if(!bulletInfo) return null; for(let i=0;i<bulletInfo.length;i++){ const b=bulletInfo[i]; const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-3; const dirx=dx/d, diry=dy/d; const rv=-(b.vx*dirx + b.vy*diry); const s=rv*(1/d); if(rv>0 && s>score){score=s;best=b;}} return best; }

  function pickTarget(){ if(!enemies||enemies.length===0) return null; let best=null, key=Infinity; const cx=(tank.arenaWidth||1000)/2, cy=(tank.arenaHeight||1000)/2; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; const d=dist(tank.x,tank.y,e.x,e.y); const hp=(e.hp!=null?e.hp:100); const center=dist(cx,cy,e.x,e.y); const k=d*0.8 + hp*0.7 + center*0.1; if(k<key){key=k; best=e;}} return best; }

  // ===== 행동 =====
  // 1) 탄 회피 우선
  const th = threatBullet();
  if (th){
    const ang=Math.atan2(th.vy, th.vx); const p1=ang+PI/2, p2=ang-PI/2; const relx=tank.x-th.x, rely=tank.y-th.y; const dot1=Math.cos(p1)*relx+Math.sin(p1)*rely; const evade=(dot1>=0)?p1:p2; if(!tryMove(evade)) tryMove(evade + rand(-10*DEG,10*DEG));
  } else {
    // 2) 측후방 오비트: 타겟 기준 ±90° 방향으로 원운동, 주기적 반경 조절
    const tgt = pickTarget(); let moveAng=rand(-PI,PI); if(tgt){
      const to= Math.atan2(tgt.y - tank.y, tgt.x - tank.x);
      const orbitDir = (Math.random()<0.5)?1:-1; // 난수화 방향 플립
      const base = wrap(to + orbitDir * 90*DEG);
      // 반경 조절: 120~200 사이 왕복
      const d = dist(tank.x,tank.y,tgt.x,tgt.y);
      const minR=140, maxR=220;
      if (d < minR) moveAng = wrap(to + PI); // 벌리기
      else if (d > maxR) moveAng = to; // 좁히기
      else moveAng = base; // 원운동
    }
    tryMove(moveAng + rand(-7*DEG,7*DEG));
  }

  // 3) 연속 사격: 리드샷, 소량 난수화
  const target = (function(){
    // 근접한 적에게 우선 사격하도록 재사용
    return pickTarget();
  })();
  if (target){
    const ang = lead(tank, target, proj);
    tank.fire(ang + rand(-3*DEG,3*DEG));
  }
}



// ===== 다음 로봇 =====


// Normal Interceptor — 탄 차단 회피와 반격, 위협 점수 기반 수직 회피

function name() { return 'Normal Interceptor'; }

function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  const PI=Math.PI, TAU=PI*2, DEG=PI/180;
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(ax,ay,bx,by){return Math.hypot(bx-ax,by-ay);} 
  function wrap(a){while(a<=-PI)a+=TAU;while(a>PI)a-=TAU;return a;}
  function rand(a,b){return a+(b-a)*Math.random();}
  const proj=(tank&&(tank.bulletSpeed||tank.projectileSpeed))||6.0;

  function lead(src,dst,speed){
    const rx=dst.x-src.x, ry=dst.y-src.y; const vx=(dst.vx||0), vy=(dst.vy||0);
    const A=vx*vx+vy*vy-speed*speed, B=2*(rx*vx+ry*vy), C=rx*rx+ry*ry; let t=0;
    if(Math.abs(A)<1e-6) t=(Math.abs(B)<1e-6)?0:clamp(-C/B,0,2.0); else {
      const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); let t1=(-B-s)/(2*A), t2=(-B+s)/(2*A);
        t=Math.min(t1,t2); if(t<0) t=Math.max(t1,t2); if(t<0) t=0; t=clamp(t,0,1.2);
      }
    }
    const ax=dst.x+(dst.vx||0)*t, ay=dst.y+(dst.vy||0)*t; return Math.atan2(ay-src.y, ax-src.x);
  }

  function tryMove(base){ const step=15*DEG; for(let i=0;i<10;i++){ const s=(i%2===0)?1:-1; const k=Math.floor(i/2); if(tank.move(base + s*k*step)) return true;} return false; }

  function threatBullet(){ let best=null,score=-Infinity; if(!bulletInfo) return null; for(let i=0;i<bulletInfo.length;i++){ const b=bulletInfo[i]; const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-3; const dirx=dx/d, diry=dy/d; const rv=-(b.vx*dirx + b.vy*diry); const s=rv*(1/d); if(rv>0 && s>score){score=s;best=b;}} return best; }

  function pickTarget(){ if(!enemies||enemies.length===0) return null; let best=null,key=Infinity; const cx=(tank.arenaWidth||1000)/2, cy=(tank.arenaHeight||1000)/2; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; const d=dist(tank.x,tank.y,e.x,e.y); const hp=(e.hp!=null?e.hp:100); const center=dist(cx,cy,e.x,e.y); const k=d*0.7 + hp*0.6 + center*0.1; if(k<key){key=k; best=e;}} return best; }

  // 탄 회피 우선
  const th = threatBullet();
  if (th){
    const ang=Math.atan2(th.vy, th.vx); const p1=ang+PI/2, p2=ang-PI/2; const relx=tank.x-th.x, rely=tank.y-th.y; const dot1=Math.cos(p1)*relx + Math.sin(p1)*rely; const evade=(dot1>=0)?p1:p2; if(!tryMove(evade)) tryMove(evade + rand(-10*DEG,10*DEG));
  } else {
    // 여유 시 전진 혹은 포지션 조정
    const tgt=pickTarget(); let moveAng=rand(-PI,PI);
    if (tgt){
      const to= Math.atan2(tgt.y - tank.y, tgt.x - tank.x);
      const d = dist(tank.x,tank.y,tgt.x,tgt.y);
      const desired=200;
      if (d > desired*1.2) moveAng = to; else if (d < desired*0.8) moveAng = wrap(to + PI); else moveAng = to;
    }
    tryMove(moveAng + rand(-5*DEG,5*DEG));
  }

  const target = pickTarget();
  if (target){ tank.fire(lead(tank, target, proj) + rand(-2*DEG,2*DEG)); }
}



// ===== 다음 로봇 =====


// Normal Support — 아군 보호 및 포커스 파이어 동조, 중거리 유지

function name() { return 'Normal Support'; }

function type() { return Type.NORMAL; }

function update(tank, enemies, allies, bulletInfo) {
  const PI=Math.PI, TAU=PI*2, DEG=PI/180;
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(ax,ay,bx,by){return Math.hypot(bx-ax,by-ay);} 
  function wrap(a){while(a<=-PI)a+=TAU;while(a>PI)a-=TAU;return a;}
  function rand(a,b){return a+(b-a)*Math.random();}
  const proj=(tank&&(tank.bulletSpeed||tank.projectileSpeed))||6.5;

  function lead(src,dst,speed){
    const rx=dst.x-src.x, ry=dst.y-src.y; const vx=(dst.vx||0), vy=(dst.vy||0);
    const A=vx*vx+vy*vy-speed*speed, B=2*(rx*vx+ry*vy), C=rx*rx+ry*ry; let t=0;
    if(Math.abs(A)<1e-6) t=(Math.abs(B)<1e-6)?0:clamp(-C/B,0,2.0); else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); let t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.min(t1,t2); if(t<0) t=Math.max(t1,t2); if(t<0) t=0; t=clamp(t,0,1.5);} }
    const ax=dst.x+(dst.vx||0)*t, ay=dst.y+(dst.vy||0)*t; return Math.atan2(ay-src.y, ax-src.x);
  }

  function tryMove(base){ const step=15*DEG; for(let i=0;i<10;i++){ const s=(i%2===0)?1:-1; const k=Math.floor(i/2); if(tank.move(base + s*k*step)) return true;} return false; }

  function threatBullet(){ let best=null,score=-Infinity; if(!bulletInfo) return null; for(let i=0;i<bulletInfo.length;i++){ const b=bulletInfo[i]; const dx=tank.x-b.x, dy=tank.y-b.y; const d=Math.hypot(dx,dy)+1e-3; const dirx=dx/d, diry=dy/d; const rv=-(b.vx*dirx + b.vy*diry); const s=rv*(1/d); if(rv>0 && s>score){score=s;best=b;}} return best; }

  function teamCenter(){ let sx=0, sy=0, n=0; for(let i=0;i<allies.length;i++){sx+=allies[i].x; sy+=allies[i].y; n++;} if(n===0) return {x:tank.x, y:tank.y}; return {x:sx/n, y:sy/n}; }

  // 공통 타겟 선정 규칙: 팀 중심에 가까우며 체력이 낮고 우리와도 가까운 적
  function sharedTarget(){ if(!enemies||enemies.length===0) return null; const center=teamCenter(); let best=null,key=Infinity; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; const k=dist(center.x,center.y,e.x,e.y)*0.8 + dist(tank.x,tank.y,e.x,e.y)*0.3 + ((e.hp!=null?e.hp:100))*0.7; if(k<key){key=k; best=e;} } return best; }

  function nearestAlly(){ if(!allies||allies.length===0) return null; let best=null,dmin=Infinity; for(let i=0;i<allies.length;i++){ const a=allies[i]; const d=dist(tank.x,tank.y,a.x,a.y); if(d<dmin){dmin=d; best=a;} } return best; }

  // 1) 탄 회피 우선
  const th = threatBullet();
  if (th){
    const ang=Math.atan2(th.vy, th.vx); const p1=ang+PI/2, p2=ang-PI/2; const relx=tank.x-th.x, rely=tank.y-th.y; const dot1=Math.cos(p1)*relx + Math.sin(p1)*rely; const evade=(dot1>=0)?p1:p2; if(!tryMove(evade)) tryMove(evade + rand(-10*DEG,10*DEG));
  } else {
    // 2) 아군 중심 근처에서 보호 포지셔닝 + 공통 타겟과의 중거리 유지
    const center = teamCenter(); const ally = nearestAlly(); const tgt = sharedTarget();
    let moveAng = Math.atan2(center.y - tank.y, center.x - tank.x); // 기본은 중심 접근
    if (tgt){
      // 아군 중심과 타겟 사이에 위치하도록 각도 조절
      const toCenter = Math.atan2(center.y - tank.y, center.x - tank.x);
      const toTarget = Math.atan2(tgt.y - tank.y, tgt.x - tank.x);
      // 중간 각도로 배치
      const mid = wrap((toCenter + toTarget) / 2);
      const d = dist(tank.x,tank.y,tgt.x,tgt.y); const desired=240;
      if (d < desired*0.9) moveAng = wrap(toTarget + PI); else if (d > desired*1.1) moveAng = toTarget; else moveAng = mid;
    }
    // 가장 가까운 아군과 너무 가깝다면 살짝 벌리기
    if ( ally ){
      const dA = dist(tank.x,tank.y,ally.x,ally.y); if (dA < 60) moveAng = wrap(moveAng + 30*DEG);
    }
    tryMove(moveAng + rand(-5*DEG,5*DEG));
  }

  const target = sharedTarget(); if (target){ tank.fire( lead(tank, target, proj) + rand(-2*DEG,2*DEG) ); }
}



// ===== 다음 로봇 =====


// Tanker Bruiser — 전면 압박, 벽-슬라이딩, 지속 사격, 지그재그 회피

function name() { return 'Tanker Bruiser'; }

function type() { return Type.TANKER; }

function update(tank, enemies, allies, bulletInfo) {
  const PI=Math.PI, TAU=PI*2, DEG=PI/180; const EPS=1e-6;
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function dist(ax,ay,bx,by){return Math.hypot(bx-ax,by-ay);} 
  function wrap(a){while(a<=-PI)a+=TAU;while(a>PI)a-=TAU;return a;}
  function rand(a,b){return a+(b-a)*Math.random();}
  const proj=(tank&&(tank.bulletSpeed||tank.projectileSpeed))||6.0;

  function lead(src,dst,speed){
    const rx=dst.x-src.x, ry=dst.y-src.y; const vx=(dst.vx||0), vy=(dst.vy||0);
    const A=vx*vx+vy*vy-speed*speed, B=2*(rx*vx+ry*vy), C=rx*rx+ry*ry; let t=0;
    if(Math.abs(A)<1e-6) t=(Math.abs(B)<1e-6)?0:clamp(-C/B,0,1.5); else { const D=B*B-4*A*C; if(D>=0){ const s=Math.sqrt(D); let t1=(-B-s)/(2*A), t2=(-B+s)/(2*A); t=Math.min(t1,t2); if(t<0) t=Math.max(t1,t2); if(t<0) t=0; t=clamp(t,0,1.0);} }
    const ax=dst.x+(dst.vx||0)*t, ay=dst.y+(dst.vy||0)*t; return Math.atan2(ay-src.y, ax-src.x);
  }

  function tryMove(base){ const step=15*DEG; for(let i=0;i<10;i++){ const s=(i%2===0)?1:-1; const k=Math.floor(i/2); if(tank.move(base + s*k*step)) return true;} return false; }

  function pickTarget(){ if(!enemies||enemies.length===0) return null; let best=null,key=Infinity; for(let i=0;i<enemies.length;i++){ const e=enemies[i]; const d=dist(tank.x,tank.y,e.x,e.y); const hp=(e.hp!=null?e.hp:100); const k=d*0.8 + hp*0.4; if(k<key){key=k; best=e;}} return best; }

  function nearWall(){ const W=tank.arenaWidth||1000, H=tank.arenaHeight||1000; const m=50; const left=tank.x<m, right=(W-tank.x)<m, top=tank.y<m, bottom=(H-tank.y)<m; return {left,right,top,bottom,W,H}; }

  // 1) 기본 전진 압박: 타겟 향해 이동하되 지그재그로 예측 회피
  const tgt = pickTarget();
  let moveAng = rand(-PI,PI);
  if (tgt){
    const to = Math.atan2(tgt.y - tank.y, tgt.x - tank.x);
    const d = dist(tank.x,tank.y,tgt.x,tgt.y);
    const desired = 180; // 중근거리 유지
    const zig = (Math.random()<0.5? -1:1) * rand(12*DEG, 25*DEG); // 간헐적 좌우 지그재그
    if (d > desired*1.2) moveAng = wrap(to + zig);
    else if (d < desired*0.8) moveAng = wrap(to + PI + zig*0.5);
    else moveAng = wrap(to + zig);
  }

  // 2) 벽-슬라이딩: 벽 근접 시 벽과 평행한 방향으로 수정
  const w = nearWall();
  if (w.left || w.right) {
    // 수직 벽이면 수평 이동 유지: 위/아래로 슬라이딩
    const up = -PI/2, down = PI/2;
    // 타겟이 더 가까워지는 쪽 선택
    let a1 = up, a2 = down;
    if (tgt){
      const d1 = dist(tank.x + Math.cos(a1)*10, tank.y + Math.sin(a1)*10, tgt.x, tgt.y);
      const d2 = dist(tank.x + Math.cos(a2)*10, tank.y + Math.sin(a2)*10, tgt.x, tgt.y);
      moveAng = (d1<d2)?a1:a2;
    } else moveAng = (Math.random()<0.5)?up:down;
  } else if (w.top || w.bottom) {
    // 수평 벽이면 좌/우로 슬라이딩
    const left = Math.PI, right = 0;
    let a1 = right, a2 = left;
    if (tgt){
      const d1 = dist(tank.x + Math.cos(a1)*10, tank.y + Math.sin(a1)*10, tgt.x, tgt.y);
      const d2 = dist(tank.x + Math.cos(a2)*10, tank.y + Math.sin(a2)*10, tgt.x, tgt.y);
      moveAng = (d1<d2)?a1:a2;
    } else moveAng = (Math.random()<0.5)?left:right;
  }

  tryMove(moveAng);

  // 3) 지속 사격(리드샷, 소량 난수화)
  if (tgt){ tank.fire( lead(tank, tgt, proj) + rand(-3*DEG,3*DEG) ); }
}

