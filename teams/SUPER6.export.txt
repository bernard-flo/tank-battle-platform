function name() { return "Tanker Guardian"; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  // 유틸리티 (파일 내부 한정)
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function dist(ax, ay, bx, by){ return Math.hypot(ax-bx, ay-by); }
  function angleTo(ax, ay, bx, by){ return Math.atan2(by - ay, bx - ax) * 180/Math.PI; }
  function norm(a){ a%=360; return a<0?a+360:a; }
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    // 벽/충돌 시 소폭 보정 재시도
    for (let d=10; d<=40; d+=10){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function mostDangerousBullet() {
    let best = null;
    let bestScore = -Infinity;
    for (const b of bulletInfo) {
      const rx = tank.x - b.x, ry = tank.y - b.y;
      const vx = b.vx, vy = b.vy;
      const vv = vx*vx + vy*vy;
      if (vv === 0) continue;
      const t = -(rx*vx + ry*vy)/vv; // 최근접 시점
      if (t < 0) continue; // 멀어지는 탄은 무시
      const cx = rx + vx*t, cy = ry + vy*t;
      const cd = Math.hypot(cx, cy);
      const score = 1000/(1+cd) + 0.5/(1+t);
      if (score > bestScore) { bestScore = score; best = {b, t, cd}; }
    }
    return best;
  }

  // 1) 회피 우선
  const threat = mostDangerousBullet();
  if (threat && threat.cd < (tank.size/2 + 20)) {
    const dir = Math.atan2(threat.b.vy, threat.b.vx) * 180/Math.PI;
    // 탄 궤적 수직 방향으로 이동, 약간의 난수화
    const offset = (Math.random()<0.5? -90: 90) + (Math.random()-0.5)*12;
    tryMoveDir(dir + offset);
  } else if (enemies.length) {
    // 2) 선두 방패: 최근접 적에게 각도 우선 확보(짧은 리드샷)
    let target = enemies[0];
    for (const e of enemies) if (e.distance < target.distance) target = e;

    // 접근: 과도한 근접은 피하고, 탱커답게 중근거리(120~220)
    const desired = clamp(target.distance - 170, -180, 180);
    const dirTo = angleTo(tank.x, tank.y, target.x, target.y);
    const moveDir = desired > 0 ? dirTo : norm(dirTo + 180);
    tryMoveDir(moveDir + (Math.random()-0.5)*10);

    // 짧은 리드샷: 거리 기반 소폭 보정
    const lead = clamp(target.distance/20, -12, 12) * (Math.random()<0.5?1:-1);
    tank.fire(norm(dirTo + lead));
  } else {
    // 대기 중 랜덤 드리프트로 포지션 조정
    tryMoveDir(Math.random()*360);
  }
}



// ===== 다음 로봇 =====

function name() { return "Dealer Sniper"; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function norm(a){a%=360;return a<0?a+360:a;}
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    for (let d=8; d<=32; d+=8){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function mostDangerousBullet(){
    let best=null,bestScore=-1;
    for (const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const vx=b.vx, vy=b.vy; const vv=vx*vx+vy*vy; if(!vv) continue;
      const t=-(rx*vx+ry*vy)/vv; if(t<0) continue; const cx=rx+vx*t, cy=ry+vy*t; const cd=Math.hypot(cx,cy);
      const sc=1200/(1+cd)+0.6/(1+t); if(sc>bestScore){bestScore=sc; best={b,cd,t};}
    }
    return best;
  }

  // 장거리 카이팅: 위협 우선 회피 -> 최대 사거리 유지 -> 정밀 사격
  const threat = mostDangerousBullet();
  if (threat && threat.cd < (tank.size/2 + 24)){
    const dir = Math.atan2(threat.b.vy, threat.b.vx)*180/Math.PI;
    const offset = (Math.random()<0.5?-90:90) + (Math.random()-0.5)*10;
    tryMoveDir(dir + offset);
  }

  if (enemies.length){
    // 타겟: 체력 낮음 우선, 동률이면 원거리 유지가 쉬운 대상
    let target = enemies[0];
    for (const e of enemies){
      if (e.health < target.health - 5) target = e; else if (Math.abs(e.health - target.health) <= 5 && e.distance > target.distance) target = e;
    }
    const dirTo = angleTo(tank.x,tank.y,target.x,target.y);
    // 거리 밸런스: 260~360 선호
    const preferMin=260, preferMax=360;
    let moveDir = dirTo;
    if (target.distance < preferMin) moveDir = norm(dirTo + 180); // 벌리기
    else if (target.distance > preferMax) moveDir = dirTo; // 추적
    else moveDir = norm(dirTo + (Math.random()<0.5?90:-90)); // 측면 유지
    tryMoveDir(moveDir + (Math.random()-0.5)*8);

    // 사격: 작은 리드와 분산
    const jitter = (Math.random()-0.5)*8;
    const lead = clamp(target.distance/18, -14, 14) * (Math.random()<0.5?1:-1);
    tank.fire(norm(dirTo + lead + jitter));
  } else {
    tryMoveDir(Math.random()*360);
  }
}



// ===== 다음 로봇 =====

function name() { return "Dealer Flanker"; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function norm(a){a%=360; return a<0?a+360:a;}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    for (let d=10; d<=40; d+=10){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function mostDangerousBullet(){
    let best=null,score=-1;
    for(const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const vx=b.vx, vy=b.vy; const vv=vx*vx+vy*vy; if(!vv) continue;
      const t=-(rx*vx+ry*vy)/vv; if (t<0) continue; const cx=rx+vx*t, cy=ry+vy*t; const cd=Math.hypot(cx,cy);
      const sc=900/(1+cd)+0.5/(1+t); if (sc>score){score=sc; best={b,cd,t};}
    }
    return best;
  }

  // 위협 회피 우선
  const threat = mostDangerousBullet();
  if (threat && threat.cd < (tank.size/2 + 18)){
    const dir = Math.atan2(threat.b.vy, threat.b.vx)*180/Math.PI;
    tryMoveDir(dir + (Math.random()<0.5? -90:90));
  }

  if (enemies.length){
    let target = enemies[0]; for (const e of enemies) if (e.distance < target.distance) target = e;
    const to = angleTo(tank.x,tank.y,target.x,target.y);
    // 오비트: 타겟 법선 방향으로 원운동. 반경은 160~240를 들쑥날쑥 유지
    const prefer = 200 + (Math.random()-0.5)*80;
    let moveDir = norm(to + (Math.random()<0.55? 90: -90));
    if (target.distance < prefer - 30) moveDir = norm(to + 180); // 거리를 벌려 반경 회복
    if (target.distance > prefer + 30) moveDir = to;            // 반경 안으로 진입
    tryMoveDir(moveDir + (Math.random()-0.5)*8);

    // 사격: 오비트 방향으로 약간 앞을 긁는 리드
    const sweep = (moveDir - to); // +90/-90 근사
    const lead = clamp((target.distance/22), -10, 10) * Math.sign(sweep || 1);
    const jitter = (Math.random()-0.5)*6;
    tank.fire(norm(to + lead + jitter));
  } else {
    tryMoveDir(Math.random()*360);
  }
}



// ===== 다음 로봇 =====

function name() { return "Normal Interceptor"; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function norm(a){a%=360;return a<0?a+360:a;}
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    for (let d=12; d<=48; d+=12){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function threatScore(b){
    const rx=tank.x-b.x, ry=tank.y-b.y; const vx=b.vx, vy=b.vy; const vv=vx*vx+vy*vy; if(!vv) return -1;
    const closing=-(rx*vx+ry*vy)/Math.sqrt(vv); // 접근 성분
    const t=-(rx*vx+ry*vy)/vv; // 최근접 시간
    const cx=rx+vx*Math.max(0,t), cy=ry+vy*Math.max(0,t);
    const cd=Math.hypot(cx,cy);
    return (closing>0? closing:0)/(1+cd) + 0.6/(1+Math.max(0,t));
  }
  function mostDangerousBullet(){
    let best=null, bs=-1;
    for(const b of bulletInfo){
      const s=threatScore(b); if (s>bs){bs=s; best=b;}
    }
    return best;
  }

  // 1) 가장 위협적인 탄에 수직 회피
  const b = mostDangerousBullet();
  if (b){
    const dir = Math.atan2(b.vy,b.vx)*180/Math.PI;
    const offset = (Math.random()<0.5? -90:90) + (Math.random()-0.5)*12;
    tryMoveDir(dir + offset);
  }

  // 2) 반격: 최근접 적에게 약한 리드샷
  if (enemies.length){
    let target=enemies[0]; for(const e of enemies) if(e.distance<target.distance) target=e;
    const to = angleTo(tank.x,tank.y,target.x,target.y);
    const lead = Math.min(10, target.distance/25) * (Math.random()<0.5?1:-1);
    tank.fire(norm(to + lead + (Math.random()-0.5)*5));
  }
}



// ===== 다음 로봇 =====

function name() { return "Normal Support"; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function norm(a){a%=360;return a<0?a+360:a;}
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    for (let d=10; d<=40; d+=10){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function centroid(points){
    if (!points.length) return {x:tank.x, y:tank.y};
    let sx= tank.x, sy=tank.y, c=1;
    for(const p of points){ sx+=p.x; sy+=p.y; c++; }
    return {x:sx/c, y:sy/c};
  }
  function mostDangerousBullet(){
    let best=null,score=-1; for(const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const vx=b.vx, vy=b.vy; const vv=vx*vx+vy*vy; if(!vv) continue;
      const t=-(rx*vx+ry*vy)/vv; if(t<0) continue; const cx=rx+vx*t, cy=ry+vy*t; const cd=Math.hypot(cx,cy);
      const sc=1000/(1+cd)+0.5/(1+t); if(sc>score){score=sc; best={b,cd,t};}
    } return best;
  }

  // 1) 아군 중심 방어 포지셔닝 + 위협 회피
  const allyCenter = centroid(allies);
  const threat = mostDangerousBullet();
  if (threat && threat.cd < (tank.size/2 + 20)){
    const dir = Math.atan2(threat.b.vy, threat.b.vx)*180/Math.PI;
    tryMoveDir(dir + (Math.random()<0.5? -90:90));
  } else if (enemies.length){
    // 공통 타겟: 아군 중심에서 가장 가까운 적
    let focus = enemies[0];
    let bestd = Math.hypot(enemies[0].x - allyCenter.x, enemies[0].y - allyCenter.y);
    for (const e of enemies){
      const d = Math.hypot(e.x - allyCenter.x, e.y - allyCenter.y);
      if (d < bestd) { bestd = d; focus = e; }
    }

    // 중거리(200~300) 유지하며 중심과 각도 정렬
    const to = angleTo(tank.x,tank.y,focus.x,focus.y);
    let moveDir = to;
    if (focus.distance < 200) moveDir = norm(to + 180);
    else if (focus.distance > 300) moveDir = to;
    else moveDir = norm(angleTo(tank.x,tank.y,allyCenter.x,allyCenter.y)); // 중심 정렬
    tryMoveDir(moveDir + (Math.random()-0.5)*8);

    // 포커스 파이어: 소폭 지터
    const jitter = (Math.random()-0.5)*6;
    tank.fire(norm(to + jitter));
  } else {
    tryMoveDir(Math.random()*360);
  }
}



// ===== 다음 로봇 =====

function name() { return "Tanker Bruiser"; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function angleTo(ax,ay,bx,by){return Math.atan2(by-ay,bx-ax)*180/Math.PI;}
  function norm(a){a%=360;return a<0?a+360:a;}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function tryMoveDir(dir){
    dir = norm(dir);
    if (tank.move(dir)) return true;
    // 벽-슬라이딩: 평행 방향으로 재시도
    for (let d of [15,30,45]){
      if (tank.move(norm(dir + d))) return true;
      if (tank.move(norm(dir - d))) return true;
    }
    return false;
  }
  function mostDangerousBullet(){
    let best=null,score=-1; for(const b of bulletInfo){
      const rx=tank.x-b.x, ry=tank.y-b.y; const vx=b.vx, vy=b.vy; const vv=vx*vx+vy*vy; if(!vv) continue;
      const t=-(rx*vx+ry*vy)/vv; if(t<0) continue; const cx=rx+vx*t, cy=ry+vy*t; const cd=Math.hypot(cx,cy);
      const sc=900/(1+cd)+0.5/(1+t); if(sc>score){score=sc; best={b,cd,t};}
    } return best;
  }

  // 1) 위협 회피(가벼운 지그재그 유지)
  const threat = mostDangerousBullet();
  if (threat && threat.cd < (tank.size/2 + 22)){
    const dir = Math.atan2(threat.b.vy, threat.b.vx)*180/Math.PI;
    const zig = (Math.random()<0.5? -1:1) * (10 + Math.random()*10);
    tryMoveDir(dir + 90 + zig);
  }

  // 2) 압박 전진: 최근접 적에게 접근, 소폭 지그재그로 예측 회피
  if (enemies.length){
    let t = enemies[0]; for(const e of enemies) if(e.distance<t.distance) t=e;
    const to = angleTo(tank.x,tank.y,t.x,t.y);
    const zig = (Math.random()<0.5? -1:1) * (8 + Math.random()*10);
    const desired = t.distance > 140 ? to : norm(to + 180); // 너무 붙으면 살짝 이탈
    tryMoveDir(desired + zig);

    const lead = clamp(t.distance/24, -12, 12) * (Math.random()<0.5?1:-1);
    tank.fire(norm(to + lead + (Math.random()-0.5)*6));
  } else {
    tryMoveDir(Math.random()*360);
  }
}



// ===== 다음 로봇 =====

