function name(){return "Aegis";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  // 도우미
  const W=900,H=600; const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  // 목표: 저체력+가까움 가중
  let tgt=null,b=1e9; for(const e of enemies){const s=e.distance*0.85 + (e.health||0)*0.4; if(s<b){b=s;tgt=e;}}
  // 총알 회피: 접근하는 탄을 수직 회피
  let evx=0,evy=0; for(const bl of bulletInfo){const rx=bl.x-tank.x, ry=bl.y-tank.y; const bv=Math.hypot(bl.vx,bl.vy)||1e-6; const ux=bl.vx/bv, uy=bl.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const t=d/bv; const w=dot/(1+0.05*d+0.02*t*t); evx+=px*w; evy+=py*w;}}
  ;[evx,evy]=norm(evx,evy);
  // 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  // 아군 분리(겹침 방지) + 느슨한 응집(라인 유지)
  let sx=0,sy=0,cx=0,cy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<85){sx+=dx/(d*d); sy+=dy/(d*d);} cx+=a.x; cy+=a.y;} if(allies.length){cx=cx/allies.length - tank.x; cy=cy/allies.length - tank.y; ;[cx,cy]=norm(cx,cy);} ;[sx,sy]=norm(sx,sy);
  // 타겟 기반: 접근 + 공전(측면)
  let ax=0,ay=0, ox=0,oy=0, dist=1; if(tgt){ax=tgt.x-tank.x; ay=tgt.y-tank.y; dist=Math.hypot(ax,ay)||1; ax/=dist; ay/=dist; ox=-ay; oy=ax;}
  // 체력 낮으면 후퇴
  let rx=0,ry=0; if(tank.health < tank.energy*0.25 && tgt){rx=-ax; ry=-ay; ;[rx,ry]=norm(rx,ry);} 
  // 가중치(탱커): 전면 압박, 강한 회피, 약간의 공전으로 어그로 유지
  const wEv=0.35, wWall=0.12, wA=0.55, wO=0.25, wSep=0.18, wCoh=0.06, wRt=0.50;
  // 거리별 조정
  const near = dist<150 ? 1:0, far=dist>260 ? 1:0; const Aeff = wA*(far?1.1:(near?0.8:1.0)); const Oeff=wO*(near?1.25:1.0);
  const mvx = evx*wEv + wx*wWall + ax*Aeff + ox*Oeff + sx*wSep + cx*wCoh + rx*wRt;
  const mvy = evy*wEv + wy*wWall + ay*Aeff + oy*Oeff + sy*wSep + cy*wCoh + ry*wRt;
  const mvAng = ang(mvx,mvy);
  // 사격: 직접 조준 + 소량 지터로 분산 사격 억제
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*2; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Bulwark";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  let tgt=null,score=1e9; for(const e of enemies){const s=e.distance*0.8 + (e.health||0)*0.5; if(s<score){score=s;tgt=e;}}
  let evx=0,evy=0; for(const b of bulletInfo){const rx=b.x-tank.x, ry=b.y-tank.y; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const w=dot/(1+0.06*d); evx+=px*w; evy+=py*w;}} ;[evx,evy]=norm(evx,evy);
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  let sx=0,sy=0,cx=0,cy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<85){sx+=dx/(d*d); sy+=dy/(d*d);} cx+=a.x; cy+=a.y;} if(allies.length){cx=cx/allies.length - tank.x; cy=cy/allies.length - tank.y; ;[cx,cy]=norm(cx,cy);} ;[sx,sy]=norm(sx,sy);
  let ax=0,ay=0,ox=0,oy=0,dist=1; if(tgt){ax=tgt.x-tank.x; ay=tgt.y-tank.y; dist=Math.hypot(ax,ay)||1; ax/=dist; ay/=dist; ox=-ay; oy=ax;}
  let rx=0,ry=0; if(tank.health<tank.energy*0.2 && tgt){rx=-ax; ry=-ay; ;[rx,ry]=norm(rx,ry);} 
  const wEv=0.32, wWall=0.10, wA=0.6, wO=0.22, wSep=0.2, wCoh=0.05, wRt=0.55;
  const near=dist<140?1:0, far=dist>250?1:0; const Aeff=wA*(far?1.1:(near?0.8:1.0)); const Oeff=wO*(near?1.3:1.0);
  const mvx=evx*wEv + wx*wWall + ax*Aeff + ox*Oeff + sx*wSep + cx*wCoh + rx*wRt;
  const mvy=evy*wEv + wy*wWall + ay*Aeff + oy*Oeff + sy*wSep + cy*wCoh + ry*wRt;
  const mvAng=ang(mvx,mvy);
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*1.2; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Viper";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  // 목표: 저체력 가장 낮은 적 우선
  let tgt=null,b=1e9; for(const e of enemies){const s=e.health*0.8 + e.distance*0.3; if(s<b){b=s;tgt=e;}}
  // 탄 회피 우선 강하게
  let evx=0,evy=0; for(const bl of bulletInfo){const rx=bl.x-tank.x, ry=bl.y-tank.y; const bv=Math.hypot(bl.vx,bl.vy)||1e-6; const ux=bl.vx/bv, uy=bl.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const t=d/bv; const w=dot/(1+0.03*d+0.03*t); evx+=px*w; evy+=py*w;}} ;[evx,evy]=norm(evx,evy);
  // 벽 회피
  let wx=0,wy=0; const m=70; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  // 최적 거리 유지(220~280) + 공전
  let ax=0,ay=0,ox=0,oy=0,dist=1; if(tgt){ax=tgt.x-tank.x; ay=tgt.y-tank.y; dist=Math.hypot(ax,ay)||1; ax/=dist; ay/=dist; ox=-ay; oy=ax;}
  let kx=0,ky=0; if(tgt){ const pref=250; const diff=dist-pref; kx=-ax*diff; ky=-ay*diff; ;[kx,ky]=norm(kx,ky);} // 거리 유지
  // 아군 분리
  let sx=0,sy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<80){sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=norm(sx,sy);
  const wEv=0.55, wWall=0.08, wKeep=0.45, wOrb=0.45, wSep=0.18;
  const near=dist<170?1:0, far=dist>300?1:0; const Keff=wKeep*(near?1.35:(far?0.9:1.0)); const Oeff=wOrb*(near?1.2:1.0);
  const mvx=evx*wEv + wx*wWall + kx*Keff + ox*Oeff + sx*wSep;
  const mvy=evy*wEv + wy*wWall + ky*Keff + oy*Oeff + sy*wSep;
  const mvAng=ang(mvx,mvy);
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*0.8; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Falcon";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  let tgt=null,s=1e9; for(const e of enemies){const v=e.health*0.9 + e.distance*0.25; if(v<s){s=v;tgt=e;}}
  let evx=0,evy=0; for(const b of bulletInfo){const rx=b.x-tank.x, ry=b.y-tank.y; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const w=dot/(1+0.04*d); evx+=px*w; evy+=py*w;}} ;[evx,evy]=norm(evx,evy);
  let wx=0,wy=0; const m=70; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  let ax=0,ay=0,ox=0,oy=0,dist=1; if(tgt){ax=tgt.x-tank.x; ay=tgt.y-tank.y; dist=Math.hypot(ax,ay)||1; ax/=dist; ay/=dist; ox=-ay; oy=ax;}
  let kx=0,ky=0; if(tgt){ const pref=240; const diff=dist-pref; kx=-ax*diff; ky=-ay*diff; ;[kx,ky]=norm(kx,ky);} 
  let sx=0,sy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<78){sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=norm(sx,sy);
  const wEv=0.52, wWall=0.08, wKeep=0.42, wOrb=0.48, wSep=0.18;
  const near=dist<170?1:0, far=dist>300?1:0; const Keff=wKeep*(near?1.35:(far?0.9:1.0)); const Oeff=wOrb*(near?1.2:1.0);
  const mvx=evx*wEv + wx*wWall + kx*Keff + ox*Oeff + sx*wSep;
  const mvy=evy*wEv + wy*wWall + ky*Keff + oy*Oeff + sy*wSep;
  const mvAng=ang(mvx,mvy);
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*0.7; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Sentinel";}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  let tgt=null,b=1e9; for(const e of enemies){const s=e.distance*0.8 + (e.health||0)*0.35; if(s<b){b=s;tgt=e;}}
  let evx=0,evy=0; for(const bl of bulletInfo){const rx=bl.x-tank.x, ry=bl.y-tank.y; const bv=Math.hypot(bl.vx,bl.vy)||1e-6; const ux=bl.vx/bv, uy=bl.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const w=dot/(1+0.05*d); evx+=px*w; evy+=py*w;}} ;[evx,evy]=norm(evx,evy);
  let wx=0,wy=0; const m=65; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  let ax=0,ay=0,ox=0,oy=0,dist=1; if(tgt){ax=tgt.x-tank.x; ay=tgt.y-tank.y; dist=Math.hypot(ax,ay)||1; ax/=dist; ay/=dist; ox=-ay; oy=ax;}
  let sx=0,sy=0,cx=0,cy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<80){sx+=dx/(d*d); sy+=dy/(d*d);} cx+=a.x; cy+=a.y;} if(allies.length){cx=cx/allies.length - tank.x; cy=cy/allies.length - tank.y; ;[cx,cy]=norm(cx,cy);} ;[sx,sy]=norm(sx,sy);
  const wEv=0.4, wWall=0.1, wA=0.45, wO=0.35, wSep=0.2, wCoh=0.1;
  const mvx=evx*wEv + wx*wWall + ax*wA + (-ay)*wO + sx*wSep + cx*wCoh;
  const mvy=evy*wEv + wy*wWall + ay*wA + (ax)*wO + sy*wSep + cy*wCoh;
  const mvAng=ang(mvx,mvy);
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*1.0; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Guardian";}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const ang=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return [x/m,y/m];};
  // 적 중심과 아군 중심 기반의 라인전
  let ex=0,ey=0; for(const e of enemies){ex+=e.x; ey+=e.y;} if(enemies.length){ex/=enemies.length; ey/=enemies.length;}
  let axc=0,ayc=0; for(const a of allies){axc+=a.x; ayc+=a.y;} if(allies.length){axc/=allies.length; ayc/=allies.length;}
  // 목표: 적 중심에서 가장 가까운 적
  let tgt=null,bd=1e9; for(const e of enemies){const d=Math.hypot(e.x-ex,e.y-ey); const s=d*0.7 + e.health*0.5; if(s<bd){bd=s;tgt=e;}}
  let evx=0,evy=0; for(const bl of bulletInfo){const rx=bl.x-tank.x, ry=bl.y-tank.y; const bv=Math.hypot(bl.vx,bl.vy)||1e-6; const ux=bl.vx/bv, uy=bl.vy/bv; const dot=rx*ux+ry*uy; if(dot>0){const d=Math.hypot(rx,ry)||1e-6; const px=-uy, py=ux; const w=dot/(1+0.05*d); evx+=px*w; evy+=py*w;}} ;[evx,evy]=norm(evx,evy);
  let wx=0,wy=0; const m=65; if(tank.x<m) wx+=1-tank.x/m; if(W-tank.x<m) wx-=1-(W-tank.x)/m; if(tank.y<m) wy+=1-tank.y/m; if(H-tank.y<m) wy-=1-(H-tank.y)/m; ;[wx,wy]=norm(wx,wy);
  let lx=axc-tank.x, ly=ayc-tank.y; ;[lx,ly]=norm(lx,ly);
  let gx=ex-tank.x, gy=ey-tank.y; ;[gx,gy]=norm(gx,gy);
  let sx=0,sy=0; for(const a of allies){const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1e-6; if(d<82){sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=norm(sx,sy);
  const wEv=0.42, wWall=0.1, wLine=0.25, wPress=0.35, wSep=0.2;
  const mvx=evx*wEv + wx*wWall + lx*wLine + gx*wPress + sx*wSep;
  const mvy=evy*wEv + wy*wWall + ly*wLine + gy*wPress + sy*wSep;
  const mvAng=ang(mvx,mvy);
  if(tgt){ const aim=ang(tgt.x-tank.x,tgt.y-tank.y); const jitter=(Math.random()-0.5)*0.9; tank.fire(aim+jitter); }
  if(!tank.move(mvAng)){ if(!tank.move(mvAng+70)){ if(!tank.move(mvAng-70)){ tank.move(Math.random()*360); }}}
}
