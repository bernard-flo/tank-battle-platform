function name(){return "Aegis-1";}
function type(){return 1;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":187.48252715215136,"rMax":290.66398344513124,"strafe":25.90150944693972,"threatR":103.50261210207951,"fleeBias":10.545693408688397,"sep":77.76820230560804,"edge":64.02650610435204,"leadCap":18.063867518419364,"leadW":0.8665657232311935,"aimJitter":0.10079761000326161,"healthW":1.0046951324150863,"distW":0.227430170186894,"finisherHP":28.106530882936653,"aggrRemain":1.1268080520870427,"aggrIn":19.42270091390884,"aggrOut":15.93086875869544,"bias":4.868787928179755};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+1)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((1+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+3)%360)+P.bias; trySet([r, r+120, r-120]);
}


// ===== 다음 로봇 =====

function name(){return "Aegis-2";}
function type(){return 1;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":194.73189053556848,"rMax":312.07287567247675,"strafe":14.487032125313732,"threatR":106.96554109149132,"fleeBias":16.068381136380303,"sep":70.16252360455178,"edge":48.04939384507195,"leadCap":18.528020026683272,"leadW":0.9182476372302892,"aimJitter":0.03421345881763842,"healthW":1.01867851971839,"distW":0.24315530915190905,"finisherHP":33.81303976240753,"aggrRemain":1.515925217134273,"aggrIn":6.822776164677094,"aggrOut":13.42744274350116,"bias":8.638428463167287};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+2)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((2+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+4)%360)+P.bias; trySet([r, r+120, r-120]);
}


// ===== 다음 로봇 =====

function name(){return "Aegis-3";}
function type(){return 0;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":231.10306830773823,"rMax":316.6165049163002,"strafe":33.33113062406858,"threatR":126.86627346599205,"fleeBias":21.515294519388725,"sep":82.94849913603957,"edge":60.45332262397601,"leadCap":15.947114021224746,"leadW":0.9604618874273864,"aimJitter":0.15900212694563196,"healthW":1.150370454284864,"distW":0.27390970546255955,"finisherHP":29.956056545723627,"aggrRemain":0.6204673048366034,"aggrIn":12.148449010516785,"aggrOut":16.944817762838113,"bias":-15.24489790643625};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+3)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((3+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+5)%360)+P.bias; trySet([r, r+120, r-120]);
}


// ===== 다음 로봇 =====

function name(){return "Aegis-4";}
function type(){return 0;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":217.31947066244743,"rMax":343.2450938620901,"strafe":34.7388530218298,"threatR":125.91134541648299,"fleeBias":25.483935558775272,"sep":64.30120948123465,"edge":52.65933588869615,"leadCap":16.515502416114693,"leadW":0.7873728624294646,"aimJitter":0.13759886813509917,"healthW":1.1393311836537283,"distW":0.16770309582875229,"finisherHP":24.285127740562075,"aggrRemain":3.1526554020984516,"aggrIn":18.04153405125564,"aggrOut":19.961195628597295,"bias":16.705267534423};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+4)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((4+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+6)%360)+P.bias; trySet([r, r+120, r-120]);
}


// ===== 다음 로봇 =====

function name(){return "Aegis-5";}
function type(){return 2;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":215.30233091044886,"rMax":341.7378964845228,"strafe":20.848190114919944,"threatR":143.26204496205787,"fleeBias":8.40268296562391,"sep":69.61617180519724,"edge":66.90286003423206,"leadCap":14.21020561483196,"leadW":0.779345830216858,"aimJitter":0.034977152552501334,"healthW":0.9094388036448382,"distW":0.30223094636118875,"finisherHP":24.59764102794962,"aggrRemain":2.047249604362335,"aggrIn":13.235135331134686,"aggrOut":20.045046458780078,"bias":13.460459007150831};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+5)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((5+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+7)%360)+P.bias; trySet([r, r+120, r-120]);
}


// ===== 다음 로봇 =====

function name(){return "Aegis-6";}
function type(){return 2;}
let __s={last:null,lastVel:null,tick:0,aggr:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI, H=Math.hypot;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;}, clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const P={"rMin":236.60878152806833,"rMax":306.60878152806833,"strafe":48.710648446908934,"threatR":123.27380314751477,"fleeBias":18.537906366012486,"sep":67.270172747147,"edge":50.51279260306859,"leadCap":13.282554883837179,"leadW":0.8119793395570912,"aimJitter":0.19580682143424227,"healthW":1.1078878794131966,"distW":0.2152151697541146,"finisherHP":36.00315734003274,"aggrRemain":0.4482748514878778,"aggrIn":8.034775317638633,"aggrOut":23.053130259943174,"bias":14.128852781538797};
  __s.tick=(__s.tick||0)+1; __s.aggr=Math.max(0,(__s.aggr||0)-1);

  // Target selection: prioritize low HP and closer distance
  let tgt=null,b=1e9; for(const e of enemies){ const score=e.health*P.healthW + e.distance*P.distW; if(score<b){b=score;tgt=e;} }
  if(tgt){
    // Predictive fire with smoothed velocity estimate and capped lead time
    let ax=tgt.x, ay=tgt.y;
    if(__s.last){
      const vx=tgt.x-__s.last.x, vy=tgt.y-__s.last.y;
      const lvx=__s.lastVel?__s.lastVel.vx:0, lvy=__s.lastVel?__s.lastVel.vy:0;
      const svx=lvx*0.6+vx*0.4, svy=lvy*0.6+vy*0.4; __s.lastVel={vx:svx,vy:svy};
      const d=H(tgt.x-tank.x,tgt.y-tank.y); const t=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadW*t; ay=tgt.y+svy*P.leadW*t;
    }
    const jitter=(((__s.tick*31+6)%23)-11)*0.07*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter);
    __s.last={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};
  const trySet=(arr)=>{ for(const a of arr){ if(go(a)) return true; } return false; };

  // Bullet avoidance: consider bullets with positive closing projection and small miss distance
  let hot=null,minR=1e9; for(const bu of bulletInfo){ const dx=bu.x-tank.x, dy=bu.y-tank.y; const v=H(bu.vx,bu.vy)||1; const nx=bu.vx/v, ny=bu.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=bu.x-proj*nx, py=bu.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<minR && d<P.threatR){minR=d;hot=bu;} } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side=((6+1)%2?1:-1)*P.fleeBias + P.bias*0.6; if(trySet([a+90+side,a-90-side,a+130,a-130,a+70,a-70])) return; }

  // Edge avoidance (prefer turning inward)
  if(tank.x<P.edge){ if(go(0))return; } if(tank.x>900-P.edge){ if(go(180))return; } if(tank.y<P.edge){ if(go(90))return; } if(tank.y>600-P.edge){ if(go(270))return; }

  // Ally separation
  let near=null,ad=1e9; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near && ad<P.sep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(trySet([away,away+28,away-28])) return; }

  // Engagement ring with adaptive aggression towards low-HP targets
  if(tgt){
    const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance;
    let minR=P.rMin, maxR=P.rMax;
    if(tgt.health<P.finisherHP) { __s.aggr=P.aggrRemain; }
    if(__s.aggr>0) { minR-=P.aggrIn; maxR-=P.aggrOut; }
    if(d<minR){ if(trySet([to+180+P.bias,to+150,to+210,to+180+P.bias*0.5])) return; }
    if(d>maxR){ if(trySet([to+P.bias,to+P.bias+20,to+P.bias-20])) return; }
    const strafe = P.strafe + ((__s.tick>>3)%2?8:-8);
    if(trySet([to+90+strafe+P.bias, to-90-strafe+P.bias, to+60, to-60])) return;
  }

  // Fallback wandering to break symmetry and avoid deadlocks
  const r=((__s.tick*13+8)%360)+P.bias; trySet([r, r+120, r-120]);
}
