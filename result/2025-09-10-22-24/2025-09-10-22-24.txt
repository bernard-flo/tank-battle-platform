function name(){return "Nova-G-T1";}
function type(){return Type.TANKER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":13.976,"leadWeight":0.976,"aimJitter":0.22,"minRange":165.017,"maxRange":255.1,"strafeAngle":27.971,"threatRadius":159.841,"threatFleeBias":14.046,"allySep":63.902,"edgeMargin":45.831,"bias":-10.062,"targetHealthWeight":1.366,"targetDistWeight":0.101,"finishHp":24.008,"finishRemain":3.13,"finishMinDelta":34.911,"finishMaxDelta":24.872,"lowHp":39.935,"lowHpPad":35.171,"sweep":[0,60,120,180,240,300]}); P.bias=(P.bias||0)+(-10).toFixed?-10:((-10)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-G-T2";}
function type(){return Type.TANKER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":13.879,"leadWeight":0.98,"aimJitter":0.188,"minRange":165.065,"maxRange":255.18,"strafeAngle":28.132,"threatRadius":159.956,"threatFleeBias":13.899,"allySep":63.937,"edgeMargin":45.982,"bias":-10.199,"targetHealthWeight":1.212,"targetDistWeight":0.089,"finishHp":24.023,"finishRemain":3.07,"finishMinDelta":35.131,"finishMaxDelta":24.981,"lowHp":39.942,"lowHpPad":34.826,"sweep":[0,60,120,180,240,300]}); P.bias=(P.bias||0)+(8).toFixed?8:((8)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-G-D1";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.906,"leadWeight":0.812,"aimJitter":0.227,"minRange":240.179,"maxRange":379.847,"strafeAngle":35.829,"threatRadius":169.886,"threatFleeBias":15.829,"allySep":61.843,"edgeMargin":44.106,"bias":11.826,"targetHealthWeight":1.455,"targetDistWeight":0.06,"finishHp":21.848,"finishRemain":3.141,"finishMinDelta":39.874,"finishMaxDelta":35.086,"lowHp":34.886,"lowHpPad":49.813,"sweep":[0,50,100,150,200,250,300,350]}); P.bias=(P.bias||0)+(-14).toFixed?-14:((-14)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-G-D2";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.877,"leadWeight":0.924,"aimJitter":0.203,"minRange":239.841,"maxRange":379.978,"strafeAngle":35.804,"threatRadius":170.184,"threatFleeBias":16.107,"allySep":62.094,"edgeMargin":43.953,"bias":11.992,"targetHealthWeight":1.307,"targetDistWeight":0.059,"finishHp":21.953,"finishRemain":2.833,"finishMinDelta":39.985,"finishMaxDelta":34.828,"lowHp":34.892,"lowHpPad":49.923,"sweep":[0,50,100,150,200,250,300,350]}); P.bias=(P.bias||0)+(12).toFixed?12:((12)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-G-D3";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.915,"leadWeight":1.015,"aimJitter":0.229,"minRange":239.803,"maxRange":379.947,"strafeAngle":36.116,"threatRadius":170.117,"threatFleeBias":15.91,"allySep":61.812,"edgeMargin":44.098,"bias":11.939,"targetHealthWeight":1.558,"targetDistWeight":0.079,"finishHp":21.947,"finishRemain":2.886,"finishMinDelta":39.996,"finishMaxDelta":34.875,"lowHp":34.847,"lowHpPad":49.973,"sweep":[0,50,100,150,200,250,300,350]}); P.bias=(P.bias||0)+(2).toFixed?2:((2)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-G-N1";}
function type(){return Type.NORMAL;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const H=Math.hypot;
  const P=Object.assign({}, {"leadCap":13.81,"leadWeight":0.975,"aimJitter":0.204,"minRange":200.015,"maxRange":320.161,"strafeAngle":32.095,"threatRadius":165.161,"threatFleeBias":15.132,"allySep":61.826,"edgeMargin":46.116,"bias":-5.915,"targetHealthWeight":1.345,"targetDistWeight":0.098,"finishHp":21.809,"finishRemain":2.805,"finishMinDelta":35.932,"finishMaxDelta":28.192,"lowHp":39.915,"lowHpPad":40.082,"sweep":[0,60,120,180,240,300]}); P.bias=(P.bias||0)+(-6).toFixed?-6:((-6)||0);
  __state.tick=(__state.tick||0)+1;

  // inferred speed by type
  const selfSpeed = (tank.type===1?3:(tank.type===2?6:5));

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9; for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with velocity smoothing
  if(tgt){ let ax=tgt.x, ay=tgt.y; if(__state.last){ const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y); let lvx=__state.lastVel?__state.lastVel.vx:0, lvy=__state.lastVel?__state.lastVel.vy:0; const svx=lvx*0.5+vx*0.5, svy=lvy*0.5+vy*0.5; __state.lastVel={vx:svx,vy:svy}; const d=H(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap); ax=tgt.x+svx*P.leadWeight*tLead; ay=tgt.y+svy*P.leadWeight*tLead; } const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.last={x:tgt.x,y:tgt.y}; }

  // Candidate angle scoring
  function riskForAngle(a){
    const ar = toRad(a);
    const dx = Math.cos(ar)*selfSpeed, dy=Math.sin(ar)*selfSpeed;
    const nx = tank.x + dx, ny = tank.y + dy;
    let risk=0;
    // edges
    if(nx<20||nx>880) risk += 2; if(ny<20||ny>580) risk+=2;
    // ally proximity
    for(const al of allies){ const d=H(nx-al.x, ny-al.y); if(d<P.allySep) risk += (P.allySep-d)*0.02; }
    // bullet danger (peek 3 ticks)
    for(const b of bulletInfo){ let minD=1e9; for(let t=0;t<3;t++){ const bx=b.x+b.vx*(t+1), by=b.y+b.vy*(t+1); const px=nx+dx*t, py=ny+dy*t; const d=H(px-bx,py-by); if(d<minD) minD=d; }
      if(minD<P.threatRadius){ risk += (P.threatRadius-minD)*0.08; }
    }
    // range fit if tgt
    if(tgt){ const nd = H(nx-tgt.x, ny-tgt.y); let MIN=P.minRange, MAX=P.maxRange; if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain){ MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; } if(tank.health<P.lowHp) MIN+=P.lowHpPad; if(nd<MIN) risk += (MIN-nd)*0.02; else if(nd>MAX) risk += (nd-MAX)*0.01; }
    // inertia: prefer continuing direction
    if(__state.lastMove!==undefined){ const da=Math.abs(norm(a-__state.lastMove)); const turn=Math.min(da,360-da); risk += turn*0.002; }
    return risk;
  }

  // 3) assemble candidate angles: bullets perpendiculars, to/from target, strafes, sweep
  const cands=[];
  // bullet-based
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); cands.push(a+90+P.threatFleeBias+P.bias*0.4, a-90-P.threatFleeBias-P.bias*0.4, a+120, a-120, a+70, a-70); }
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); cands.push(to, to+180+P.bias*0.4, to+P.strafeAngle+P.bias*0.5, to-P.strafeAngle-P.bias*0.5); }
  for(const s of P.sweep){ cands.push(s+P.bias); }
  // dedupe and clamp
  const seen={}; const uniq=[]; for(const a of cands){ const aa=norm(Math.round(a)); if(!seen[aa]){seen[aa]=1; uniq.push(aa);} }
  uniq.sort((a,b)=>riskForAngle(a)-riskForAngle(b));

  // Try best angles first
  for(const a of uniq){ if(tank.move(norm(a))){ __state.lastMove=a; return; } }
  // Fallback random
  const fallback = norm(((__state.tick*37 + tank.x + tank.y)|0)%360);
  if(tank.move(fallback)){ __state.lastMove=fallback; return; }
}
