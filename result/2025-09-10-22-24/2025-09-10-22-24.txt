function name(){return "Nova-2-T1";}
function type(){return Type.TANKER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.134,"leadWeight":0.963,"aimJitter":0.235,"minRange":164.747,"maxRange":254.928,"strafeAngle":28.385,"threatRadius":159.515,"threatFleeBias":13.977,"allySep":64.229,"edgeMargin":45.994,"bias":-10.241,"targetHealthWeight":0.932,"targetDistWeight":0.139,"finishHp":24.336,"finishRemain":2.932,"finishMinDelta":35.246,"finishMaxDelta":25.015,"lowHp":40.199,"lowHpPad":34.455,"sweep":[0,60,120,180,240,300]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (-10).toFixed ? -10 : (-10||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-2-T2";}
function type(){return Type.TANKER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.392,"leadWeight":0.936,"aimJitter":0.222,"minRange":164.946,"maxRange":254.955,"strafeAngle":28.545,"threatRadius":159.999,"threatFleeBias":14.394,"allySep":63.74,"edgeMargin":46.034,"bias":-9.679,"targetHealthWeight":1.097,"targetDistWeight":0.117,"finishHp":24.483,"finishRemain":3.115,"finishMinDelta":35.078,"finishMaxDelta":24.623,"lowHp":39.75,"lowHpPad":34.843,"sweep":[0,60,120,180,240,300]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (8).toFixed ? 8 : (8||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-2-D1";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":14.511,"leadWeight":0.7,"aimJitter":0.22,"minRange":240.397,"maxRange":380.144,"strafeAngle":35.592,"threatRadius":170.132,"threatFleeBias":15.434,"allySep":61.779,"edgeMargin":43.813,"bias":11.434,"targetHealthWeight":1.629,"targetDistWeight":0.046,"finishHp":21.441,"finishRemain":2.609,"finishMinDelta":39.597,"finishMaxDelta":35.075,"lowHp":34.632,"lowHpPad":50.288,"sweep":[0,50,100,150,200,250,300,350]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (-14).toFixed ? -14 : (-14||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-2-D2";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":15.106,"leadWeight":1.1,"aimJitter":0.269,"minRange":240.554,"maxRange":380.3,"strafeAngle":35.797,"threatRadius":169.453,"threatFleeBias":15.634,"allySep":61.785,"edgeMargin":43.592,"bias":12.047,"targetHealthWeight":1.854,"targetDistWeight":0.045,"finishHp":21.769,"finishRemain":2.696,"finishMinDelta":39.989,"finishMaxDelta":35.296,"lowHp":35.057,"lowHpPad":49.633,"sweep":[0,50,100,150,200,250,300,350]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (12).toFixed ? 12 : (12||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-2-D3";}
function type(){return Type.DEALER;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":15.337,"leadWeight":1.1,"aimJitter":0.225,"minRange":239.699,"maxRange":379.457,"strafeAngle":35.816,"threatRadius":169.661,"threatFleeBias":15.705,"allySep":61.73,"edgeMargin":44.201,"bias":11.575,"targetHealthWeight":1.707,"targetDistWeight":0.016,"finishHp":21.677,"finishRemain":3.326,"finishMinDelta":40.246,"finishMaxDelta":35.151,"lowHp":35.494,"lowHpPad":49.89,"sweep":[0,50,100,150,200,250,300,350]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (2).toFixed ? 2 : (2||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-2-N1";}
function type(){return Type.NORMAL;}
let __state={last:null, lastVel:null, tick:0};
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const hypot=Math.hypot;
  const P=Object.assign({}, {"leadCap":13.715,"leadWeight":1.013,"aimJitter":0.197,"minRange":199.642,"maxRange":320.017,"strafeAngle":31.859,"threatRadius":165.569,"threatFleeBias":14.708,"allySep":62.223,"edgeMargin":45.606,"bias":-5.481,"targetHealthWeight":1.396,"targetDistWeight":0.121,"finishHp":22.01,"finishRemain":3.078,"finishMinDelta":36.287,"finishMaxDelta":27.435,"lowHp":40.207,"lowHpPad":40.328,"sweep":[0,60,120,180,240,300]});
  // mix in per-robot bias to desync patterns
  P.bias = (P.bias||0) + (-6).toFixed ? -6 : (-6||0);
  __state.tick=(__state.tick||0)+1;

  // 1) target selection: prioritize low HP then distance
  let tgt=null, best=1e9;
  for(const e of enemies){ const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight; if(key<best){best=key; tgt=e;} }

  // 2) predictive aim with simple velocity smoothing
  if(tgt){
    let aimX=tgt.x, aimY=tgt.y;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); const vy=(tgt.y-__state.last.y);
      let lvx=__state.lastVel?__state.lastVel.vx:0; let lvy=__state.lastVel?__state.lastVel.vy:0;
      const svx=lvx*0.5 + vx*0.5; const svy=lvy*0.5 + vy*0.5; __state.lastVel={vx:svx,vy:svy};
      const d=hypot(tgt.x-tank.x,tgt.y-tank.y); const tLead=clamp(d/8,0,P.leadCap);
      aimX = tgt.x + svx*P.leadWeight*tLead; aimY = tgt.y + svy*P.leadWeight*tLead;
    }
    // small deterministic jitter to break symmetry
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.06*P.aimJitter;
    tank.fire(toDeg(aimX-tank.x,aimY-tank.y)+jitter);
    __state.last={x:tgt.x,y:tgt.y};
  }

  let tries=0; const go=(a)=>{tries++; return tank.move(norm(a));};

  // 3) bullet avoidance: respond to nearest projected approach inside radius
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=hypot(px-tank.x,py-tank.y); if(d<md && d<P.threatRadius){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); const side = P.threatFleeBias + P.bias*0.4; const cand=[a+90+side, a-90-side, a+120, a-120, a+70, a-70]; for(const c of cand){ if(go(c)) return; } }

  // 4) edge avoidance (map 900x600)
  if(tank.x < P.edgeMargin){ if(go(0)) return; } if(tank.x > 900-P.edgeMargin){ if(go(180)) return; } if(tank.y < P.edgeMargin){ if(go(90)) return; } if(tank.y > 600-P.edgeMargin){ if(go(270)) return; }

  // 5) ally separation
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){ const away=toDeg(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+26)) return; if(go(away-26)) return; }

  // 6) spacing + strafing with health-aware aggression
  if(tgt){ const to=toDeg(tgt.x-tank.x,tgt.y-tank.y); const d=tgt.distance; let MIN=P.minRange, MAX=P.maxRange;
    if(tgt.health<=P.finishHp || enemies.length<=P.finishRemain) { MIN-=P.finishMinDelta; MAX-=P.finishMaxDelta; }
    if(tank.health< P.lowHp){ MIN+=P.lowHpPad; }
    if(d<MIN){ const away=to+180 + P.bias*0.4; if(go(away)) return; if(go(away+22)) return; if(go(away-22)) return; }
    else if(d>MAX){ if(go(to)) return; if(go(to+16)) return; if(go(to-16)) return; }
    else { const side = to + ((((__state.tick+tank.x+tank.y)|0)%2)?P.strafeAngle:-P.strafeAngle) + P.bias*0.5; if(go(side)) return; if(go(side+16)) return; if(go(side-16)) return; }
  }

  // 7) fallback sweeping
  for(const s of P.sweep){ if(go(s+P.bias)) return; }
}
