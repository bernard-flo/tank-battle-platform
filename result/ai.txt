function name(){return 'Atlas';}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9, ex=0,ey=0; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} ex+=e.x; ey+=e.y; }
  const ecx=(ex/Math.max(1,enemies.length)||tank.x)-tank.x, ecy=(ey/Math.max(1,enemies.length)||tank.y)-tank.y; const ecd=Math.hypot(ecx,ecy)+1e-6;
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} ax/=Math.max(1,allies.length); ay/=Math.max(1,allies.length); const acx=(ax||tank.x)-tank.x, acy=(ay||tank.y)-tank.y; const acd=Math.hypot(acx,acy)+1e-6;
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.05*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=70; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/150), t0,t1,t2, Math.tanh(nd/400), (nx?((nx.x-tank.x)/Math.max(1,nd)):0), (nx?((nx.y-tank.y)/Math.max(1,nd)):0), ecx/ecd, ecy/ecd, acx/acd, acy/acd, Math.tanh(th), wx, wy ];
  const W1=[[0.38,-0.20,0.26,0.46,0.28,-0.24,0.20,0.68,0.70,-0.48,0.09,-0.31,-0.04,0.38,0.90,-1.05],[-0.12,-0.19,-0.04,0.12,-0.33,-0.02,0.39,-0.51,0.27,-0.18,-0.33,0.18,-0.05,0.09,-0.26,1.40],[0.82,-0.29,0.06,-1.10,-0.08,-0.46,-0.16,-0.33,0.26,0.72,0.35,-1.02,0.14,-0.31,0.78,0.08],[0.12,-0.74,-0.37,0.43,-0.16,-0.25,0.64,0.14,0.02,-0.18,-0.35,-1.17,0.29,0.46,0.28,0.30],[-0.86,0.71,0.09,-0.06,-0.49,-0.64,-0.36,0.40,-0.30,0.03,-0.14,-0.10,0.90,-0.17,-0.30,0.05],[0.22,-0.82,-0.45,0.45,-0.48,-0.44,-0.07,-0.48,0.74,-0.19,-0.43,0.81,-0.52,-0.34,0.41,-0.25]]; const b1=[0.09,-0.58,0.19,-0.05,0.51,0.11]; const W2=[[-0.64,-0.15,-0.57,-0.36,0.28,-0.17],[0.25,-0.04,0.25,0.42,-0.41,0.70],[-0.79,-0.89,0.37,0.60,0.21,-0.36],[0.34,0.25,0.25,0.01,-0.61,-0.21],[-0.29,0.01,-0.47,0.27,0.27,-0.33]]; const b2=[0.10,-0.12,-0.14,-0.18,-0.08];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wOb=Math.max(0,o[2]), wWall=Math.max(0,o[3]); const s=wEv+wAt+wOb+wWall+1e-6; wEv/=s; wAt/=s; wOb/=s; wWall/=s; const aimLead=o[4];
  const atx = (nx?((nx.x-tank.x)/Math.max(1e-6,nd)):(ecx/ecd)), aty=(nx?((nx.y-tank.y)/Math.max(1e-6,nd)):(ecy/ecd)); const obx=-aty, oby=atx;
  const mvx=evx*wEv + atx*wAt + obx*wOb + wx*wWall, mvy=evy*wEv + aty*wAt + oby*wOb + wy*wWall; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x, nx.y-tank.y); const lead=clamp(aimLead, -10, 14); tank.fire(ang(aim+lead)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return 'Helios';}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} }
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=55; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/120), t0,t1,t2, Math.tanh(nd/300), (nx?((nx.x-tank.x)/Math.max(1,nd)):0), (nx?((nx.y-tank.y)/Math.max(1,nd)):0), Math.tanh(th), wx, wy ];
  const W1=[[0.61,0.03,0.07,-0.93,-0.94,-0.06,0.91,-0.10,0.08,-0.10,-0.68,0.35], [0.10,0.03,-0.09,-0.64,-0.16,0.23,0.28,-0.02,-0.16,-0.74,-0.46,-0.29],[0.60,-0.03,-0.19,-0.24,-0.81,0.75,0.09,-0.38,0.07,-0.43,0.30,0.05],[-0.27,0.32,-0.45,-0.29,-0.26,0.15,-0.22,-0.39,-0.63,0.47,-0.29,0.20],[0.62,-0.77,0.13,0.27,0.41,0.59,0.05,0.34,0.08,0.35,0.37,-0.01],[0.38,-0.48,-0.47,-0.08,0.55,0.35,0.95,0.12,0.33,-0.31,0.11,-0.01]]; const b1=[0.66,-0.11,-0.15,-0.22,0.04,-0.02]; const W2=[[-0.68,0.14,-0.40,-0.47,-0.44,0.44],[-0.15,0.56,1.06,0.18,0.48,-0.06],[0.58,-0.42,1.38,0.28,0.30,1.07],[0.74,1.09,0.15,0.47,0.20,0.03],[-0.13,1.04,-0.37,0.16,-0.54,0.24]]; const b2=[0.51,0.23,-0.04,-0.37,0.10];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]); const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s; const aimLead=o[3]; const rush=o[4];
  const atx = nx?((nx.x-tank.x)/Math.max(1e-6,nd)):0, aty=nx?((nx.y-tank.y)/Math.max(1e-6,nd)):0; const obx=-aty, oby=atx;
  const mvx=evx*wEv + (atx+obx*0.2+wx*0.2)*wAt + wx*wWall + atx*0.3*rush, mvy=evy*wEv + (aty+oby*0.2+wy*0.2)*wAt + wy*wWall + aty*0.3*rush; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x, nx.y-tank.y); const lead=clamp(aimLead, -8, 18); tank.fire(ang(aim+lead)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+60))){ if(!tank.move(ang(mvAng-60))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return 'Nova';}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9, far=null, fd=0; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} if(e.distance>fd){fd=e.distance; far=e;} }
  let ax=0,ay=0,cnt=0; for(const a of allies){ax+=a.x; ay+=a.y; cnt++;} if(cnt>0){ax/=cnt; ay/=cnt;}
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.08*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/120), t0,t1,t2, Math.tanh(nd/350), Math.tanh(fd/500), (nx?((nx.x-tank.x)/Math.max(1,nd)):0),(nx?((nx.y-tank.y)/Math.max(1,nd)):0), ((ax||tank.x)-tank.x)/450, ((ay||tank.y)-tank.y)/300, Math.tanh(th), wx, wy ];
  const W1=[[0.22,0.17,-0.09,0.44,-0.22,0.18,-0.28,0.31,0.62,0.14,0.07,-0.11,0.20,0.33,-0.15],[-0.44,0.09,0.11,-0.33,0.10,0.18,0.12,-0.22,0.18,0.31,-0.44,0.16,0.22,-0.31,0.27],[0.33,-0.28,0.24,-0.12,-0.18,0.09,0.08,-0.16,0.28,-0.18,0.22,0.04,-0.28,0.12,-0.18],[0.16,-0.31,0.22,0.14,0.18,-0.31,0.37,0.12,-0.22,-0.28,0.31,-0.22,0.11,0.16,0.11],[-0.31,0.22,-0.33,0.24,-0.18,-0.22,-0.14,0.11,-0.29,0.24,-0.11,-0.16,0.18,-0.24,0.22],[0.28,-0.22,0.18,-0.18,0.22,0.16,0.14,-0.18,0.11,-0.16,0.18,0.12,-0.16,0.28,-0.22]]; const b1=[0.11,-0.08,0.07,-0.06,0.05,-0.04]; const W2=[[0.22,0.16,0.14,-0.12,0.18,-0.11],[0.18,-0.14,0.22,0.16,0.14,0.22],[-0.22,0.18,-0.16,0.14,-0.12,-0.14],[0.16,0.22,0.12,0.11,0.08,0.04],[0.28,0.14,-0.18,0.22,0.24,-0.12]]; const b2=[-0.08,0.06,-0.04,0.02,0.04];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wCoh=Math.max(0,o[2]), wWall=Math.max(0,o[3]); const s=wEv+wAt+wCoh+wWall+1e-6; wEv/=s; wAt/=s; wCoh/=s; wWall/=s; const aimLead=o[4];
  const atx = nx?((nx.x-tank.x)/Math.max(1e-6,nd)):0, aty=nx?((nx.y-tank.y)/Math.max(1e-6,nd)):0; const cx=((ax||tank.x)-tank.x), cy=((ay||tank.y)-tank.y); const cn=Math.hypot(cx,cy)+1e-6; const cohx=cx/cn, cohy=cy/cn;
  const mvx=evx*wEv + atx*wAt + cohx*wCoh + wx*wWall, mvy=evy*wEv + aty*wAt + cohy*wCoh + wy*wWall; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x,nx.y-tank.y); tank.fire(ang(aim+clamp(aimLead,-12,12))); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+65))){ if(!tank.move(ang(mvAng-65))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return 'Aegis';}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} }
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.05*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=80; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/180), t0,t1,t2, Math.tanh(nd/500), (nx?((nx.x-tank.x)/Math.max(1,nd)):0), (nx?((nx.y-tank.y)/Math.max(1,nd)):0), Math.tanh(th), wx, wy ];
  const W1=[[0.32,-0.18,0.14,0.38,0.22,-0.20,0.24,0.44,0.55,-0.36,0.07,-0.24],[0.10,-0.16,-0.04,0.08,-0.22,-0.02,0.32,-0.40,0.21,-0.16,-0.30,0.16],[0.70,-0.22,0.06,-0.92,-0.08,-0.40,-0.14,-0.30,0.22,0.60,0.30,-0.90],[0.10,-0.70,-0.34,0.40,-0.14,-0.22,0.58,0.12,0.02,-0.16,-0.32,-1.00],[ -0.70,0.60,0.08,-0.06,-0.42,-0.56,-0.33,0.36,-0.28,0.02,-0.12,-0.08],[0.20,-0.70,-0.40,0.40,-0.42,-0.40,-0.06,-0.44,0.70,-0.18,-0.40,0.76]]; const b1=[0.08,-0.50,0.16,-0.04,0.44,0.10]; const W2=[[-0.56,-0.14,-0.50,-0.30,0.24,-0.16],[0.22,-0.04,0.22,0.36,-0.36,0.60],[-0.70,-0.80,0.34,0.52,0.18,-0.32],[0.30,0.22,0.22,0.01,-0.54,-0.18],[-0.26,0.01,-0.42,0.24,0.24,-0.30]]; const b2=[0.09,-0.10,-0.12,-0.16,-0.07];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]); const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s; const aimLead=o[3];
  const atx = nx?((nx.x-tank.x)/Math.max(1e-6,nd)):0, aty=nx?((nx.y-tank.y)/Math.max(1e-6,nd)):0;
  const mvx=evx*wEv + atx*wAt + wx*wWall, mvy=evy*wEv + aty*wAt + wy*wWall; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x, nx.y-tank.y); tank.fire(ang(aim+clamp(aimLead,-8,10))); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+75))){ if(!tank.move(ang(mvAng-75))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return 'Viper';}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} }
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.07*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=50; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/100), t0,t1,t2, Math.tanh(nd/280), (nx?((nx.x-tank.x)/Math.max(1,nd)):0), (nx?((nx.y-tank.y)/Math.max(1,nd)):0), Math.tanh(th), wx, wy ];
  const W1=[[0.66,-0.08,0.19,-0.70,0.18,-0.22,0.79,-0.18,0.22,-0.16,-0.44,0.28],[0.22,0.04,-0.12,-0.44,-0.14,0.20,0.30,-0.08,-0.18,-0.52,-0.28,-0.24],[0.50,-0.10,-0.18,-0.18,-0.70,0.66,0.12,-0.32,0.10,-0.28,0.22,0.04],[-0.22,0.28,-0.36,-0.22,-0.18,0.14,-0.20,-0.32,-0.54,0.38,-0.22,0.18],[0.50,-0.62,0.12,0.22,0.36,0.50,0.06,0.30,0.10,0.30,0.32,-0.02],[0.30,-0.40,-0.42,-0.08,0.48,0.30,0.88,0.10,0.30,-0.30,0.10,-0.02]]; const b1=[0.56,-0.10,-0.12,-0.20,0.04,-0.02]; const W2=[[-0.60,0.12,-0.38,-0.44,-0.40,0.40],[-0.12,0.50,1.00,0.18,0.44,-0.06],[0.52,-0.38,1.30,0.26,0.28,1.00],[0.70,1.00,0.14,0.44,0.18,0.03],[-0.12,0.96,-0.34,0.16,-0.50,0.22]]; const b2=[0.48,0.20,-0.04,-0.34,0.09];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]); const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s; const aimLead=o[3];
  const atx = nx?((nx.x-tank.x)/Math.max(1e-6,nd)):0, aty=nx?((nx.y-tank.y)/Math.max(1e-6,nd)):0;
  const mvx=evx*wEv + (atx+wx*0.1)*wAt + wx*wWall, mvy=evy*wEv + (aty+wy*0.1)*wAt + wy*wWall; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x, nx.y-tank.y); tank.fire(ang(aim+clamp(aimLead,-14,20))); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+55))){ if(!tank.move(ang(mvAng-55))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return 'Orion';}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;} function deg(x,y){return Math.atan2(y,x)*180/Math.PI;} function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function mlp(x,W1,b1,W2,b2){const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));}
  const W=900,H=600;
  let nx=null, nd=1e9, ex=0,ey=0; for(const e of enemies){ if(e.distance<nd){nd=e.distance; nx=e;} ex+=e.x; ey+=e.y; }
  const ecx=(ex/Math.max(1,enemies.length)||tank.x)-tank.x, ecy=(ey/Math.max(1,enemies.length)||tank.y)-tank.y; const ecd=Math.hypot(ecx,ecy)+1e-6;
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6; const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; th+=w; }} const en=Math.hypot(evx,evy)+1e-6; evx/=en; evy/=en;
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; const wn=Math.hypot(wx,wy)+1e-6; wx/=wn; wy/=wn;
  const t0 = tank.type===0?1:0, t1=tank.type===1?1:0, t2=tank.type===2?1:0;
  const inVec=[ tank.x/W*2-1, tank.y/H*2-1, Math.tanh(tank.health/120), t0,t1,t2, Math.tanh(nd/350), (nx?((nx.x-tank.x)/Math.max(1,nd)):0), (nx?((nx.y-tank.y)/Math.max(1,nd)):0), ecx/ecd, ecy/ecd, Math.tanh(th), wx, wy ];
  const W1=[[0.30,0.06,0.12,-0.40,-0.40,-0.06,0.36,-0.08,0.08,-0.09,-0.42,0.24,0.14,0.10], [0.12,0.03,-0.06,-0.44,-0.12,0.20,0.26,-0.02,-0.12,-0.52,-0.30,-0.18,-0.16,-0.18],[0.42,-0.10,-0.16,-0.20,-0.60,0.62,0.10,-0.34,0.08,-0.30,0.24,0.05,0.10,0.12],[-0.20,0.24,-0.32,-0.22,-0.18,0.16,-0.18,-0.34,-0.56,0.34,-0.20,0.20,0.10,0.08],[0.50,-0.66,0.12,0.22,0.34,0.52,0.06,0.32,0.08,0.32,0.34,-0.02,-0.08,-0.06],[0.30,-0.44,-0.40,-0.08,0.46,0.32,0.84,0.12,0.28,-0.32,0.12,-0.02,0.10,0.08]]; const b1=[0.56,-0.10,-0.12,-0.20,0.04,-0.02]; const W2=[[-0.60,0.12,-0.38,-0.44,-0.40,0.40],[-0.12,0.50,1.00,0.18,0.44,-0.06],[0.52,-0.38,1.30,0.26,0.28,1.00],[0.70,1.00,0.14,0.44,0.18,0.03],[-0.12,0.96,-0.34,0.16,-0.50,0.22]]; const b2=[0.48,0.20,-0.04,-0.34,0.09];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]); const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s; const aimLead=o[3];
  const atx = nx?((nx.x-tank.x)/Math.max(1e-6,nd)):(ecx/ecd), aty = nx?((nx.y-tank.y)/Math.max(1e-6,nd)):(ecy/ecd);
  const mvx=evx*wEv + atx*wAt + wx*wWall, mvy=evy*wEv + aty*wAt + wy*wWall; const mvAng=deg(mvx,mvy);
  if(nx){ const aim=deg(nx.x-tank.x, nx.y-tank.y); tank.fire(ang(aim+clamp(aimLead,-12,16))); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+60))){ if(!tank.move(ang(mvAng-60))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

