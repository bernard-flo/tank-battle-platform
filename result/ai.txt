// === AI Pack v7 (6 tanks, NN-based, tuned) ===
// Import 안내: 아래 6개 블록을 통째로 복사하여
// 게임 화면의 Import 기능(가져오기)에 붙여넣으세요.

// 공통 설계(각 탱크 블록에 포함):
// - 입력 48차원: self 4 + type 3 + 적 3개 + 아군 2개 + 총알 3개 요약
//   self: [x/900, y/600, health_norm, size_norm] + type one-hot(3)
//   enemy: [dx, dy, dist_norm, sin, cos, health_norm]
//   ally:  [dx, dy, dist_norm, health_norm]
//   bullet:[dx, dy, dist_norm, vx_norm, vy_norm]
// - 출력 5차원: [move_cos, move_sin, fire_cos, fire_sin, fire_prob]
// - 활성화: 출력 0..3은 tanh, 출력4는 sigmoid
// - 이동: atan2(out1, out0), 실패 시 소폭/중폭/역진 보정
// - 사격: atan2(out3, out2), out4 > role 임계치일 때 발사

function name() { return 'Shield-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f; // 48
  }
  function NN(x){
    const D=48, O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1,sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 라인 세우기(적쪽으로 전진) + 총알 강회피 + 중앙 복귀 소량
    add(0,I.e1+0,+1.40); add(1,I.e1+1,+1.40);
    add(0,I.e2+0,+0.55); add(1,I.e2+1,+0.55);
    add(0,I.b1+0,-1.35); add(1,I.b1+1,-1.35);
    add(0,I.b2+0,-0.80); add(1,I.b2+1,-0.80);
    add(0,I.sx,-0.14);   add(1,I.sy,-0.14);
    // 조준: 최근접 적 고정
    add(2,I.e1+0,+3.10); add(3,I.e1+1,+3.10);
    // 발사: 근접 + 내 체력 양호 시 더 공격적
    add(4,I.e1+2,-3.10); add(4,I.sh,+0.55); b[4]+=0.92;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+22) || tank.move(move-22) || tank.move(move+55) || tank.move(move-55) || tank.move(move+180); }
  if(y[4]>0.31) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Anchor-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const esD=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const esW=enemies.slice().sort((a,b)=>a.health-b.health);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(esW[0]||esD[0]), e2=eF(esD[0]), e3=eF(esD[1]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48,O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1,sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 아군 보호(아군 쪽 가중) + 탄 회피 + 전진 약간
    add(0,I.a1+0,+0.80); add(1,I.a1+1,+0.80);
    add(0,I.e1+0,+0.50); add(1,I.e1+1,+0.50);
    add(0,I.b1+0,-1.40); add(1,I.b1+1,-1.40);
    add(0,I.b2+0,-0.85); add(1,I.b2+1,-0.85);
    add(0,I.sx,-0.08);   add(1,I.sy,-0.08);
    // 조준: 취약 적 우선
    add(2,I.e1+0,+2.90); add(3,I.e1+1,+2.90);
    // 발사: 근접 + 내 체력 양호 바이어스
    add(4,I.e1+2,-2.95); add(4,I.sh,+0.45); b[4]+=0.88;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+20) || tank.move(move-20) || tank.move(move+50) || tank.move(move-50) || tank.move(fire); }
  if(y[4]>0.30) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Coordinator-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const esD=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const esW=enemies.slice().sort((a,b)=>a.health-b.health);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(esW[0]||esD[0]), e2=eF(esD[0]), e3=eF(esD[1]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f; // 48
  }
  function NN(x){
    const D=48,O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1,sh:2, e1:7, e2:13, e3:19, a1:25, a2:29, b1:33, b2:38};
    // 이동: 아군 중심 유지 + 취약 적에 접근 + 탄 회피 + 중앙 복귀 약간
    add(0,I.a1+0,+0.75); add(1,I.a1+1,+0.75);
    add(0,I.e1+0,+0.70); add(1,I.e1+1,+0.70);
    add(0,I.b1+0,-1.30); add(1,I.b1+1,-1.30);
    add(0,I.b2+0,-0.80); add(1,I.b2+1,-0.80);
    add(0,I.sx,-0.10);   add(1,I.sy,-0.10);
    // 조준: 취약 적(e1) 우선, e2 보조
    add(2,I.e1+0,+3.05); add(3,I.e1+1,+3.05);
    add(2,I.e2+0,+0.65); add(3,I.e2+1,+0.65);
    // 발사: 근접 + 내 체력 양호 + 탄 적음
    add(4,I.e1+2,-3.00); add(4,I.sh,+0.45); add(4,I.b1+2,-0.85); b[4]+=0.90;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+22) || tank.move(move-22) || tank.move(move+55) || tank.move(move-55) || tank.move(fire); }
  if(y[4]>0.29) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Skirmisher-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48,O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 적 반대(거리 유지) + 스트레이프 + 탄 강회피 + 중앙 복귀 조절
    add(0,I.e1+0,-1.10); add(1,I.e1+1,-1.10);
    add(0,I.e1+1,+0.95); add(1,I.e1+0,-0.95);
    add(0,I.b1+0,-1.80); add(1,I.b1+1,-1.80);
    add(0,I.b2+0,-1.05); add(1,I.b2+1,-1.05);
    add(0,I.sx,-0.09);  add(1,I.sy,-0.09);
    // 조준: e1 강, e2 보조
    add(2,I.e1+0,+3.20); add(3,I.e1+1,+3.20);
    add(2,I.e2+0,+0.60); add(3,I.e2+1,+0.60);
    // 발사: 근접/정렬 + 탄 적음, 공격적 바이어스는 보통
    add(4,I.e1+2,-2.95); add(4,I.b1+2,-1.20); b[4]+=0.89;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+24) || tank.move(move-24) || tank.move(move+60) || tank.move(move-60) || tank.move(move+180); }
  if(y[4]>0.28) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Reaper-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f; // 48
  }
  function NN(x){
    const D=48,O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 카이팅(적 반대) + 강한 스트레이프 + 탄 강회피 + 중앙 복귀 소량
    add(0,I.e1+0,-1.20); add(1,I.e1+1,-1.20);
    add(0,I.e1+1,+1.05); add(1,I.e1+0,-1.05);
    add(0,I.b1+0,-1.95); add(1,I.b1+1,-1.95);
    add(0,I.b2+0,-1.15); add(1,I.b2+1,-1.15);
    add(0,I.sx,-0.10);   add(1,I.sy,-0.10);
    // 조준: 최근접 적 강하게
    add(2,I.e1+0,+3.40); add(3,I.e1+1,+3.40);
    add(2,I.e2+0,+0.60); add(3,I.e2+1,+0.60);
    // 발사: 근접/정렬 + 탄 적음 + 공격적 바이어스
    add(4,I.e1+2,-3.05); add(4,I.b1+2,-1.10); b[4]+=0.94;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+32) || tank.move(move-32) || tank.move(move+72) || tank.move(move-72) || tank.move(move+180); }
  if(y[4]>0.27) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Hawk-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48,O=5; const W=Array.from({length:O},()=>new Array(D).fill(0)); const b=[0,0,0,0,0]; const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, e1:7, e2:13, e3:19, a1:25, b1:33, b2:38};
    // 이동: 플랭킹 성향(목표 주변 곡선 이동) + 탄 회피 + 중앙 복귀
    // 곡선 이동: 목표에 대해 직교 성분 강하게
    add(0,I.e1+1,+1.20); add(1,I.e1+0,-1.20);
    // 거리 유지(너무 붙지 않게 약간 반대 성분)
    add(0,I.e1+0,-0.55); add(1,I.e1+1,-0.55);
    // 탄 회피
    add(0,I.b1+0,-1.85); add(1,I.b1+1,-1.85);
    add(0,I.b2+0,-1.05); add(1,I.b2+1,-1.05);
    // 중앙 복귀 스프링
    add(0,I.sx,-0.09);   add(1,I.sy,-0.09);
    // 조준: e1 + e2 혼합으로 전환성 확보
    add(2,I.e1+0,+3.35); add(3,I.e1+1,+3.35);
    add(2,I.e2+0,+0.65); add(3,I.e2+1,+0.65);
    // 발사: 근접/정렬 + 공격적 바이어스
    add(4,I.e1+2,-3.00); b[4]+=0.92;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+28) || tank.move(move-28) || tank.move(move+64) || tank.move(move-64) || tank.move(move+180); }
  if(y[4]>0.29) tank.fire(fire);
}

