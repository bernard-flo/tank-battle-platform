// === AI Pack v2 (6 tanks, NN-based) ===

function name() { return 'Alpha-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function build() {
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Tanker: push frontline; modest bullet avoidance; strong aim at nearest
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={self_sx:0,self_sy:1,e1:7,e2:13,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.e1+0,+1.5); add(1,I.e1+1,+1.5);
    add(0,I.e2+0,+0.7); add(1,I.e2+1,+0.7);
    add(0,I.b1+0,-1.0); add(1,I.b1+1,-1.0);
    add(0,I.b2+0,-0.6); add(1,I.b2+1,-0.6);
    add(0,I.self_sx,-0.2); add(1,I.self_sy,-0.2);
    add(2,I.e1+0,+3.2); add(3,I.e1+1,+3.2);
    add(4,I.e1+2,-3.1); add(4,I.b1+2,-0.8); b[4]+=1.0;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+30) || tank.move(moveAngle-30) || tank.move(fireAngle); }
  if(y[4]>0.34) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Bravo-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    // prioritize weakest enemy as target1, nearest as target2
    const targetWeak = enemies.length>0 ? enemies.slice().sort((a,b)=>a.health-b.health)[0] : null;
    const e1=eF(targetWeak||es[0]), e2=eF(es[0]), e3=eF(es[1]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Tanker variant: hunts weakest to secure kills; stronger bullet avoidance
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={e1:7,e2:13,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.e1+0,+1.2); add(1,I.e1+1,+1.2);
    add(0,I.e2+0,+0.6); add(1,I.e2+1,+0.6);
    add(0,I.b1+0,-1.5); add(1,I.b1+1,-1.5);
    add(0,I.b2+0,-0.9); add(1,I.b2+1,-0.9);
    add(2,I.e2+0,+3.1); add(3,I.e2+1,+3.1);
    add(4,I.e2+2,-3.2); b[4]+=1.1;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+22) || tank.move(moveAngle-22) || tank.move(fireAngle); }
  if(y[4]>0.30) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Charlie-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Dealer: kite + strong avoidance + strafe
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={e1:7,e2:13,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.b1+0,-2.0); add(1,I.b1+1,-2.0);
    add(0,I.b2+0,-1.4); add(1,I.b2+1,-1.4);
    add(0,I.e1+0,-0.9); add(1,I.e1+1,-0.9);
    add(0,I.e2+1,+0.7); add(1,I.e2+0,-0.7);
    add(2,I.e1+0,+3.6); add(3,I.e1+1,+3.6);
    add(4,I.e1+2,-3.3); add(4,I.b1+2,-2.0); b[4]+=0.9;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+35) || tank.move(moveAngle-35) || tank.move(fireAngle+180); }
  if(y[4]>0.25) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Delta-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Dealer variant: strafe around target; very strong bullet avoidance
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={e1:7,e2:13,b1:33,b2:38,self_sx:0,self_sy:1}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.e1+1,+1.25); add(1,I.e1+0,-1.25);
    add(0,I.b1+0,-1.8); add(1,I.b1+1,-1.8);
    add(0,I.b2+0,-1.0); add(1,I.b2+1,-1.0);
    add(0,I.self_sx,-0.12); add(1,I.self_sy,-0.12);
    add(2,I.e1+0,+3.3); add(3,I.e1+1,+3.3);
    add(4,I.e1+2,-3.2); add(4,I.b1+2,-2.2); b[4]+=0.95;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+28) || tank.move(moveAngle-28) || tank.move(fireAngle); }
  if(y[4]>0.28) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Echo-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    // blend: nearest and weakest
    const targetWeak = enemies.length>0 ? enemies.slice().sort((a,b)=>a.health-b.health)[0] : null;
    const e1=eF(es[0]), e2=eF(targetWeak||es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Normal: balanced approach; assist allies if low health
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={self_h:2,a1:25,e1:7,e2:13,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.e1+0,+1.0); add(1,I.e1+1,+1.0);
    add(0,I.e2+0,+0.5); add(1,I.e2+1,+0.5);
    add(0,I.b1+0,-1.2); add(1,I.b1+1,-1.2);
    add(0,I.b2+0,-0.6); add(1,I.b2+1,-0.6);
    // when low health, gravitate a bit to ally a1
    add(0,I.a1+0,+0.8); add(1,I.a1+1,+0.8); // scaled by health later via bias
    b[0]+= -0.3; b[1]+= -0.3; // mild center bias via negative offset
    add(2,I.e1+0,+3.0); add(3,I.e1+1,+3.0);
    add(4,I.e1+2,-3.0); add(4,I.b1+2,-1.2); b[4]+=1.0;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));}
    return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+27) || tank.move(moveAngle-27) || tank.move(fireAngle); }
  if(y[4]>0.31) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Foxtrot-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Normal variant: focus low-health target; balanced avoidance
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={e1:7,e2:13,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    add(0,I.e1+0,+1.0); add(1,I.e1+1,+1.0);
    add(0,I.e2+0,+0.4); add(1,I.e2+1,+0.4);
    add(0,I.b1+0,-1.3); add(1,I.b1+1,-1.3);
    add(0,I.b2+0,-0.7); add(1,I.b2+1,-0.7);
    add(2,I.e1+0,+3.0); add(3,I.e1+1,+3.0);
    add(4,I.e1+2,-3.0); b[4]+=1.05;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+30) || tank.move(moveAngle-30) || tank.move(fireAngle); }
  if(y[4]>0.33) tank.fire(fireAngle);
}

// ===== 다음 로봇 =====

function name() { return 'Charlie-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function build(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, shealth=Math.min(1,tank.health/150), ssize=Math.min(1,tank.size/50);
    const tonehot=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(e.angle||Math.atan2(dy,dx)*180/Math.PI)*Math.PI/180; return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,e.health/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.min(1,a.health/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; return [dx,dy,Math.min(1,Math.hypot(dx,dy)),Math.max(-1,Math.min(1,b.vx/8)),Math.max(-1,Math.min(1,b.vy/8))]; }
    const f=[sx,sy,shealth,ssize,...tonehot];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function act(x){
    // Dealer: kite (move opposite to aim), strong bullet perpendicular strafe
    const W=new Array(5).fill(0).map(()=>new Array(48).fill(0)); const b=[0,0,0,0,0];
    const I={e1:7,b1:33,b2:38}; const add=(o,k,w)=>W[o][k]+=w;
    // Movement: away from e1 (kite) and perpendicular to incoming bullets
    add(0,I.e1+0,-1.4); add(1,I.e1+1,-1.4); // back off from target
    // strafe: mix in perpendicular to bullet velocity by swapping and negating
    add(0,I.b1+1,-1.6); add(1,I.b1+0,+1.6);
    add(0,I.b2+1,-0.9); add(1,I.b2+0,+0.9);
    // Fire: directly toward e1
    add(2,I.e1+0,+3.4); add(3,I.e1+1,+3.4);
    // Trigger: closer target -> higher fire prob, some penalty if many bullets near
    add(4,I.e1+2,-3.3); add(4,I.b1+2,-1.0); b[4]+=0.9;
    const y=[0,0,0,0,0]; for(let o=0;o<5;o++){let s=b[o]; for(let i=0;i<48;i++) s+=W[o][i]*x[i]; y[o]=o<4?Math.tanh(s):1/(1+Math.exp(-s));} return y;
  }
  const y=act(build()); const moveAngle=Math.atan2(y[1],y[0])*180/Math.PI; const fireAngle=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(moveAngle)) { tank.move(moveAngle+32) || tank.move(moveAngle-32) || tank.move(fireAngle); }
  if(y[4]>0.29) tank.fire(fireAngle);
}
