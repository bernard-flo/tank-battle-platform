// NeuroPack v3 — 6개의 상호보완형 탱크 AI
// 각 블록은 function name(), function type(), function update(...)로 구성되어
// tank_battle_platform.html의 Import 기능으로 그대로 붙여넣을 수 있습니다.

// 1) Ares — 돌격 탱커: 어그로 유도 + 각도 흔들기 + 근접 압박
function name(){ return 'Ares'; }
function type(){ return Type.TANKER; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600; const TA=tank;
  const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let nearest=null, nd=1e9, ex=0,ey=0; for(const e of enemies){ if(e.distance<nd){ nd=e.distance; nearest=e; } ex+=e.x; ey+=e.y; }
  const ecx=(ex/Math.max(1,enemies.length)||TA.x)-TA.x, ecy=(ey/Math.max(1,enemies.length)||TA.y)-TA.y; const ecd=Math.hypot(ecx,ecy)||1;
  let ax=0,ay=0; for(const a of allies){ ax+=a.x; ay+=a.y; } ax/=Math.max(1,allies.length); ay/=Math.max(1,allies.length);
  const acx=(ax||TA.x)-TA.x, acy=(ay||TA.y)-TA.y; const acd=Math.hypot(acx,acy)||1;
  let evx=0,evy=0, threat=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; threat+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=55; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const t0=TA.type===0?1:0, t1=TA.type===1?1:0, t2=TA.type===2?1:0;
  const inVec=[ TA.x/W*2-1, TA.y/H*2-1, Math.tanh(TA.health/160), t0,t1,t2,
                Math.tanh(nd/380), nearest?((nearest.x-TA.x)/Math.max(1,nd)):0, nearest?((nearest.y-TA.y)/Math.max(1,nd)):0,
                ecx/ecd, ecy/ecd, acx/acd, acy/acd, Math.tanh(threat*0.7), wx, wy ];
  const W1=[[0.42,-0.38,0.55,0.12,-0.06,0.18,0.44,0.91,0.73,-0.19,-0.12,0.66,-0.51,0.09,0.21,-0.33],
            [0.31,-0.47,-0.72,0.05,0.62,-0.42,-0.25,-0.12,1.02,0.11,0.08,0.18,-0.15,0.39,0.52,1.02],
            [0.08,-0.31,0.28,0.14,0.35,-0.40,-0.04,1.08,-0.09,-0.61,-0.25,0.19,0.20,0.41,-0.21,-0.09],
            [-0.22,0.73,0.22,-0.29,-0.51,0.11,0.16,0.41,0.62,1.21,0.06,0.31,0.27,-0.29,0.48,-0.95],
            [-1.12,0.89,0.44,-0.18,0.05,0.41,-0.50,0.39,0.31,-0.12,-0.15,0.07,0.03,-0.17,0.12,0.39],
            [-0.64,-0.22,-0.55,-0.03,-0.82,0.31,-0.18,-0.04,0.03,0.31,-0.52,0.15,-0.12,0.18,-0.49,-0.28]];
  const b1=[-0.19,-0.09,-0.51,-0.06,-0.41,-0.12];
  const W2=[[0.04,0.31,0.39,-0.43,-0.21,0.31], [0.86,0.51,0.91,0.07,-0.18,0.12], [-0.03,0.43,-0.07,-0.11,-0.22,0.41], [-0.29,0.66,0.13,0.35,-0.02,-0.11], [1.01,0.18,-0.44,0.53,-0.08,-0.41]]; const b2=[0.66,-0.18,-0.43,-0.59,0.23];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wOb=Math.max(0,o[2]), wWall=Math.max(0,o[3]); const s=wEv+wAt+wOb+wWall+1e-6; wEv/=s; wAt/=s; wOb/=s; wWall/=s;
  const lead=nearest?Math.max(-10,Math.min(14,o[4])):0;
  const atx=nearest?((nearest.x-TA.x)/Math.max(1e-6,nd)):(ecx/ecd), aty=nearest?((nearest.y-TA.y)/Math.max(1e-6,nd)):(ecy/ecd);
  const obx=-aty, oby=atx;
  const mvx=evx*wEv + atx*wAt + obx*wOb + wx*wWall, mvy=evy*wEv + aty*wAt + oby*wOb + wy*wWall;
  const mvAng=deg(mvx,mvy);
  if(nearest){ const aim=deg(nearest.x-TA.x,nearest.y-TA.y); TA.fire(ang(aim+lead)); }
  if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+60))){ if(!TA.move(ang(mvAng-60))){ TA.move(Math.random()*360); }}}
}

// 2) Athena — 지능형 딜러: 집중사격 + 탄 회피 우선
function name(){ return 'Athena'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600, TA=tank; const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let target=null; let nd=1e9; for(const e of enemies){ if(e.health<=0) continue; const score=e.distance*0.7 + e.health*0.4; if(score<nd){ nd=score; target=e; }}
  let evx=0,evy=0,t=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.05*d); evx+=px*w; evy+=py*w; t+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=70; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const inVec=[ Math.tanh(TA.health/120), Math.tanh((nd||900)/450), Math.tanh(t), wx, wy, target?((target.x-TA.x)/(nd||1)):0, target?((target.y-TA.y)/(nd||1)):0 ];
  const W1=[[0.35,-0.41,0.72,0.22,0.18,0.91,0.51],[0.12,0.66,0.31,-0.48,0.42,-0.39,-0.61],[-0.29,0.58,-0.37,0.31,-0.27,0.33,0.74]]; const b1=[-0.11,0.07,-0.16];
  const W2=[[0.77,0.11,-0.22],[0.31,0.84,-0.41],[0.13,-0.27,0.92],[0.41,-0.19,0.28],[0.63,-0.45,0.12]]; const b2=[0.51,-0.38,0.27,0.11,0.18];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]), aimLead=o[3], kite=o[4]; const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s;
  let mvx=evx*wEv + wx*wWall, mvy=evy*wEv + wy*wWall;
  if(target){ const ux=(target.x-TA.x)/(nd||1), uy=(target.y-TA.y)/(nd||1); mvx+=ux*wAt - uy*kite*0.3; mvy+=uy*wAt + ux*kite*0.3; const aim=deg(target.x-TA.x,target.y-TA.y); TA.fire(ang(aim+Math.max(-12,Math.min(16,aimLead)))); }
  const mvAng=deg(mvx,mvy); if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+80))){ if(!TA.move(ang(mvAng-80))){ TA.move(Math.random()*360); }}}
}

// 3) Hermes — 측면 기동 딜러: 우회 진입 + 리드샷 강화
function name(){ return 'Hermes'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600, TA=tank; const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let target=null, nd=1e9, ex=0,ey=0; for(const e of enemies){ if(e.distance<nd){ nd=e.distance; target=e; } ex+=e.x; ey+=e.y; }
  const ecx=(ex/Math.max(1,enemies.length)||TA.x)-TA.x, ecy=(ey/Math.max(1,enemies.length)||TA.y)-TA.y; const ecd=Math.hypot(ecx,ecy)||1;
  let evx=0,evy=0,t=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; t+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=60; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const inVec=[ TA.x/W*2-1, TA.y/H*2-1, Math.tanh(TA.health/150), Math.tanh(nd/400), ecx/ecd, ecy/ecd, Math.tanh(t), wx, wy ];
  const W1=[[0.33,-0.28,0.41,0.65,0.51,0.22,0.44,0.18,0.09],[0.18,0.52,-0.21,-0.49,-0.33,0.31,-0.37,0.26,-0.14],[-0.25,0.47,0.09,0.33,-0.22,0.42,0.59,-0.28,0.31]]; const b1=[-0.09,0.06,-0.11];
  const W2=[[0.68,0.31,-0.21],[0.39,0.77,-0.31],[0.11,-0.26,0.88],[0.51,-0.21,0.19],[0.72,-0.39,0.14]]; const b2=[0.43,-0.33,0.22,0.09,0.16];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wFlank=Math.max(0,o[1]), wWall=Math.max(0,o[2]), aimLead=o[3], spin=o[4]; const s=wEv+wFlank+wWall+1e-6; wEv/=s; wFlank/=s; wWall/=s;
  let mvx=evx*wEv + wx*wWall, mvy=evy*wEv + wy*wWall;
  const tgt=target||{x:TA.x+ecx,y:TA.y+ecy}; const ux=(tgt.x-TA.x)/(nd||1), uy=(tgt.y-TA.y)/(nd||1);
  const fx= uy, fy=-ux; mvx += fx*wFlank + ux*0.3; mvy += fy*wFlank + uy*0.3; // 측면 기동
  const mvAng=deg(mvx,mvy); const aim=deg((tgt.x-TA.x),(tgt.y-TA.y)); TA.fire(ang(aim+Math.max(-14,Math.min(18,aimLead+spin*0.3))));
  if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+70))){ if(!TA.move(ang(mvAng-70))){ TA.move(Math.random()*360); }}}
}

// 4) Titan — 방패 탱커: 엄폐 유지 + 전선 유지
function name(){ return 'Titan'; }
function type(){ return Type.TANKER; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600, TA=tank; const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let front=TA.team==='red'?1:-1; // 전선 방향
  let target=null; let nd=1e9; for(const e of enemies){ if(e.distance<nd){ nd=e.distance; target=e; }}
  let evx=0,evy=0,t=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.05*d); evx+=px*w; evy+=py*w; t+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=50; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const holdX = TA.team==='red'? W*0.35 : W*0.65; const holdVecX = (holdX-TA.x)/W*2;
  const inVec=[ Math.tanh(TA.health/180), Math.tanh((nd||900)/400), Math.tanh(t), wx, wy, holdVecX ];
  const W1=[[0.41,-0.35,0.62,0.21,0.19,0.55],[0.17,0.58,0.28,-0.41,0.36,-0.31],[-0.22,0.44,-0.29,0.28,-0.23,0.37]]; const b1=[-0.12,0.06,-0.14];
  const W2=[[0.81,0.09,-0.18],[0.36,0.71,-0.33],[0.12,-0.23,0.77],[0.49,-0.18,0.21],[0.69,-0.41,0.13]]; const b2=[0.57,-0.31,0.21,0.12,0.17];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wHold=Math.max(0,o[1]), wWall=Math.max(0,o[2]), aimLead=o[3], jiggle=o[4]; const s=wEv+wHold+wWall+1e-6; wEv/=s; wHold/=s; wWall/=s;
  let mvx=evx*wEv + wx*wWall + front*wHold*0.6; let mvy=evy*wEv + wy*wWall + (jiggle*0.2*(Math.random()>0.5?1:-1));
  const mvAng=deg(mvx,mvy); if(target){ const aim=deg(target.x-TA.x,target.y-TA.y); TA.fire(ang(aim+Math.max(-10,Math.min(14,aimLead)))); }
  if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+65))){ if(!TA.move(ang(mvAng-65))){ TA.move(Math.random()*360); }}}
}

// 5) Viper — 암살자 딜러: 최약체 우선 + 큰 리드샷
function name(){ return 'Viper'; }
function type(){ return Type.DEALER; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600, TA=tank; const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let target=null, best=1e9; for(const e of enemies){ const score=e.health*0.9 + e.distance*0.4; if(score<best){ best=score; target=e; }}
  let evx=0,evy=0,t=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.05*d); evx+=px*w; evy+=py*w; t+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=75; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const inVec=[ Math.tanh(TA.health/120), Math.tanh((best||900)/450), Math.tanh(t), wx, wy ];
  const W1=[[0.39,-0.37,0.71,0.22,0.17],[0.14,0.61,0.29,-0.44,0.38],[-0.27,0.53,-0.33,0.29,-0.25]]; const b1=[-0.1,0.07,-0.12];
  const W2=[[0.73,0.13,-0.21],[0.34,0.79,-0.29],[0.12,-0.24,0.91],[0.52,-0.2,0.22]]; const b2=[0.49,-0.35,0.26,0.15];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]), lead=o[3]; const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s;
  let mvx=evx*wEv + wx*wWall, mvy=evy*wEv + wy*wWall;
  if(target){ const ux=(target.x-TA.x)/(target.distance||1), uy=(target.y-TA.y)/(target.distance||1); mvx+=ux*wAt; mvy+=uy*wAt; const aim=deg(target.x-TA.x,target.y-TA.y); TA.fire(ang(aim+Math.max(-16,Math.min(20,lead*1.2)))); }
  const mvAng=deg(mvx,mvy); if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+85))){ if(!TA.move(ang(mvAng-85))){ TA.move(Math.random()*360); }}}
}

// 6) Zephyr — 균형형: 상황가중 혼합(탄 회피/타겟팅/벽 회피)
function name(){ return 'Zephyr'; }
function type(){ return Type.NORMAL; }
function update(tank,enemies,allies,bulletInfo){
  const W=900,H=600, TA=tank; const ang=a=>(a+360)%360; const deg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const mlp=(x,W1,b1,W2,b2)=>{const h=b1.map((bi,j)=>Math.tanh(bi+x.reduce((s,xi,i)=>s+xi*W1[j][i],0)));return b2.map((bo,k)=>bo+h.reduce((s,hj,j)=>s+hj*W2[k][j],0));};
  let target=null, nd=1e9, ex=0,ey=0; for(const e of enemies){ if(e.distance<nd){ nd=e.distance; target=e; } ex+=e.x; ey+=e.y; }
  const ecx=(ex/Math.max(1,enemies.length)||TA.x)-TA.x, ecy=(ey/Math.max(1,enemies.length)||TA.y)-TA.y; const ecd=Math.hypot(ecx,ecy)||1;
  let evx=0,evy=0,t=0; for(const b of bulletInfo){ const rx=b.x-TA.x, ry=b.y-TA.y; const d=Math.hypot(rx,ry)||1; const bv=Math.hypot(b.vx,b.vy)||1; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.055*d); evx+=px*w; evy+=py*w; t+=w; }} const en=Math.hypot(evx,evy)||1; evx/=en; evy/=en;
  let wx=0,wy=0; const m=65; if(TA.x<m) wx+=1-TA.x/m; if(W-TA.x<m) wx-=1-(W-TA.x)/m; if(TA.y<m) wy+=1-TA.y/m; if(H-TA.y<m) wy-=1-(H-TA.y)/m; const wn=Math.hypot(wx,wy)||1; wx/=wn; wy/=wn;
  const inVec=[ TA.x/W*2-1, TA.y/H*2-1, Math.tanh(TA.health/140), Math.tanh(nd/420), ecx/ecd, ecy/ecd, Math.tanh(t), wx, wy ];
  const W1=[[0.37,-0.33,0.56,0.61,0.49,0.21,0.39,0.16,0.08],[0.16,0.49,-0.19,-0.44,-0.29,0.29,-0.34,0.23,-0.12],[-0.21,0.42,0.08,0.31,-0.20,0.37,0.53,-0.26,0.29]]; const b1=[-0.1,0.05,-0.1];
  const W2=[[0.71,0.29,-0.19],[0.36,0.74,-0.29],[0.11,-0.22,0.83],[0.48,-0.19,0.2],[0.66,-0.38,0.12]]; const b2=[0.46,-0.31,0.2,0.1,0.15];
  const o=mlp(inVec,W1,b1,W2,b2); let wEv=Math.max(0,o[0]), wAt=Math.max(0,o[1]), wWall=Math.max(0,o[2]), lead=o[3], swirl=o[4]; const s=wEv+wAt+wWall+1e-6; wEv/=s; wAt/=s; wWall/=s;
  let mvx=evx*wEv + wx*wWall, mvy=evy*wEv + wy*wWall;
  if(target){ const ux=(target.x-TA.x)/(nd||1), uy=(target.y-TA.y)/(nd||1); mvx+=ux*wAt - uy*swirl*0.25; mvy+=uy*wAt + ux*swirl*0.25; const aim=deg(target.x-TA.x,target.y-TA.y); TA.fire(ang(aim+Math.max(-12,Math.min(16,lead)))); }
  const mvAng=deg(mvx,mvy); if(!TA.move(ang(mvAng))){ if(!TA.move(ang(mvAng+75))){ if(!TA.move(ang(mvAng-75))){ TA.move(Math.random()*360); }}}
}

