// === AI Pack v5 (6 tanks, NN-based, tuned) ===
// Import 안내: 아래 6개 블록을 통째로 복사하여
// 게임 화면의 Import 기능(가져오기)에 붙여넣으세요.

// 공통 설계(각 탱크 블록에 포함):
// - 입력 48차원: self 7 + 적 3*6 + 아군 2*4 + 총알 3*5
// - 출력 5차원: [move_cos, move_sin, fire_cos, fire_sin, fire_prob]
// - 활성화: 출력 0..3은 tanh, 출력4는 sigmoid
// - 이동: atan2(out1, out0), 실패 시 ±25/60/180 보정 재시도
// - 사격: atan2(out3, out2), out4 > role별 임계치에서 발사

function name() { return 'Vanguard-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  // 특징 추출
  function F() {
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(e.distance/1000,0,1); const ang=(Math.atan2(dy,dx)); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f; // 48
  }
  // 단층 NN: 역할에 맞춘 가중치
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0];
    for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1,sh:2, e1:7, e2:13, e3:19, a1:25, a2:29, b1:33, b2:38};
    // 이동: 최근접 적 추격 + 총알 회피 + 살짝 중앙 복귀
    add(0,I.e1+0,+1.45); add(1,I.e1+1,+1.45);
    add(0,I.e2+0,+0.60); add(1,I.e2+1,+0.60);
    add(0,I.b1+0,-1.10); add(1,I.b1+1,-1.10);
    add(0,I.b2+0,-0.65); add(1,I.b2+1,-0.65);
    add(0,I.sx,-0.18);   add(1,I.sy,-0.18);
    // 조준: 최근접 적 위주, 약간 보조 목표 혼합
    add(2,I.e1+0,+3.25); add(3,I.e1+1,+3.25);
    add(2,I.e2+0,+0.80); add(3,I.e2+1,+0.80);
    // 발사 확률: 적 근접 + 총알 밀도 낮음일수록 ↑, 체력 좋으면 ↑
    add(4,I.e1+2,-3.25); add(4,I.b1+2,-0.70); add(4,I.sh,+0.60); b[4]+=0.95;
    // 전개
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} // 0..3
    {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+25) || tank.move(move-25) || tank.move(move+60) || tank.move(move-60) || tank.move(move+180); }
  if(y[4]>0.33) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Bulwark-Tanker'; }
function type() { return Type.TANKER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const esD=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const esW=enemies.slice().sort((a,b)=>a.health-b.health);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(esW[0]||esD[0]), e2=eF(esD[0]), e3=eF(esD[1]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0]; for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1,sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 약한 적(e1) 추격 + 강력한 탄 회피 + 팀 결속
    add(0,I.e1+0,+1.10); add(1,I.e1+1,+1.10);
    add(0,I.e2+0,+0.55); add(1,I.e2+1,+0.55);
    add(0,I.a1+0,+0.40); add(1,I.a1+1,+0.40);
    add(0,I.b1+0,-1.40); add(1,I.b1+1,-1.40);
    add(0,I.b2+0,-0.90); add(1,I.b2+1,-0.90);
    add(0,I.sx,-0.10);   add(1,I.sy,-0.10);
    // 조준: e2(근접) 기반, e1 보정
    add(2,I.e2+0,+3.10); add(3,I.e2+1,+3.10);
    add(2,I.e1+0,+0.70); add(3,I.e1+1,+0.70);
    // 발사: 근접일수록, 체력 좋을수록 ↑. 탄 많으면 ↓
    add(4,I.e2+2,-3.10); add(4,I.b1+2,-1.00); add(4,I.sh,+0.70); b[4]+=0.90;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+22) || tank.move(move-22) || tank.move(move+55) || tank.move(move-55) || tank.move(move+180); }
  if(y[4]>0.36) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Viper-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0]; for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, e1:7, b1:33, b2:38};
    // 이동: 원거리 포지셔닝(목표와 일정 거리 유지) + 탄 우선 회피
    add(0,I.e1+0,-0.80); add(1,I.e1+1,-0.80); // 멀어지기 경향
    add(0,I.b1+0,-1.85); add(1,I.b1+1,-1.85);
    add(0,I.b2+0,-1.10); add(1,I.b2+1,-1.10);
    add(0,I.sx,-0.08);   add(1,I.sy,-0.08);
    // 조준: e1에 강하게 고정
    add(2,I.e1+0,+3.50); add(3,I.e1+1,+3.50);
    // 발사: 멀수록 낮게, 탄 적으면 높게
    add(4,I.e1+2,-2.60); add(4,I.b1+2,-1.80); b[4]+=0.85;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+30) || tank.move(move-30) || tank.move(move+70) || tank.move(move-70) || tank.move(move+180); }
  if(y[4]>0.30) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Ranger-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0]; for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 근접 추격 + 아군 근처 유지 + 탄 회피
    add(0,I.e1+0,+1.05); add(1,I.e1+1,+1.05);
    add(0,I.a1+0,+0.55); add(1,I.a1+1,+0.55);
    add(0,I.b1+0,-1.25); add(1,I.b1+1,-1.25);
    add(0,I.b2+0,-0.70); add(1,I.b2+1,-0.70);
    add(0,I.sx,-0.12);   add(1,I.sy,-0.12);
    // 조준: e1 우선, e2 보조
    add(2,I.e1+0,+3.05); add(3,I.e1+1,+3.05);
    add(2,I.e2+0,+0.85); add(3,I.e2+1,+0.85);
    // 발사: 근접 + 탄 적음 + 내 체력 보정
    add(4,I.e1+2,-3.05); add(4,I.b1+2,-1.10); add(4,I.sh,+0.35); b[4]+=0.92;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+25) || tank.move(move-25) || tank.move(move+60) || tank.move(move-60) || tank.move(fire); }
  if(y[4]>0.31) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Sentinel-Normal'; }
function type() { return Type.NORMAL; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f;
  }
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0]; for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 아군 보호(아군 방향 비중↑) + 탄 회피 + 살짝 전진
    add(0,I.a1+0,+0.70); add(1,I.a1+1,+0.70);
    add(0,I.e1+0,+0.55); add(1,I.e1+1,+0.55);
    add(0,I.b1+0,-1.30); add(1,I.b1+1,-1.30);
    add(0,I.b2+0,-0.75); add(1,I.b2+1,-0.75);
    add(0,I.sx,-0.08);   add(1,I.sy,-0.08);
    // 조준: e1 고정
    add(2,I.e1+0,+3.00); add(3,I.e1+1,+3.00);
    // 발사: 근접 + 체력 양호
    add(4,I.e1+2,-3.00); add(4,I.sh,+0.40); b[4]+=0.90;
    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+24) || tank.move(move-24) || tank.move(move+58) || tank.move(move-58) || tank.move(fire); }
  if(y[4]>0.32) tank.fire(fire);
}

// ===== 다음 로봇 =====

function name() { return 'Phantom-Dealer'; }
function type() { return Type.DEALER; }
function update(tank, enemies, allies, bulletInfo) {
  function F(){
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const sx=tank.x/900, sy=tank.y/600, sh=Math.min(1,tank.health/150), ss=Math.min(1,tank.size/50);
    const to=[tank.type===0?1:0, tank.type===1?1:0, tank.type===2?1:0];
    const es=enemies.slice().sort((a,b)=>a.distance-b.distance);
    const as=allies.slice().sort((a,b)=>a.distance-b.distance);
    const bs=bulletInfo.slice().sort((a,b)=>a.distance-b.distance);
    function eF(e){ if(!e) return [0,0,0,0,0,0]; const dx=(e.x-tank.x)/900, dy=(e.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const ang=Math.atan2(dy,dx); return [dx,dy,dn,Math.sin(ang),Math.cos(ang),Math.min(1,(e.health||100)/150)]; }
    function aF(a){ if(!a) return [0,0,0,0]; const dx=(a.x-tank.x)/900, dy=(a.y-tank.y)/600; return [dx,dy,clamp(Math.hypot(dx,dy),0,1),Math.min(1,(a.health||100)/150)]; }
    function bF(b){ if(!b) return [0,0,0,0,0]; const dx=(b.x-tank.x)/900, dy=(b.y-tank.y)/600; const dn=clamp(Math.hypot(dx,dy),0,1); const vx=clamp(b.vx/8,-1,1), vy=clamp(b.vy/8,-1,1); return [dx,dy,dn,vx,vy]; }
    const f=[sx,sy,sh,ss,...to];
    const e1=eF(es[0]), e2=eF(es[1]), e3=eF(es[2]); f.push(...e1,...e2,...e3);
    const a1=aF(as[0]), a2=aF(as[1]); f.push(...a1,...a2);
    const b1=bF(bs[0]), b2=bF(bs[1]), b3=bF(bs[2]); f.push(...b1,...b2,...b3);
    return f; // 48
  }
  function NN(x){
    const D=48; const O=5; const W=new Array(O); const b=[0,0,0,0,0]; for(let o=0;o<O;o++){W[o]=new Array(D).fill(0);} const add=(o,k,w)=>{if(k>=0&&k<D)W[o][k]+=w;};
    const I={sx:0,sy:1, sh:2, e1:7, e2:13, a1:25, b1:33, b2:38};
    // 이동: 카이팅(적 반대) + 횡이동(스트레이프) + 탄 회피 + 중앙으로 약하게 복귀
    add(0,I.e1+0,-1.10); add(1,I.e1+1,-1.10); // 거리 유지(멀어짐)
    // 스트레이프: (y0 += +dy), (y1 += -dx)
    add(0,I.e1+1,+0.90); add(1,I.e1+0,-0.90);
    // 탄 회피 강하게
    add(0,I.b1+0,-1.90); add(1,I.b1+1,-1.90);
    add(0,I.b2+0,-1.10); add(1,I.b2+1,-1.10);
    // 살짝 중앙 복귀
    add(0,I.sx,-0.10);   add(1,I.sy,-0.10);

    // 조준: e1 우선, e2 약하게 혼합(측면 사격 시 전환성)
    add(2,I.e1+0,+3.40); add(3,I.e1+1,+3.40);
    add(2,I.e2+0,+0.60); add(3,I.e2+1,+0.60);

    // 발사: 근접/정렬 + 탄 적음 + 내 체력 보정
    add(4,I.e1+2,-2.90); add(4,I.b1+2,-1.40); add(4,I.sh,+0.30); b[4]+=0.88;

    const y=[0,0,0,0,0];
    for(let o=0;o<4;o++){let s=0; for(let i=0;i<D;i++) s+=W[o][i]*x[i]; y[o]=Math.tanh(s);} {let s=b[4]; for(let i=0;i<D;i++) s+=W[4][i]*x[i]; y[4]=1/(1+Math.exp(-s));}
    return y;
  }
  const x=F(); const y=NN(x);
  const move=Math.atan2(y[1],y[0])*180/Math.PI; const fire=Math.atan2(y[3],y[2])*180/Math.PI;
  if(!tank.move(move)) { tank.move(move+32) || tank.move(move-32) || tank.move(move+72) || tank.move(move-72) || tank.move(move+180); }
  if(y[4]>0.28) tank.fire(fire);
}
