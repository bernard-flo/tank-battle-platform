function name(){return "Ares-T1";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<65; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*31+tank.y*17)%23-11)*0.25; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  // 1) 탄 회피
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90-12, a-90+12, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  // 2) 벽 회피 (탱크 크기 고려)
  const r=tank.size/2; const m=50; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  // 3) 아군 과밀 회피
  if(allies.length){ const al=closest(allies); if(al && al.distance<60){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  // 4) 교전/카이팅
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<165){ const away=to+180-12; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>260){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to-12; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  // 5) 여유 공간 탐색
  for(const p of [0,90,180,270]){ if(tryMove(p-12)) return; }
}

// ===== 다음 로봇 =====

function name(){return "Ares-T2";}
function type(){return Type.TANKER;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<65; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*19+tank.y*13)%21-10)*0.25; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+12, a-90-12, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  const r=tank.size/2; const m=50; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<60){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<165){ const away=to+180+12; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>260){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to+12; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  for(const p of [0,90,180,270]){ if(tryMove(p+12)) return; }
}

// ===== 다음 로봇 =====

function name(){return "Ares-D1";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<72; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*29+tank.y*7)%19-9)*0.28; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+22, a-90-22, a+115, a-115]; for(const c of cand){ if(tryMove(c)) return; } }
  const r=tank.size/2; const m=55; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<65){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<225){ const away=to+180+22; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>335){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to+22; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  for(const p of [0,90,180,270]){ if(tryMove(p+22)) return; }
}

// ===== 다음 로봇 =====

function name(){return "Ares-D2";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<72; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*23+tank.y*11)%19-9)*0.28; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90-22, a-90+22, a+115, a-115]; for(const c of cand){ if(tryMove(c)) return; } }
  const r=tank.size/2; const m=55; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<65){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<225){ const away=to+180-22; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>335){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to-22; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  for(const p of [0,90,180,270]){ if(tryMove(p-22)) return; }
}

// ===== 다음 로봇 =====

function name(){return "Ares-D3";}
function type(){return Type.DEALER;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<70; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*17+tank.y*23)%21-10)*0.26; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+0, a-90-0, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  const r=tank.size/2; const m=55; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<65){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<220){ const away=to+180+0; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>330){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to+0; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  for(const p of [0,90,180,270]){ if(tryMove(p+0)) return; }
}

// ===== 다음 로봇 =====

function name(){return "Ares-N1";}
function type(){return Type.NORMAL;}
function update(tank,enemies,allies,bulletInfo){
  function focus(es){ if(!es.length) return null; es=es.slice().sort((a,b)=> a.health-b.health || (a.x+a.y)-(b.x+b.y)); return es[0]; }
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function closest(arr){let r=null,md=1e9; for(const e of arr){if(e.distance<md){md=e.distance;r=e;}} return r;}
  function threat(b){ const dx=b.x-tank.x, dy=b.y-tank.y; const dv=Math.hypot(b.vx,b.vy)||1; const nx=b.vx/dv, ny=b.vy/dv; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=Math.hypot(px-tank.x,py-tank.y); return d<68; } return false; }
  const tgt = focus(enemies);
  if(tgt){ const base=deg(tgt.x-tank.x,tgt.y-tank.y); const jitter=((tank.x*13+tank.y*29)%21-10)*0.26; tank.fire(base+jitter); }
  let tried=0; function tryMove(a){tried++; return tank.move(ang(a));}
  let hot=null, minD=1e9; for(const b of bulletInfo){const d=Math.hypot(b.x-tank.x,b.y-tank.y); if(d<minD && threat(b)){minD=d; hot=b;}}
  if(hot){ const a=deg(hot.vx,hot.vy); const cand=[a+90+0, a-90-0, a+110, a-110]; for(const c of cand){ if(tryMove(c)) return; } }
  const r=tank.size/2; const m=52; const nearL=tank.x-r<m, nearR=900-(tank.x+r)<m, nearT=tank.y-r<m, nearB=600-(tank.y+r)<m;
  if(nearL||nearR||nearT||nearB){ const away=[]; if(nearL) away.push(0); if(nearR) away.push(180); if(nearT) away.push(90); if(nearB) away.push(270); for(const a of away){ if(tryMove(a)) return; if(tryMove(a+25)) return; if(tryMove(a-25)) return; } }
  if(allies.length){ const al=closest(allies); if(al && al.distance<62){ const av=deg(tank.x-al.x,tank.y-al.y); if(tryMove(av)) return; if(tryMove(av+30)) return; if(tryMove(av-30)) return; } }
  if(tgt){ const d=tgt.distance; const to=deg(tgt.x-tank.x,tgt.y-tank.y); if(d<205){ const away=to+180+0; if(tryMove(away)) return; if(tryMove(away+25)) return; if(tryMove(away-25)) return; } else if(d>305){ if(tryMove(to)) return; if(tryMove(to+20)) return; if(tryMove(to-20)) return; } else { const side=to+0; if(tryMove(side)) return; if(tryMove(side+20)) return; if(tryMove(side-20)) return; } }
  for(const p of [0,90,180,270]){ if(tryMove(p+0)) return; }
}
