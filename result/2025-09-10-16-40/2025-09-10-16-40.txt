function name(){return "Astra-T1";}
function type(){return Type.TANKER;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.3,"distW":0.116,"dealerBias":-11,"tankerBias":10,"velLP":0.49,"leadCap":17.42,"leadW":0.93,"aimJitter":0.13,"aimBias":0.26,"minRange":159,"maxRange":294,"strafe":27,"allySep":61,"edge":65,"threatR":219,"threatH":5,"threatBonus":0,"fleeBias":15,"finisherHP":19,"aggrRemain":3,"aggrIn":23,"aggrOut":19,"bias":-22}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}


// ===== 다음 로봇 =====


function name(){return "Astra-T2";}
function type(){return Type.TANKER;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.17,"distW":0.094,"dealerBias":-11,"tankerBias":7,"velLP":0.59,"leadCap":20.33,"leadW":0.96,"aimJitter":0.21,"aimBias":0.43,"minRange":192,"maxRange":303,"strafe":27,"allySep":62,"edge":59,"threatR":208,"threatH":6,"threatBonus":1,"fleeBias":18,"finisherHP":21,"aggrRemain":4,"aggrIn":29,"aggrOut":14,"bias":18}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}


// ===== 다음 로봇 =====


function name(){return "Astra-D3";}
function type(){return Type.DEALER;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.27,"distW":0.081,"dealerBias":-9,"tankerBias":3,"velLP":0.56,"leadCap":16.07,"leadW":0.96,"aimJitter":0.17,"aimBias":-0.18,"minRange":283,"maxRange":415,"strafe":28,"allySep":59,"edge":66,"threatR":150,"threatH":4,"threatBonus":-1,"fleeBias":22,"finisherHP":23,"aggrRemain":4,"aggrIn":21,"aggrOut":13,"bias":-29}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}


// ===== 다음 로봇 =====


function name(){return "Astra-D4";}
function type(){return Type.DEALER;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.21,"distW":0.124,"dealerBias":-17,"tankerBias":8,"velLP":0.5,"leadCap":19.69,"leadW":1.07,"aimJitter":0.14,"aimBias":-0.02,"minRange":265,"maxRange":406,"strafe":31,"allySep":67,"edge":61,"threatR":171,"threatH":5,"threatBonus":-1,"fleeBias":21,"finisherHP":33,"aggrRemain":4,"aggrIn":23,"aggrOut":14,"bias":2}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}


// ===== 다음 로봇 =====


function name(){return "Astra-N5";}
function type(){return Type.NORMAL;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.28,"distW":0.107,"dealerBias":-11,"tankerBias":5,"velLP":0.57,"leadCap":16.29,"leadW":1.1,"aimJitter":0.17,"aimBias":0.35,"minRange":230,"maxRange":303,"strafe":26,"allySep":63,"edge":63,"threatR":159,"threatH":6,"threatBonus":-2,"fleeBias":21,"finisherHP":19,"aggrRemain":4,"aggrIn":29,"aggrOut":18,"bias":11}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}


// ===== 다음 로봇 =====


function name(){return "Astra-N6";}
function type(){return Type.NORMAL;}
let __s={last:null,tick:0,lastVel:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const N=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"healthW":1.28,"distW":0.102,"dealerBias":-11,"tankerBias":6,"velLP":0.61,"leadCap":21.42,"leadW":1.06,"aimJitter":0.14,"aimBias":0.19,"minRange":197,"maxRange":313,"strafe":22,"allySep":63,"edge":60,"threatR":141,"threatH":5,"threatBonus":0,"fleeBias":16,"finisherHP":29,"aggrRemain":4,"aggrIn":28,"aggrOut":21,"bias":35}; __s.tick=(__s.tick||0)+1; const rnd=((tank.x*97+tank.y*131)|0)%2?1:-1;
  // target selection with role bias by inferred size
  let tgt=null, best=1e18; for(const e of enemies){ let tBias=0; const sz=e.size||0; if(sz>=43) tBias+=P.tankerBias; else if(sz<=34) tBias+=P.dealerBias; const k=e.health*P.healthW + e.distance*P.distW + tBias; if(k<best){best=k; tgt=e;} }
  // predictive fire via quadratic intercept
  if(tgt){
    const dx=tgt.x-tank.x, dy=tgt.y-tank.y; const dist=H(dx,dy);
    let vx=0,vy=0; // estimate enemy velocity by comparing to closest other enemy as proxy if any
    if(enemies.length>1){ let nb=null,bd=1e18; for(const e of enemies){ if(e===tgt) continue; const d=H(e.x-tgt.x,e.y-tgt.y); if(d<bd){bd=d; nb=e;} } if(nb){ vx=(tgt.x-nb.x); vy=(tgt.y-nb.y); const n=H(vx,vy)||1; vx/=n; vy/=n; vx*=P.leadW; vy*=P.leadW; } }
    const bs=8; // bullet speed
    // lead factor limited
    const t=CL(dist/bs,0,P.leadCap); const lx=dx + vx*t, ly=dy + vy*t;
    let ang=D(lx,ly) + P.aimBias + (Math.random()-0.5)*P.aimJitter*30; ang=N(ang);
    // aggression finisher bias
    if(tgt.health<=P.finisherHP){ ang=N(ang + (Math.random()-0.5)*P.aimJitter*40); }
    tank.fire(ang);
  }
  // movement helpers
  let tried=0; const go=(a)=>{ if(tried>20) return true; tried++; return tank.move(N(a)); };
  // bullet avoidance with time-to-closest weighting
  let hot=null, score=1e18; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const dist=H(px-tank.x,py-tank.y); const tt=proj/v; const s=dist + tt*P.threatH - (P.threatBonus||0); if(dist<P.threatR && s<score){score=s; hot=b;} } }
  if(hot){ const a=D(hot.vx,hot.vy); const side=(rnd>0?1:-1)*P.fleeBias + (P.bias||0)*0.4; const cand=[a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]; for(const c of cand){ if(go(c)) return; } }
  // walls
  if(tank.x<P.edge){ if(go(0)) return; } if(tank.x>900-P.edge){ if(go(180)) return; } if(tank.y<P.edge){ if(go(90)) return; } if(tank.y>600-P.edge){ if(go(270)) return; }
  // ally separation
  let near=null, ad=1e18; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } } if(near && ad<P.allySep){ const away=D(tank.x-near.x,tank.y-near.y); if(go(away)) return; if(go(away+18)) return; if(go(away-18)) return; }
  // range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.minRange, r1=P.maxRange; if(tgt.health<=P.finisherHP || enemies.length<=P.aggrRemain){ r0=Math.max(100, r0-P.aggrIn); r1=Math.max(140, r1-P.aggrOut); } if(d<r0){ const aw=to+180+(P.bias||0)*0.3; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to + (((tank.x*13+tank.y*7)|0)%2?P.strafe:-P.strafe) + (P.bias||0)*0.4; if(go(s)) return; if(go(s+14)) return; if(go(s-14)) return; } }
  // fallback sweep
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}
