function name(){return "Bulwark-L";}
function type(){return Type.TANKER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":15.946551242415557,"leadWeight":0.957930562219012,"aimJitter":0.055070524875040244,"fireBias":0,"minRange":167.1232981271883,"maxRange":330.5101670008815,"strafeAngle":29.41285028868553,"threatRadius":154.62574515217568,"threatTime":37.99733660296982,"threatTight":90.53772762673417,"threatFleeBias":16.307933191567344,"allySep":66.44473946488411,"edgeMargin":52.086784453353864,"bias":-26.08087028029451,"sidePref":-2.121805854615147,"targetHealthWeight":1.5788849578216757,"targetDistWeight":0.11685143201669763,"finishHp":22.734512400995673,"finishRemain":2.9908850582479225,"finishMinDelta":31.606879220225792,"finishMaxDelta":26.01559342580961,"velEma":0.4978698640801528};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Bulwark-R";}
function type(){return Type.TANKER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":17.618356550409914,"leadWeight":1.0471451328154264,"aimJitter":0.06692304108068753,"fireBias":0,"minRange":211.70210781513987,"maxRange":265.3428428710787,"strafeAngle":13.772421647936044,"threatRadius":197.8692274522415,"threatTime":21.501349731146664,"threatTight":120.39208034561929,"threatFleeBias":10.798910363152233,"allySep":68.95522841209056,"edgeMargin":44.25637164033119,"bias":4.126668377837587,"sidePref":4.431154297914916,"targetHealthWeight":1.2248037497316837,"targetDistWeight":0.10939447599574592,"finishHp":20.543210371373178,"finishRemain":3.013464694396099,"finishMinDelta":36.34614634232857,"finishMaxDelta":31.91983064698124,"velEma":0.4668265564279935};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-1";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":18.74396164541799,"leadWeight":1.0127601863457503,"aimJitter":0.06494223378139001,"fireBias":0,"minRange":206.56723433353199,"maxRange":399.1673509898634,"strafeAngle":48.54807413977366,"threatRadius":162.23283953553792,"threatTime":30.95477160447258,"threatTight":141.8904273278358,"threatFleeBias":17.336108783021565,"allySep":58.67144427185525,"edgeMargin":46.89000886791535,"bias":-4.2417631029844625,"sidePref":3.922906550278575,"targetHealthWeight":1.4284289847995526,"targetDistWeight":0.06971753769929338,"finishHp":26.5369689360062,"finishRemain":2.6154079617386072,"finishMinDelta":29.947188563807018,"finishMaxDelta":27.258337769172844,"velEma":0.4615696826993929};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-2";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":16.496039498537254,"leadWeight":1.0586870503264678,"aimJitter":0.03775106320220393,"fireBias":0,"minRange":217.03918062568113,"maxRange":441.3373442296392,"strafeAngle":25.343951852386994,"threatRadius":162.26504429435025,"threatTime":23.51662443508011,"threatTight":94.01115401417616,"threatFleeBias":16.265793810350324,"allySep":64.05534913929326,"edgeMargin":50.515149371844856,"bias":0.9166248108698065,"sidePref":-8.253002704589242,"targetHealthWeight":1.418279195076647,"targetDistWeight":0.06253960511484723,"finishHp":21.27633733122494,"finishRemain":3.3066188478315572,"finishMinDelta":25.64056251458872,"finishMaxDelta":26.04116879536645,"velEma":0.5227589394602925};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-3";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":18.889677382895798,"leadWeight":1.0127622121864737,"aimJitter":0.1291216581927188,"fireBias":0,"minRange":243.0075216041648,"maxRange":473.59556994950566,"strafeAngle":53.103362950410876,"threatRadius":169.30690980903913,"threatTime":29.68620969709042,"threatTight":80.35130274422936,"threatFleeBias":18.90650585008867,"allySep":62.72731753490679,"edgeMargin":41.73675290042385,"bias":-0.5426506504880291,"sidePref":17.14413101823782,"targetHealthWeight":1.3926080055802712,"targetDistWeight":0.08190111921130658,"finishHp":18.771957793941592,"finishRemain":2.843197870964718,"finishMinDelta":20.387333132664406,"finishMaxDelta":25.702639712006825,"velEma":0.41376447239494096};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Anchor";}
function type(){return Type.NORMAL;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":16.6057811944082,"leadWeight":1.0508442410651935,"aimJitter":0.10689803665466166,"fireBias":0,"minRange":228.0785505362067,"maxRange":407.20864388431505,"strafeAngle":27.047134552597917,"threatRadius":192.54342115018693,"threatTime":35.96364510611472,"threatTight":115.19985576222628,"threatFleeBias":11.890377860269512,"allySep":57.88042916433844,"edgeMargin":45.70924531611548,"bias":2.005111946560816,"sidePref":11.410401714655935,"targetHealthWeight":1.4182529241459785,"targetDistWeight":0.09890382841934424,"finishHp":26.965374894681702,"finishRemain":2.7228334546575743,"finishMinDelta":28.140175221773735,"finishMaxDelta":30.29546480314562,"velEma":0.5329255435883875};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}
