function name(){return "Bulwark-L";}
function type(){return Type.TANKER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":15.676916168731015,"leadWeight":0.9995450453768621,"aimJitter":0.0834837715426419,"fireBias":0,"minRange":183.88608431385734,"maxRange":339.36953017020755,"strafeAngle":13.864193389598315,"threatRadius":132.51962967821177,"threatTime":40.64430784177308,"threatTight":130.68653083043557,"threatFleeBias":18.57581516867509,"allySep":55.229255271729535,"edgeMargin":44.22783004808092,"bias":-24.398002038401224,"sidePref":-7.725521910796602,"targetHealthWeight":1.3472801577874314,"targetDistWeight":0.08714086769886026,"finishHp":33.13811926702413,"finishRemain":2.331053500433496,"finishMinDelta":19.845395146831414,"finishMaxDelta":23.546306827984118,"velEma":0.5489524197814892};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Bulwark-R";}
function type(){return Type.TANKER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":15.216901865309747,"leadWeight":1.0757858256110524,"aimJitter":0.02347481897777925,"fireBias":0,"minRange":213.7766242063501,"maxRange":324.2537232902036,"strafeAngle":22.56619248918432,"threatRadius":154.88417627732375,"threatTime":47.14700207305677,"threatTight":65.98455618948714,"threatFleeBias":9.269634039371065,"allySep":66.55565498934537,"edgeMargin":45.88267915555945,"bias":2.1556163655345015,"sidePref":0.41265077498546077,"targetHealthWeight":1.292427323030717,"targetDistWeight":0.09105241002600978,"finishHp":23.29626706032365,"finishRemain":2.9962496257032947,"finishMinDelta":27.84507416536026,"finishMaxDelta":31.636326375367556,"velEma":0.5080343574238716};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-1";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":21.04689159910872,"leadWeight":1.0279579671792196,"aimJitter":0.1272280915119191,"fireBias":0,"minRange":372.41359674346114,"maxRange":677.4921279907262,"strafeAngle":29.081776148997747,"threatRadius":190.12507364765813,"threatTime":28.810815565037984,"threatTight":126.36300922133027,"threatFleeBias":14.84899971320019,"allySep":55.469159005689086,"edgeMargin":48.658980614221555,"bias":-2.047781293486346,"sidePref":0.979082737796844,"targetHealthWeight":1.4632578780274579,"targetDistWeight":0.0937913031532986,"finishHp":21.638483984800896,"finishRemain":3.4653870661133603,"finishMinDelta":32.133468625507135,"finishMaxDelta":23.16434089995471,"velEma":0.39619757441740894};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-2";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":14.650950143457042,"leadWeight":0.981589886295489,"aimJitter":0.021290794918943336,"fireBias":0,"minRange":202.7797467626697,"maxRange":483.11482643995834,"strafeAngle":36.29641011701985,"threatRadius":197.16112446848746,"threatTime":24.758615661910703,"threatTight":85.69382812171823,"threatFleeBias":10.186070784591722,"allySep":60.630187867875584,"edgeMargin":47.890901576971544,"bias":0.4269458994460829,"sidePref":-1.3605922404363198,"targetHealthWeight":1.278263426716324,"targetDistWeight":0.059551447031538696,"finishHp":23.49098736537828,"finishRemain":3.075232713425834,"finishMinDelta":44.57998436348687,"finishMaxDelta":14.420476565443122,"velEma":0.45951944151128116};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Striker-3";}
function type(){return Type.DEALER;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":16.551180697276408,"leadWeight":1.0555193080360792,"aimJitter":0.06297462379989763,"fireBias":0,"minRange":173.83808448105458,"maxRange":384.3584732139317,"strafeAngle":16.19253800911788,"threatRadius":151.20372361254417,"threatTime":14.615421926405753,"threatTight":96.11057241224242,"threatFleeBias":20.912162964189566,"allySep":64.64452661164097,"edgeMargin":39.81137325440359,"bias":-1.9611940113752344,"sidePref":21.60573237965032,"targetHealthWeight":1.1491900837258469,"targetDistWeight":0.08313123772704129,"finishHp":10.70120240723458,"finishRemain":3.9981819224839414,"finishMinDelta":15.107753363097082,"finishMaxDelta":20.87382098421336,"velEma":0.3674958397882491};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Anchor";}
function type(){return Type.NORMAL;}
let __state = { tick:0, lastTgt:null, lastVel:{vx:0,vy:0} };
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  const W=900,H=600;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const toRad=(a)=>a*Math.PI/180;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot;
  const P={"leadCap":17.56836067580666,"leadWeight":0.9981220183792341,"aimJitter":0.0629543828416898,"fireBias":0,"minRange":187.39321953059425,"maxRange":263.5094681874885,"strafeAngle":40.38159953719995,"threatRadius":168.6322521554045,"threatTime":42.3297295088797,"threatTight":118.94551562440286,"threatFleeBias":11.085404137366691,"allySep":57.57300648303753,"edgeMargin":50.087601110239696,"bias":0.2903168171892822,"sidePref":20.306462611563813,"targetHealthWeight":1.0856009275270013,"targetDistWeight":0.11382009234714512,"finishHp":36.337757780527895,"finishRemain":3.2201832331303026,"finishMinDelta":30.592314230257777,"finishMaxDelta":16.866750924108192,"velEma":0.695961347482607};

  __state.tick=(__state.tick||0)+1;

  // 1) Target selection: health-first, distance-second
  let tgt=null, best=1e12;
  for(const e of enemies){
    const s = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(s<best){best=s; tgt=e;}
  }

  // 2) Predictive aim by analytic intercept using est. velocity
  if(tgt){
    // Estimate target velocity (EMA)
    if(__state.lastTgt){
      const vx=(tgt.x-__state.lastTgt.x);
      const vy=(tgt.y-__state.lastTgt.y);
      __state.lastVel.vx = __state.lastVel.vx*P.velEma + vx*(1-P.velEma);
      __state.lastVel.vy = __state.lastVel.vy*P.velEma + vy*(1-P.velEma);
    }
    const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vx=__state.lastVel.vx, vy=__state.lastVel.vy; // px/tick
    const vb=8.0; // bullet speed px/tick
    const a = (vx*vx+vy*vy) - vb*vb;
    const b = 2*(rx*vx+ry*vy);
    const c = rx*rx+ry*ry;
    let t = 0;
    if (Math.abs(a) < 1e-6) {
      t = c>0 ? -c/b : 0; // linear
    } else {
      const d = b*b - 4*a*c;
      if (d >= 0) {
        const s1 = (-b + Math.sqrt(d)) / (2*a);
        const s2 = (-b - Math.sqrt(d)) / (2*a);
        t = Math.min(s1, s2);
        if (t < 0) t = Math.max(s1, s2);
      } else {
        t = 0;
      }
    }
    t = clamp(t, 0, P.leadCap);
    const aimX = tgt.x + vx*t*P.leadWeight;
    const aimY = tgt.y + vy*t*P.leadWeight;
    const jitter = ((((tank.x*31+tank.y*17)%23)-11)*0.08) * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter + P.fireBias;
    tank.fire(fireAngle);
    __state.lastTgt={x:tgt.x,y:tgt.y};
  }

  // Movement helpers
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance using closest approach
  let hot=null, minD=1e9, minT=1e9;
  for(const b of bulletInfo){
    const dx=b.x-tank.x, dy=b.y-tank.y; const v=hypot(b.vx,b.vy)||1;
    const nx=b.vx/v, ny=b.vy/v; // bullet unit velocity
    const proj=dx*nx+dy*ny; // forward distance along bullet path
    if(proj>0){
      const px=b.x-proj*nx, py=b.y-proj*ny; // closest point on path
      const d=hypot(px-tank.x,py-tank.y);
      const tca=proj/v; // ticks to closest approach
      if(d<minD && d<P.threatRadius && tca<P.threatTime){ minD=d; minT=tca; hot=b; }
    }
  }
  if(hot){
    const a=toDeg(hot.vx,hot.vy);
    // Prefer perpendicular escape but bias away if very close
    const fleeBias = (minD< P.threatTight ? P.threatFleeBias+10 : P.threatFleeBias);
    const cands=[a+90+P.sidePref+fleeBias, a-90-P.sidePref-fleeBias, a+120, a-120, a+60, a-60];
    for(const c of cands){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > W-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > H-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (closest only)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away=toDeg(tank.x-near.x,tank.y-near.y);
    if(tryMove(away)) return; if(tryMove(away+28)) return; if(tryMove(away-28)) return;
  }

  // 6) Engagement spacing + strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain=enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4; if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+18)) return; if(tryMove(to-18)) return;
    } else {
      const sign = (((tank.x*13+tank.y*7)|0)%2)?1:-1;
      const side = to + sign*P.strafeAngle + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweeping
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}
