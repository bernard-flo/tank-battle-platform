function name(){return "Gumiho";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*1.2826697530864195 + wx*0.9205868055555556 + atx*0.75 + obx*0.5582973251028807 + cx*0.15 + sx*0.35;
  const mvy = evy*1.2826697530864195 + wy*0.9205868055555556 + aty*0.75 + oby*0.5582973251028807 + cy*0.15 + sy*0.35;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((6.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Bison";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*0.974832561728395 + wx*1.0600208976337449 + atx*0.555533950617284 + obx*0.65 + cx*0.15 + sx*0.35;
  const mvy = evy*0.974832561728395 + wy*1.0600208976337449 + aty*0.555533950617284 + oby*0.65 + cy*0.15 + sy*0.35;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((14.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Manta";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*1 + wx*0.85 + atx*0.875400462962963 + obx*0.7526779835390947 + cx*0.15 + sx*0.35;
  const mvy = evy*1 + wy*0.85 + aty*0.875400462962963 + oby*0.7526779835390947 + cy*0.15 + sy*0.35;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((11.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Comet";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*1 + wx*0.85 + atx*0.9453375128600823 + obx*0.6600829475308642 + cx*0.15 + sx*0.4288225308641976;
  const mvy = evy*1 + wy*0.85 + aty*0.9453375128600823 + oby*0.6600829475308642 + cy*0.15 + sy*0.4288225308641976;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((9.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Osprey";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*1 + wx*0.85 + atx*0.6949434156378601 + obx*0.8068900462962963 + cx*0.15 + sx*0.35;
  const mvy = evy*1 + wy*0.85 + aty*0.6949434156378601 + oby*0.8068900462962963 + cy*0.15 + sy*0.35;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((10.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Kite";}
function type(){return 0;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){return (a+360)%360;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)+1e-6; return [x/m,y/m];}
  const W=900,H=600;

  // 타겟 선정: 가장 가까운 적 우선, 동률이면 체력 낮은 적
  let target=null, best=1e9;
  for(const e of enemies){const d=e.distance; const k=d - e.health*0.02; if(k<best){best=k; target=e;}}

  // 총알 회피 벡터: 닫히는 탄만 고려, 탄에 수직인 방향으로 이탈
  let evx=0, evy=0, evScore=0;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)+1e-6;
    const bv=Math.hypot(b.vx,b.vy)+1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const closing=-(rx*ux+ry*uy)/d; // 양수면 접근중
    if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.06*d); evx+=px*w; evy+=py*w; evScore+=w; }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 벽 회피 벡터
  let wx=0,wy=0; const m=60;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const ac=allies.length>0?1/allies.length:0; ax*=ac; ay*=ac;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)+1e-6; if(d<80){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 공격/견제 벡터 (타겟 기준)
  let atx=0,aty=0, obx=0,oby=0; if(target){
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)+1e-6; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 측면 기동(스트레이프)
  }

  // 가중합
  const mvx = evx*1.1424807098765433 + wx*0.8252427983539095 + atx*0.75 + obx*0.65 + cx*0.17529578189300413 + sx*0.35;
  const mvy = evy*1.1424807098765433 + wy*0.8252427983539095 + aty*0.75 + oby*0.65 + cy*0.17529578189300413 + sy*0.35;
  const mvAng = deg(mvx,mvy);

  // 사격: 간단한 리드 + 지터 스윕
  if(target){
    const base = target.angle; // 엔진이 제공하는 적에 대한 극각
    const jitter = ((13.0) * (Math.random()-0.5));
    const aim = ang(base + jitter);
    tank.fire(aim);
  }

  // 이동: 실패시 우회 각도 시도
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====
