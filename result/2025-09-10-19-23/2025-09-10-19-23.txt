function name(){return "Helios-T1";}
function type(){return Type.TANKER;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":151.375,"rMax":293.518,"strafe":21.279,"threatR":267.462,"threatH":4.83,"fleeBias":23.596,"sep":69.747,"edge":60.044,"leadCap":25.358,"leadW":1.106,"aimJ":0.139,"healthW":1.256,"distW":0.095,"finHP":21.654,"aggrRemain":3,"aggrIn":23.097,"aggrOut":15.028,"bias":0,"smooth":0.437,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.06};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.06;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "Helios-T2";}
function type(){return Type.TANKER;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":151.375,"rMax":293.518,"strafe":21.279,"threatR":267.462,"threatH":4.83,"fleeBias":23.596,"sep":69.747,"edge":60.044,"leadCap":25.358,"leadW":1.106,"aimJ":0.139,"healthW":1.256,"distW":0.095,"finHP":21.654,"aggrRemain":3,"aggrIn":23.097,"aggrOut":15.028,"bias":0,"smooth":0.437,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.06};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.06;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "Helios-D1";}
function type(){return Type.DEALER;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":235.857,"rMax":363.493,"strafe":29.987,"threatR":183.31,"threatH":6.121,"fleeBias":16.975,"sep":78.469,"edge":59.148,"leadCap":26.583,"leadW":1.11,"aimJ":0.137,"healthW":1.361,"distW":0.097,"finHP":19.963,"aggrRemain":3,"aggrIn":22.817,"aggrOut":26.189,"bias":0,"smooth":0.488,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.137};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.137;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "Helios-D2";}
function type(){return Type.DEALER;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":235.857,"rMax":363.493,"strafe":29.987,"threatR":183.31,"threatH":6.121,"fleeBias":16.975,"sep":78.469,"edge":59.148,"leadCap":26.583,"leadW":1.11,"aimJ":0.137,"healthW":1.361,"distW":0.097,"finHP":19.963,"aggrRemain":3,"aggrIn":22.817,"aggrOut":26.189,"bias":0,"smooth":0.488,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.137};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.137;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "Helios-N1";}
function type(){return Type.NORMAL;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":193.59,"rMax":341.022,"strafe":31.296,"threatR":175.805,"threatH":5.586,"fleeBias":17.76,"sep":66.287,"edge":49.671,"leadCap":22.713,"leadW":1.077,"aimJ":0.141,"healthW":1.253,"distW":0.096,"finHP":28.746,"aggrRemain":3,"aggrIn":20.451,"aggrOut":19.905,"bias":0,"smooth":0.476,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.088};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.088;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}

// ===== 다음 로봇 =====

function name(){return "Helios-N2";}
function type(){return Type.NORMAL;}
var __S = (typeof __S !== 'undefined') ? __S : {tick:0,last:null,lastV:null,side:1,initX:null,isRed:null,top:null};
function update(tank,enemies,allies,bulletInfo){
  const H=Math.hypot, D=(x,y)=>Math.atan2(y,x)*180/Math.PI, N=(a)=>{a%=360;if(a<0)a+=360;return a;}, CL=(v,l,h)=>v<l?l:v>h?h:v;
  const P={"rMin":193.59,"rMax":341.022,"strafe":31.296,"threatR":175.805,"threatH":5.586,"fleeBias":17.76,"sep":66.287,"edge":49.671,"leadCap":22.713,"leadW":1.077,"aimJ":0.141,"healthW":1.253,"distW":0.096,"finHP":28.746,"aggrRemain":3,"aggrIn":20.451,"aggrOut":19.905,"bias":0,"smooth":0.476,"openTicks":18,"sideFlip":240,"redBias":6,"alignW":0.088};
  const S=__S; S.tick=(S.tick||0)+1; if(S.initX===null){ S.initX=tank.x; S.isRed = S.initX < 450; S.top = tank.y < 300; S.side = ((tank.x*97+tank.y*131)|0)%2?1:-1; }
  if((S.tick%240)===0) S.side*=-1;
  const BIAS = (S.isRed? 6 : -6);

  // 1) Target selection: health-weighted distance + angle alignment bonus
  let tgt=null,b=1e18; for(const e of enemies){
    const dx=e.x-tank.x, dy=e.y-tank.y, ang=Math.abs(N(D(dx,dy))-N(S.lastAim||0));
    const align = 1 + Math.min(ang,360-ang)/180 * 0.088;
    const k=e.health*P.healthW + e.distance*P.distW * align; if(k<b){b=k;tgt=e;}
  }

  // 2) Aiming: smoothed velocity estimate + ballistic intercept (bullet speed=8)
  if(tgt){
    let ax=tgt.x, ay=tgt.y, vx=0, vy=0;
    if(S.last){
      const lv=S.lastV||{vx:0,vy:0};
      const ivx=tgt.x-S.last.x, ivy=tgt.y-S.last.y; // instant velocity
      vx=lv.vx*(1-P.smooth)+ivx*P.smooth; vy=lv.vy*(1-P.smooth)+ivy*P.smooth; S.lastV={vx,vy};
      const rx=tgt.x-tank.x, ry=tgt.y-tank.y, s2=64, aa=vx*vx+vy*vy-s2, bb=2*(rx*vx+ry*vy), cc=rx*rx+ry*ry; let t=0;
      if(Math.abs(aa)<1e-6){ t = bb!==0?CL(-cc/bb,0,P.leadCap):0; }
      else { const disc=bb*bb-4*aa*cc; if(disc>=0){ const sd=Math.sqrt(disc), t1=(-bb-sd)/(2*aa), t2=(-bb+sd)/(2*aa); t = CL((t1>0&&t2>0?Math.min(t1,t2):(t1>0?t1:(t2>0?t2:0))),0,P.leadCap);} else { t=CL(H(rx,ry)/8,0,P.leadCap);} }
      ax = tgt.x + vx*P.leadW*t; ay = tgt.y + vy*P.leadW*t;
    }
    const j = ((((S.tick*13 + ((tank.x*7+tank.y*3)|0) )%23)-11)*P.aimJ*0.08) + (P.aimBias||0);
    const aim = D(ax-tank.x,ay-tank.y)+j; S.lastAim = aim; tank.fire(aim); S.last={x:tgt.x,y:tgt.y};
  }

  // 3) Movement helpers
  let mv=0; const go=(a)=>{ if(mv>20) return true; mv++; return tank.move(N(a)); };

  // 3a) Bullet dodge: perpendicular + flee bias + time-to-impact weighting
  let hot=null,sc=1e18; for(const b of bulletInfo){
    const dx=b.x-tank.x,dy=b.y-tank.y; const v=H(b.vx,b.vy)||1, nx=b.vx/v, ny=b.vy/v, proj=dx*nx+dy*ny; if(proj>0){
      const px=b.x-proj*nx,py=b.y-proj*ny, dist=H(px-tank.x,py-tank.y), tt=proj/v, s=dist+tt*P.threatH; if(dist<P.threatR&&s<sc){sc=s;hot=b;}
    }
  }
  if(hot){ const a=D(hot.vx,hot.vy); const side=S.side*P.fleeBias + (BIAS)*0.5; for(const c of [a+90+side,a-90-side,a+120,a-120,a+70,a-70,a+150,a-150]){ if(go(c)) return; } }

  // 3b) Edge avoidance (map 900x600)
  if(tank.x<P.edge){ if(go(0)) return;} if(tank.x>900-P.edge){ if(go(180)) return;} if(tank.y<P.edge){ if(go(90)) return;} if(tank.y>600-P.edge){ if(go(270)) return;}

  // 3c) Ally separation
  let near=null,ad=1e18; for(const a of allies){ if(a.distance<ad){ad=a.distance;near=a;} } if(near&&ad<P.sep){ const aw=D(tank.x-near.x,tank.y-near.y); if(go(aw)) return; if(go(aw+18)) return; if(go(aw-18)) return; }

  // 3d) Opening drift to mitigate spawn bias
  if(S.tick<18){ const open = S.isRed ? [0,12,-12] : [180,168,192]; for(const ang of open){ if(go(ang)) return; } }

  // 3e) Range control + strafing
  if(tgt){ const to=D(tgt.x-tank.x,tgt.y-tank.y), d=tgt.distance; let r0=P.rMin,r1=P.rMax; if((tgt.health<=P.finHP)||enemies.length<=P.aggrRemain){ r0=Math.max(120,r0-P.aggrIn); r1=Math.max(160,r1-P.aggrOut);} if(d<r0){ const aw=to+180+(BIAS)*0.4; if(go(aw)) return; if(go(aw+16)) return; if(go(aw-16)) return; } else if(d>r1){ if(go(to)) return; if(go(to+14)) return; if(go(to-14)) return; } else { const s=to+S.side*P.strafe+(BIAS)*0.5; if(go(s)) return; if(go(s+16)) return; if(go(s-16)) return; } }

  // 3f) Sweeping fallback
  for(const s of [0,60,120,180,240,300]){ if(go(s+(P.bias||0))) return; }
}