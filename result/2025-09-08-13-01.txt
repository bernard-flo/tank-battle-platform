function name(){return "Aegis";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<20.50947130812116){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*-0.09282231272167364 + wx*-0.03599551017824104 + atx*-0.10114981389674561 + obx*-0.018266593473168155 + cx*-0.03178321489221041 + sx*-0.03893089237746188 + rtx*-0.12196229851542474;
  const mvy=evy*-0.09282231272167364 + wy*-0.03599551017824104 + aty*-0.10114981389674561 + oby*-0.018266593473168155 + cy*-0.03178321489221041 + sy*-0.03893089237746188 + rty*-0.12196229851542474;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=2.08257998502636*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Bulwark";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<18){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*0.04310348929191206 + wx*-0.032108730224388995 + atx*0.18077466910488543 + obx*-0.18274740614472057 + cx*-0.026980802285923866 + sx*0.07456337074049016 + rtx*-0.011425777555160527;
  const mvy=evy*0.04310348929191206 + wy*-0.032108730224388995 + aty*0.18077466910488543 + oby*-0.18274740614472057 + cy*-0.026980802285923866 + sy*0.07456337074049016 + rty*-0.011425777555160527;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=1.7550698628125094*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Valkyrie";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<18){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*-0.3375000012068929 + wx*0.1362898112128278 + atx*-0.03212885151614961 + obx*-0.09622419645181933 + cx*0.07644608875038307 + sx*-0.004745765511473274 + rtx*-0.183279696653492;
  const mvy=evy*-0.3375000012068929 + wy*0.1362898112128278 + aty*-0.03212885151614961 + oby*-0.09622419645181933 + cy*0.07644608875038307 + sy*-0.004745765511473274 + rty*-0.183279696653492;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=1.051542784446725*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Raptor";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<18){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*0.12735470580487404 + wx*-0.0065185992530153135 + atx*-0.23902412506608853 + obx*-0.04608025949577313 + cx*-0.021143293150341795 + sx*0.013072435951547737 + rtx*-0.13099558323403182;
  const mvy=evy*0.12735470580487404 + wy*-0.0065185992530153135 + aty*-0.23902412506608853 + oby*-0.04608025949577313 + cy*-0.021143293150341795 + sy*0.013072435951547737 + rty*-0.13099558323403182;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=0*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Spectre";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<20.96590458201514){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*-0.11326956910262065 + wx*0.06333544370282332 + atx*-0.07375395280085198 + obx*0.01046899570090029 + cx*-0.043983787647995334 + sx*-0.020414413176619614 + rtx*-0.2764485917186222;
  const mvy=evy*-0.11326956910262065 + wy*0.06333544370282332 + aty*-0.07375395280085198 + oby*0.01046899570090029 + cy*-0.043983787647995334 + sy*-0.020414413176619614 + rty*-0.2764485917186222;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=0.8620421997520451*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}

// ===== 다음 로봇 =====

function name(){return "Sentinel";}
function type(){return 0;}
function update(tank,enemies,allies,bulletInfo){
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1e-6; return [x/m,y/m];}
  const W=900,H=600;
  // 1) 타겟: 거리+체력 가중
  let target=null, best=1e9;
  for(const e of enemies){ const s=e.distance*0.9 + Math.max(0,e.health)*0.4; if(s<best){best=s; target=e;} }
  // 2) 총알 회피
  let evx=0,evy=0,th=0; for(const b of bulletInfo){ const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6; const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv; const closing=-(rx*ux+ry*uy)/d; if(closing>0){ const px=-uy, py=ux; const w=closing/(1+0.065*d); evx+=px*w; evy+=py*w; th+=w; } }
  ;[evx,evy]=nrm(evx,evy);
  // 3) 벽 회피
  let wx=0,wy=0; const m=60; if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m; if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m; ;[wx,wy]=nrm(wx,wy);
  // 4) 아군 응집/분리
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const c=Math.max(1,allies.length); ax/=c; ay/=c; let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);
  // 5) 타겟 접근/측면 + 저체력 이탈
  let atx=0,aty=0, obx=0,oby=0, rtx=0,rty=0; if(target){ atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n; obx=-aty; oby=atx; }
  if(tank.health<21.515914689030712){ rtx=-(cx||atx); rty=-(cy||aty); const rn=Math.hypot(rtx,rty)||1; rtx/=rn; rty/=rn; }
  // 합성 벡터
  const mvx=evx*0.08634728508141178 + wx*0.2994180012893413 + atx*-0.02612453956777648 + obx*-0.05555051605563174 + cx*0.008142013487488043 + sx*-0.11549080667671648 + rtx*0.03820838958085356;
  const mvy=evy*0.08634728508141178 + wy*0.2994180012893413 + aty*-0.02612453956777648 + oby*-0.05555051605563174 + cy*0.008142013487488043 + sy*-0.11549080667671648 + rty*0.03820838958085356;
  const mvAng=deg(mvx,mvy);
  // 사격: 기본 조준 + 소량 지터 스윕
  if(target){ const aim=deg(target.x-tank.x,target.y-tank.y); const jitter=3.1783033126534357*(Math.random()-0.5); tank.fire(ang(aim+jitter)); }
  if(!tank.move(ang(mvAng))){ if(!tank.move(ang(mvAng+70))){ if(!tank.move(ang(mvAng-70))){ tank.move(Math.random()*360); }}}
}