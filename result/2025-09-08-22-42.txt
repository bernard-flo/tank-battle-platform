function name(){return "Bulwark";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 265 : isT? 168.42635914683342 : 225;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 30;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=1.052045267522335*(isD?1.18:isT?0.92:1.0);
  const wAttack=0.6410761880874634*(isD?1.05:isT?0.95:1.0);
  const wStrafe=0.4778338217735291*(isD?1.2:1.0);
  const wRetreat=0.6022551268339157*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*1.0806557583808898 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.12 + sx*0.3220860621333122 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*1.0806557583808898 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.12 + sy*0.3220860621333122 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 7 : 13);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 7 : 3)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====

function name(){return "Aegis";}
function type(){return 1;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 265 : isT? 194.2901692390442 : 225;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 30;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=1.0546116709709168*(isD?1.18:isT?0.92:1.0);
  const wAttack=0.8014774477481842*(isD?1.05:isT?0.95:1.0);
  const wStrafe=0.5677061975002289*(isD?1.2:1.0);
  const wRetreat=0.6852108120918274*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*0.9713314414024353 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.12 + sx*0.447893009185791 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*0.9713314414024353 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.12 + sy*0.447893009185791 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 6 : 5);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 8 : 5)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====

function name(){return "Viper";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 248.41706901788712 : isT? 165 : 225;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 33.16991722583771;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=1.0787033491134643*(isD?1.18:isT?0.92:1.0);
  const wAttack=0.8057027016878128*(isD?1.05:isT?0.95:1.0);
  const wStrafe=1.024360494017601*(isD?1.2:1.0);
  const wRetreat=0.9*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*0.7523351888656616 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.10969779133796692 + sx*0.4391337865591049 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*0.7523351888656616 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.10969779133796692 + sy*0.4391337865591049 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 6 : 6);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 8 : 3)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====

function name(){return "Wraith";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 296.25332143306736 : isT? 165 : 225;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 30.54039421081543;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=1.2096676987409591*(isD?1.18:isT?0.92:1.0);
  const wAttack=0.9016253818273545*(isD?1.05:isT?0.95:1.0);
  const wStrafe=0.8532189674377441*(isD?1.2:1.0);
  const wRetreat=0.9*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*0.9382436549663543 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.12470095109939576 + sx*0.46568559587001795 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*0.9382436549663543 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.12470095109939576 + sy*0.46568559587001795 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 3 : 6);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 6 : 3)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====

function name(){return "Falcon";}
function type(){return 2;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 257.45491790771484 : isT? 165 : 225;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 28.18877601623535;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=1.1968655242919923*(isD?1.18:isT?0.92:1.0);
  const wAttack=1.0297174844145773*(isD?1.05:isT?0.95:1.0);
  const wStrafe=0.950237823486328*(isD?1.2:1.0);
  const wRetreat=0.9*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*0.8010014266967773 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.10667835617065428 + sx*0.3844992942810058 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*0.8010014266967773 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.10667835617065428 + sy*0.3844992942810058 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 5 : 7);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 8 : 4)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====

function name(){return "Anchor";}
function type(){return 0;}
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  function ang(a){a%=360; if(a<0)a+=360; return a;}
  function deg(x,y){return Math.atan2(y,x)*180/Math.PI;}
  function nrm(x,y){const m=Math.hypot(x,y)||1; return [x/m,y/m];}
  function hash(x){return (Math.sin(x*12.9898+78.233)*43758.5453)%1;}
  function rnd4(a,b,c,d){ let r=hash(a*0.13+b*0.17+c*0.19+d*0.23); if(r<0) r=-r; return r; }
  const W=900,H=600, BS=8; // 총알속도 추정

  // 1) 타겟 선정: 체력/거리/벽 근접/아군 집중 가중
  let target=null, best=1e9;
  for(const e of enemies){
    let nearAllies=0; for(const a of allies){ if(Math.hypot(a.x-e.x,a.y-e.y)<140) nearAllies++; }
    const wall = Math.min(e.x, W-e.x, e.y, H-e.y);
    const wallBias = (wall<120)? (120-wall)*0.05 : 0; // 벽에 몰린 적 우선
    const k = e.distance*0.82 + Math.max(0,e.health)*0.48 - Math.min(35,e.health)*0.62 - nearAllies*6 - wallBias;
    if(k<best){best=k; target=e;}
  }

  // 2) 위협 회피: 접근/근접 총알에 강하게 반응, 시간가중 회피벡터
  let evx=0,evy=0; // 회피 벡터
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const d=Math.hypot(rx,ry)||1e-6;
    const bv=Math.hypot(b.vx,b.vy)||1e-6; const ux=b.vx/bv, uy=b.vy/bv;
    const approach=-(rx*ux+ry*uy); // >0 이면 접근중
    if(approach>0){
      // 충돌 예상 시간 ~ d/BS, 가까울수록 가중, 진행방향 수직으로 회피
      const ttc = d/BS; const w = approach/(1+0.06*d) * (1/(0.5+ttc));
      const px=-uy, py=ux; evx += px*w; evy += py*w;
    }
  }
  ;[evx,evy]=nrm(evx,evy);

  // 3) 벽 회피: 소프트 펜스
  let wx=0,wy=0; const m=70;
  if(tank.x<m) wx+=1- tank.x/m; if(W-tank.x<m) wx-=1- (W-tank.x)/m;
  if(tank.y<m) wy+=1- tank.y/m; if(H-tank.y<m) wy-=1- (H-tank.y)/m;
  ;[wx,wy]=nrm(wx,wy);

  // 4) 아군 응집/분리로 충돌 방지 및 라인 유지
  let ax=0,ay=0; for(const a of allies){ax+=a.x; ay+=a.y;} const cnt=Math.max(1,allies.length); ax/=cnt; ay/=cnt;
  let cx=ax?ax-tank.x:0, cy=ay?ay-tank.y:0; ;[cx,cy]=nrm(cx,cy);
  let sx=0,sy=0; for(const a of allies){ const dx=tank.x-a.x, dy=tank.y-a.y; const d=Math.hypot(dx,dy)||1; if(d<85){ sx+=dx/(d*d); sy+=dy/(d*d);} } ;[sx,sy]=nrm(sx,sy);

  // 5) 목표 기반 전투거리 제어 + 측면기동
  let atx=0,aty=0, obx=0,oby=0, ringx=0,ringy=0, rtx=0,rty=0; if(target){
    // 기본 목표/측면 벡터
    atx=(target.x-tank.x); aty=(target.y-tank.y); const n=Math.hypot(atx,aty)||1; atx/=n; aty/=n;
    obx=-aty; oby=atx; // 스트레이프

    // 타입별 선호 거리
    const isT=tank.type===1, isD=tank.type===2;
    const prefer = isD? 265 : isT? 165 : 227.13081926107404;
    const d = Math.max(1, target.distance);
    const diff = d - prefer; // +면 멀다 -> 접근, -면 가깝다 -> 이탈
    const g = Math.max(-1, Math.min(1, diff/180)); // 완만한 링 제어 게인
    ringx = atx * (g>0? +1 : -1) * Math.abs(g);
    ringy = aty * (g>0? +1 : -1) * Math.abs(g);

    // 저체력 시 후퇴 성향 강화
    const low = tank.health < 30;
    if(low){ rtx=-atx; rty=-aty; }
  }

  // 6) 가중치 (타입 보정)
  const isT=tank.type===1, isD=tank.type===2;
  const wBullet=0.9603139019012452*(isD?1.18:isT?0.92:1.0);
  const wAttack=0.7175223583579062*(isD?1.05:isT?0.95:1.0);
  const wStrafe=0.6418312495946884*(isD?1.2:1.0);
  const wRetreat=0.6840981292724609*(isD?1.1:1.0);

  // 7) 최종 이동 벡터 합성
  const mvx = evx*wBullet + wx*0.8666240406036376 + atx*wAttack + obx*wStrafe + ringx*0.9 + cx*0.13180184215307236 + sx*0.34656995296478277 + rtx*wRetreat;
  const mvy = evy*wBullet + wy*0.8666240406036376 + aty*wAttack + oby*wStrafe + ringy*0.9 + cy*0.13180184215307236 + sy*0.34656995296478277 + rty*wRetreat;
  let mvAng = deg(mvx,mvy);

  // 8) 사격: 결정적 지터(좌표 기반) + 소폭 스윕 + 스트레이프 리드 힌트
  if(target){
    const base = target.angle;
    const dist = Math.max(1, target.distance);
    const J = (dist<200? 5 : 7);
    const r = rnd4(tank.x, tank.y, target.x, target.y) - 0.5; // 결정적 지터 [-0.5,0.5]
    const jitter = J * r;
    const sweep = (isD? 8 : 4)*(rnd4(target.x, target.y, tank.x, tank.y)-0.5);
    const leadHint = (obx||oby)? deg(obx,oby)*0.18 : 0;
    const aim = ang(base + jitter + sweep + leadHint);
    tank.fire(aim);
  }

  // 9) 이동: 실패 시 우회 각도 → 무작위 분산
  const a0=ang(mvAng);
  if(!tank.move(a0)){
    if(!tank.move(ang(a0+70))){ if(!tank.move(ang(a0-70))){ tank.move(Math.random()*360); }}
  }
}

// ===== 다음 로봇 =====
