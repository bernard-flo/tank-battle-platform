// Apex-Swarm v2 â€” coordinated kiting, predictive aim, bullet-aware evasion
// Six self-contained robots with role-tuned ranges and orbiting behavior.
// Notes: Each bot keeps its own state; no cross-bot globals in secure runner.

// ===== R1 =====
function name(){ return "Apex-T1"; }
function type(){ return Type.TANKER; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict";
  __state.tick=(__state.tick||0)+1;
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;};
  const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5));
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;

  // Target priority: finish low-health first, then dealers, then distance
  const W={wHealth:1.22,wDist:0.06,wDealer:22,wFinish:18};
  let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=28) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }

  // Predictive aim using smoothed velocity and quadratic intercept
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<90 && Math.abs(__state.lastTgt.y-tgt.y)<90){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; }
    __state.lvx=__state.lvx*0.55+vx*0.45; __state.lvy=__state.lvy*0.55+vy*0.45; const rx=tgt.x-tank.x, ry=tgt.y-tank.y;
    const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr;
    if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} }
    t=clamp(t,0,22); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*19+(tank.x*11+tank.y*7)|0)%11)-5)*0.11; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }

  // Movement scoring
  const P={edge:44, allySep:62, horizon:7, bulletRad:23, bulletWeight:0.115, etaW:0.17,
           minRange:150, maxRange:230, lowHpPad:34, finishHp:26,
           inertia:0.0022, edgeW:0.086, rangeInW:0.017, rangeOutW:0.011, orbit:18, fleeBias:12};
  if(tgt&&tgt.health<=P.finishHp){ P.minRange-=28; P.maxRange-=22; }
  if(tank.health<70) P.minRange+=P.lowHpPad;

  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y;
    for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; // edges
      if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW*0.5; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW*0.5;
      // allies separation
      for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.027; }
      // bullets lookahead with arrival bias
      for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } }
      // maintain range to tgt; light repulsion from others
      if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; }
      for(const e of enemies){ const de=H(px-e.x,py-e.y); if(de<95) risk+=(95-de)*0.006; }
    }
    if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; }
    return risk; }

  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); };
  if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+60*__state.spinBias); add(base-60*__state.spinBias); }
  // bullet perpendicular escape
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } }
  if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); }
  for(let s=0;s<360;s+=30) add(s);
  cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } }
  const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}

// ===== R2 =====
function name(){ return "Apex-T2"; }
function type(){ return Type.TANKER; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict"; __state.tick=(__state.tick||0)+1; const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5)); const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;
  const W={wHealth:1.18,wDist:0.06,wDealer:23,wFinish:19}; let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=27) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<90 && Math.abs(__state.lastTgt.y-tgt.y)<90){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; } __state.lvx=__state.lvx*0.55+vx*0.45; __state.lvy=__state.lvy*0.55+vy*0.45; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,22); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*21+(tank.x*13+tank.y*5)|0)%11)-5)*0.1; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }
  const P={edge:44, allySep:62, horizon:7, bulletRad:23, bulletWeight:0.115, etaW:0.17, minRange:150, maxRange:230, lowHpPad:34, finishHp:26, inertia:0.0022, edgeW:0.086, rangeInW:0.017, rangeOutW:0.011, orbit:18, fleeBias:12}; if(tgt&&tgt.health<=P.finishHp){ P.minRange-=28; P.maxRange-=22; } if(tank.health<70) P.minRange+=P.lowHpPad;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW*0.5; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW*0.5; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.027; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } for(const e of enemies){ const de=H(px-e.x,py-e.y); if(de<95) risk+=(95-de)*0.006; } } if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); }; if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+60*__state.spinBias); add(base-60*__state.spinBias); }
  let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } } if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); } for(let s=0;s<360;s+=30) add(s); cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } } const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}

// ===== R3 =====
function name(){ return "Apex-D1"; }
function type(){ return Type.DEALER; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict"; __state.tick=(__state.tick||0)+1; const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5)); const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;
  const W={wHealth:1.34,wDist:0.07,wDealer:8,wFinish:16}; let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=24) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<95 && Math.abs(__state.lastTgt.y-tgt.y)<95){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; } __state.lvx=__state.lvx*0.52+vx*0.48; __state.lvy=__state.lvy*0.52+vy*0.48; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,24); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*23+(tank.x*7+tank.y*13)|0)%13)-6)*0.08; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }
  const P={edge:46, allySep:64, horizon:8, bulletRad:22, bulletWeight:0.12, etaW:0.18, minRange:235, maxRange:380, lowHpPad:52, finishHp:22, inertia:0.0021, edgeW:0.085, rangeInW:0.017, rangeOutW:0.0105, orbit:24, fleeBias:14}; if(tgt&&tgt.health<=P.finishHp){ P.minRange-=40; P.maxRange-=34; } if(tank.health<40) P.minRange+=P.lowHpPad;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); }; if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+55*__state.spinBias); add(base-55*__state.spinBias); } let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } } if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); } for(let s=0;s<360;s+=30) add(s); cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } } const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}

// ===== R4 =====
function name(){ return "Apex-D2"; }
function type(){ return Type.DEALER; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict"; __state.tick=(__state.tick||0)+1; const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5)); const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;
  const W={wHealth:1.34,wDist:0.07,wDealer:8,wFinish:16}; let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=24) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<95 && Math.abs(__state.lastTgt.y-tgt.y)<95){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; } __state.lvx=__state.lvx*0.52+vx*0.48; __state.lvy=__state.lvy*0.52+vy*0.48; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,24); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*23+(tank.x*7+tank.y*13)|0)%13)-6)*0.08; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }
  const P={edge:46, allySep:64, horizon:8, bulletRad:22, bulletWeight:0.12, etaW:0.18, minRange:235, maxRange:380, lowHpPad:52, finishHp:22, inertia:0.0021, edgeW:0.085, rangeInW:0.017, rangeOutW:0.0105, orbit:24, fleeBias:14}; if(tgt&&tgt.health<=P.finishHp){ P.minRange-=40; P.maxRange-=34; } if(tank.health<40) P.minRange+=P.lowHpPad;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); }; if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+55*__state.spinBias); add(base-55*__state.spinBias); } let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } } if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); } for(let s=0;s<360;s+=30) add(s); cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } } const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}

// ===== R5 =====
function name(){ return "Apex-N1"; }
function type(){ return Type.NORMAL; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:1};
function update(tank,enemies,allies,bulletInfo){
  "use strict"; __state.tick=(__state.tick||0)+1; const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5)); const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;
  const W={wHealth:1.28,wDist:0.08,wDealer:16,wFinish:17}; let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=26) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<92 && Math.abs(__state.lastTgt.y-tgt.y)<92){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; } __state.lvx=__state.lvx*0.54+vx*0.46; __state.lvy=__state.lvy*0.54+vy*0.46; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,23); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*20+(tank.x*9+tank.y*9)|0)%11)-5)*0.095; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }
  const P={edge:45, allySep:64, horizon:7, bulletRad:22, bulletWeight:0.115, etaW:0.17, minRange:200, maxRange:300, lowHpPad:44, finishHp:24, inertia:0.0022, edgeW:0.086, rangeInW:0.016, rangeOutW:0.0105, orbit:22, fleeBias:13}; if(tgt&&tgt.health<=P.finishHp){ P.minRange-=36; P.maxRange-=30; } if(tank.health<50) P.minRange+=P.lowHpPad;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); }; if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+50*__state.spinBias); add(base-50*__state.spinBias); } let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } } if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); } for(let s=0;s<360;s+=30) add(s); cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } } const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}

// ===== R6 =====
function name(){ return "Apex-D3"; }
function type(){ return Type.DEALER; }
let __state={tick:0,lastMove:undefined,lastTgt:null,lvx:0,lvy:0,spinBias:-1};
function update(tank,enemies,allies,bulletInfo){
  "use strict"; __state.tick=(__state.tick||0)+1; const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI; const toRad=(a)=>a*Math.PI/180; const norm=(a)=>{a%=360; if(a<0)a+=360; return a|0;}; const H=Math.hypot; const BUL=8; const SPEED=(tank.type===1?3:(tank.type===2?6:5)); const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v; const dot=(ax,ay,bx,by)=>ax*bx+ay*by;
  const W={wHealth:1.34,wDist:0.07,wDealer:8,wFinish:16}; let tgt=null,best=1e12; for(const e of enemies){ let s=e.health*W.wHealth + e.distance*W.wDist; if(e.health<=24) s-=W.wFinish; if((e.type|0)===2) s-=W.wDealer; if(s<best){best=s;tgt=e;} }
  if(tgt){ let vx=0,vy=0; if(__state.lastTgt && Math.abs(__state.lastTgt.x-tgt.x)<95 && Math.abs(__state.lastTgt.y-tgt.y)<95){ vx=tgt.x-__state.lastTgt.x; vy=tgt.y-__state.lastTgt.y; } __state.lvx=__state.lvx*0.52+vx*0.48; __state.lvy=__state.lvy*0.52+vy*0.48; const rx=tgt.x-tank.x, ry=tgt.y-tank.y; const vv=__state.lvx*__state.lvx+__state.lvy*__state.lvy, rv=rx*__state.lvx+ry*__state.lvy, rr=rx*rx+ry*ry; let t=0; const A=vv-BUL*BUL,B=2*rv,C=rr; if(Math.abs(A)<1e-6){ t=(B!==0?-C/B:0);} else { const disc=B*B-4*A*C; if(disc>=0){ const s=Math.sqrt(disc); const t1=(-B+s)/(2*A), t2=(-B-s)/(2*A); t=Math.max(t1,t2); if(t<0) t=Math.max(t1,t2);} } t=clamp(t,0,24); const ax=tgt.x+__state.lvx*t, ay=tgt.y+__state.lvy*t; const jitter=(((__state.tick*23+(tank.x*7+tank.y*13)|0)%13)-6)*0.08; tank.fire(toDeg(ax-tank.x,ay-tank.y)+jitter); __state.lastTgt={x:tgt.x,y:tgt.y}; }
  const P={edge:46, allySep:64, horizon:8, bulletRad:22, bulletWeight:0.12, etaW:0.18, minRange:235, maxRange:380, lowHpPad:52, finishHp:22, inertia:0.0021, edgeW:0.085, rangeInW:0.017, rangeOutW:0.0105, orbit:24, fleeBias:14}; if(tgt&&tgt.health<=P.finishHp){ P.minRange-=40; P.maxRange-=34; } if(tank.health<40) P.minRange+=P.lowHpPad;
  function riskForAngle(a){ const ar=toRad(a); const dx=Math.cos(ar)*SPEED, dy=Math.sin(ar)*SPEED; let risk=0; let px=tank.x, py=tank.y; for(let k=1;k<=P.horizon;k++){ px+=dx; py+=dy; if(px<P.edge||px>900-P.edge) risk+=(P.edge-Math.min(px,900-px))*P.edgeW; if(py<P.edge||py>600-P.edge) risk+=(P.edge-Math.min(py,600-py))*P.edgeW; for(const al of allies){ const d=H(px-al.x,py-al.y); if(d<P.allySep) risk+=(P.allySep-d)*0.03; } for(const b of bulletInfo){ const bx=b.x+b.vx*k, by=b.y+b.vy*k; const relx=px-bx, rely=py-by; const d=H(relx,rely); if(d<P.bulletRad){ const vmag=H(b.vx,b.vy)||1; const ux=b.vx/vmag, uy=b.vy/vmag; const along=dot(relx,rely,ux,uy); const eta=Math.max(0,-along)/BUL; const w=P.bulletWeight*(1+P.etaW*(P.horizon-k)); risk+=(P.bulletRad-d)*w*(1+0.22*Math.min(1,eta)); } } if(tgt){ const d=H(px-tgt.x,py-tgt.y); if(d<P.minRange) risk+=(P.minRange-d)*P.rangeInW; else if(d>P.maxRange) risk+=(d-P.maxRange)*P.rangeOutW; } } if(__state.lastMove!==undefined){ const da=Math.abs(((a-__state.lastMove)%360+540)%360-180); risk+=da*P.inertia; } return risk; }
  const cands=[]; const add=(ang)=>{ const k=norm(Math.round(ang)); if(!cands.includes(k)) cands.push(k); }; if(tgt){ const base=toDeg(tgt.x-tank.x,tgt.y-tank.y); add(base); add(base+180); add(base+90+P.orbit*__state.spinBias); add(base-90-P.orbit*__state.spinBias); add(base+55*__state.spinBias); add(base-55*__state.spinBias); } let hot=null, md=1e9; for(const b of bulletInfo){ const dx=b.x-tank.x, dy=b.y-tank.y; const v=H(b.vx,b.vy)||1; const nx=b.vx/v, ny=b.vy/v; const proj=dx*nx+dy*ny; if(proj>0){ const px=b.x-proj*nx, py=b.y-proj*ny; const d=H(px-tank.x,py-tank.y); if(d<md){ md=d; hot=b; } } } if(hot){ const a=toDeg(hot.vx,hot.vy); add(a+90+P.fleeBias); add(a-90-P.fleeBias); add(a+135); add(a-135); } for(let s=0;s<360;s+=30) add(s); cands.sort((a,b)=>riskForAngle(a)-riskForAngle(b)); for(const a of cands){ if(tank.move(a)){ __state.lastMove=a; return; } } const fb=norm((__state.tick*37+tank.x+tank.y)|0); if(tank.move(fb)){ __state.lastMove=fb; return; }
}
