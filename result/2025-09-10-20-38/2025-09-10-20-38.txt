function name(){return "Nova-LeadHi-A1";}
function type(){return Type.TANKER;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":16,"leadWeight":1.08,"aimJitter":0.16,"minRange":150,"maxRange":250,"strafeAngle":28,"strafePeriod":14,"threatRadius":165,"threatFleeBias":14,"maxThreatTime":16,"timeWeight":4,"allySep":64,"edgeMargin":46,"bias":-10,"targetHealthWeight":1.3,"targetDistWeight":0.1,"finishHp":25,"finishRemain":3,"finishMinDelta":35,"finishMaxDelta":25};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((0)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-LeadHi-A2";}
function type(){return Type.TANKER;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":16,"leadWeight":1.08,"aimJitter":0.16,"minRange":160,"maxRange":260,"strafeAngle":28,"strafePeriod":14,"threatRadius":165,"threatFleeBias":14,"maxThreatTime":16,"timeWeight":4,"allySep":64,"edgeMargin":46,"bias":10,"targetHealthWeight":1.3,"targetDistWeight":0.1,"finishHp":25,"finishRemain":3,"finishMinDelta":35,"finishMaxDelta":25};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((1)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-LeadHi-A3";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":18,"leadWeight":1.1,"aimJitter":0.14,"minRange":225,"maxRange":370,"strafeAngle":34,"strafePeriod":10,"threatRadius":150,"threatFleeBias":14,"maxThreatTime":18,"timeWeight":5,"allySep":62,"edgeMargin":46,"bias":-6,"targetHealthWeight":1.35,"targetDistWeight":0.1,"finishHp":22,"finishRemain":3,"finishMinDelta":36,"finishMaxDelta":26};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((2)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-LeadHi-A4";}
function type(){return Type.DEALER;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":18,"leadWeight":1.1,"aimJitter":0.14,"minRange":225,"maxRange":370,"strafeAngle":26,"strafePeriod":10,"threatRadius":150,"threatFleeBias":14,"maxThreatTime":18,"timeWeight":5,"allySep":62,"edgeMargin":46,"bias":6,"targetHealthWeight":1.35,"targetDistWeight":0.1,"finishHp":22,"finishRemain":3,"finishMinDelta":36,"finishMaxDelta":26};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((3)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-LeadHi-A5";}
function type(){return Type.NORMAL;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":16,"leadWeight":1.08,"aimJitter":0.16,"minRange":185,"maxRange":305,"strafeAngle":28,"strafePeriod":12,"threatRadius":158,"threatFleeBias":14,"maxThreatTime":16,"timeWeight":4,"allySep":62,"edgeMargin":46,"bias":4,"targetHealthWeight":1.28,"targetDistWeight":0.1,"finishHp":24,"finishRemain":3,"finishMinDelta":32,"finishMaxDelta":24};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((4)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}


// ===== 다음 로봇 =====

function name(){return "Nova-LeadHi-A6";}
function type(){return Type.NORMAL;}
let __state = { last:null, lastVel:null, tick:0, strafeFlip:0 };
function update(tank,enemies,allies,bulletInfo){
  const toDeg=(x,y)=>Math.atan2(y,x)*180/Math.PI;
  const norm=(a)=>{a%=360; if(a<0)a+=360; return a;};
  const clamp=(v,lo,hi)=>v<lo?lo:v>hi?hi:v;
  const hypot=Math.hypot; const sq=(x)=>x*x;
  const P={"leadCap":16,"leadWeight":1.08,"aimJitter":0.16,"minRange":185,"maxRange":305,"strafeAngle":24,"strafePeriod":12,"threatRadius":158,"threatFleeBias":14,"maxThreatTime":16,"timeWeight":4,"allySep":62,"edgeMargin":46,"bias":-4,"targetHealthWeight":1.28,"targetDistWeight":0.1,"finishHp":24,"finishRemain":3,"finishMinDelta":32,"finishMaxDelta":24};
  __state.tick=(__state.tick||0)+1;
  
  // 1) Target selection (stick to lowest health; tie -> nearest)
  let tgt=null; let best=1e9; let minDist=1e9;
  for(const e of enemies){
    const key = e.health*P.targetHealthWeight + e.distance*P.targetDistWeight;
    if(key<best || (Math.abs(key-best)<1e-6 && e.distance<minDist)){
      best=key; minDist=e.distance; tgt=e;
    }
  }

  // 2) Predictive aim using constant-velocity intercept solution
  if(tgt){
    let ex=tgt.x, ey=tgt.y; let aimX=ex, aimY=ey;
    if(__state.last){
      const vx=(tgt.x-__state.last.x); // px per tick
      const vy=(tgt.y-__state.last.y);
      // Smooth velocity
      if(!__state.lastVel){ __state.lastVel={vx,vy}; } else {
        __state.lastVel.vx = __state.lastVel.vx*0.45 + vx*0.55;
        __state.lastVel.vy = __state.lastVel.vy*0.45 + vy*0.55;
      }
      const rx = ex - tank.x; const ry = ey - tank.y;
      const vvx = __state.lastVel.vx; const vvy = __state.lastVel.vy;
      const s = 8; // bullet speed px/tick
      const a = (vvx*vvx+vvy*vvy) - s*s;
      const b = 2*(rx*vvx + ry*vvy);
      const c = (rx*rx + ry*ry);
      let tLead=null;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) tLead = clamp(-c/b, 0, P.leadCap);
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const sqrt = Math.sqrt(disc);
          const t1 = (-b - sqrt) / (2*a);
          const t2 = (-b + sqrt) / (2*a);
          const tCand = [t1,t2].filter((t)=>t>0).sort((x,y)=>x-y)[0];
          if (tCand !== undefined) tLead = clamp(tCand, 0, P.leadCap);
        }
      }
      if(tLead===null){
        const d=hypot(rx,ry); tLead=clamp(d/s,0,P.leadCap);
      }
      aimX = ex + vvx * P.leadWeight * tLead;
      aimY = ey + vvy * P.leadWeight * tLead;
    }
    const jitter = ((((tank.x*31+tank.y*17)|0)%23)-11)*0.08 * P.aimJitter;
    const fireAngle = toDeg(aimX-tank.x, aimY-tank.y) + jitter;
    tank.fire(fireAngle);
    __state.last = { x:tgt.x, y:tgt.y };
  }

  // move helper
  let tries=0; const tryMove=(a)=>{tries++; return tank.move(norm(a));};

  // 3) Bullet avoidance with time-of-closest-approach
  let threat=null; let score=1e9;
  for(const b of bulletInfo){
    const rx=b.x-tank.x, ry=b.y-tank.y; const vv=sq(b.vx)+sq(b.vy)||1e-6;
    const tca = -(rx*b.vx+ry*b.vy)/vv; // ticks to closest
    if(tca < 0 || tca > P.maxThreatTime) continue;
    const px = b.x + b.vx*tca; const py = b.y + b.vy*tca;
    const d = hypot(px-tank.x, py-tank.y);
    const s = d + tca*P.timeWeight; // lower is worse
    if(d < P.threatRadius && s < score){ score=s; threat={ tca, b } }
  }
  if(threat){
    const a = toDeg(threat.b.vx, threat.b.vy);
    const flip = (((5)%2) ? 1 : -1) * ( ((__state.tick>>3)&1) ? -1:1 );
    const side = 90 + P.threatFleeBias*flip + P.bias*0.5;
    const cand=[a+side, a-side, a+side+30, a-side-30, a+120, a-120];
    for(const c of cand){ if(tryMove(c)) return; }
  }

  // 4) Edge avoidance
  if(tank.x < P.edgeMargin){ if(tryMove(0+P.bias)) return; }
  if(tank.x > 900-P.edgeMargin){ if(tryMove(180+P.bias)) return; }
  if(tank.y < P.edgeMargin){ if(tryMove(90+P.bias)) return; }
  if(tank.y > 600-P.edgeMargin){ if(tryMove(270+P.bias)) return; }

  // 5) Ally separation (mild)
  let near=null, ad=1e9; for(const a of allies){ if(a.distance<ad){ ad=a.distance; near=a; } }
  if(near && ad < P.allySep){
    const away = toDeg(tank.x-near.x, tank.y-near.y) + P.bias*0.2;
    if(tryMove(away)) return; if(tryMove(away+24)) return; if(tryMove(away-24)) return;
  }

  // 6) Engagement spacing + adaptive strafing
  if(tgt){
    const to = toDeg(tgt.x-tank.x, tgt.y-tank.y);
    const d = tgt.distance;
    let minR=P.minRange, maxR=P.maxRange;
    const remain = enemies.length;
    if((tgt.health<=P.finishHp) || remain<=P.finishRemain){ minR-=P.finishMinDelta; maxR-=P.finishMaxDelta; }
    if(d < minR){
      const away = to+180 + P.bias*0.4;
      if(tryMove(away)) return; if(tryMove(away+22)) return; if(tryMove(away-22)) return;
    } else if(d > maxR){
      if(tryMove(to)) return; if(tryMove(to+16)) return; if(tryMove(to-16)) return;
    } else {
      // toggle strafe every few ticks for desync
      if((__state.tick % P.strafePeriod)===0) __state.strafeFlip ^= 1;
      const dir = __state.strafeFlip ? P.strafeAngle : -P.strafeAngle;
      const side = to + dir + P.bias*0.5;
      if(tryMove(side)) return; if(tryMove(side+18)) return; if(tryMove(side-18)) return;
    }
  }

  // 7) Fallback sweep
  const sweep=[0,60,120,180,240,300];
  for(const s of sweep){ if(tryMove(s+P.bias)) return; }
}
